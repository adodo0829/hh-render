# 问题

各业务系统和权限系统都是比较独立的，主要是融合功能带来的一些问题

## 系统层面设计问题

融合系统数据隔离问题

所有的融合系统在代码层面其实都是同一个应用，只不过每个系统在运行时都有自己的路由菜单，数据权限等；

- 假如浏览器打开了多个融合系统，如何区分不同融合系统？url 传参判断

当前打开页面的导航数据是存在浏览器本地的，多个融合系统会在浏览器本地存储读取导航信息，如果保证互不影响？

利用 sessionStorage 的跨标签页/窗口隔离的特性，即使是同一个页面，不同浏览器标签页或窗口中的 sessionStorage 也是隔离的，它们之间不能共享数据。

## 微前端框架-导航路由跳转问题

由于路由 mirco 的路由系统实现中，主子应用是隔离的，所有主子应用路由互跳需要额外进行处理

所有从主应用基座发出去的路由跳转请求，如果是主应用自己的，有自己的路由实例来处理， 如果是子应用的路由地址都通过事件的方式向子应用派发，子应用接受到了用自己的路由实例进行跳转；

子应用在内部跳转时理论上也需要通知主应用去更新当前打开的导航页面,
但是这里我们设计的是 直接去更改主应用内部的 store 数据源来实现数据 和 UI 同步，这样我们所有的代码逻辑都在 mian.js 实现，方便维护

## 微前端框架-子系统路由页面的缓存问题

一般状态下，我们用 vue 的 keep-alive 组件可以实现页面级别的缓存，下次打开时不直接从 0 渲染，而是用缓存组件来渲染；
我们根据 框架文档 对子应用配置完成发现有些页面并未生效;

查看 keepalive 源码发现，当时 keepalive 组件是 组件 name 为 key 来实现缓存的，那我们在开发过程中会遇到 各开发定义的页面组件 name 相同的情况，这里缓存可能会出现失效的情况;

我们对 keepalive 进行了重新实现，由于我们在设计时每个页面的 path 是唯一的，我们已 path 为 key 对 keepalive 进行重写，在主子页面互相切换的过程中，keepalive 依然是生效的

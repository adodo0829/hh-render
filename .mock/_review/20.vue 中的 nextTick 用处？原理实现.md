# nextTick

任何一个 api 出现都是有它存在的场景的；

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

## 理解下次更新（本轮操作）

第一个 tick（图例中第一个步骤，即'本次更新循环'）：

- 首先修改数据，这是同步任务。同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈，此时还未涉及 DOM 。
- Vue 开启一个异步队列，并缓存在此事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。
  因为 vue 采用的`异步更新机制`，当监听到组件中数据发生变化的时候不会立即去更新 DOM；
  当数据状态发生改变的时候，会通知到 Watcher，Watcher 会通知页面发生更新，触发虚拟 Dom 的 patch 流程，然后更新页面视图。但是，现在 Watcher 触发虚拟 Dom 的流程不是同步的，而是异步的，Vue 当中有一个队列，每当需要渲染时，会将 Watcher 推送到这个队列当中，在下次事件循环中再让 Watcher 触发渲染流程

第二个 tick(下次更新循环)
同步任务执行完毕，开始执行异步 watcher 队列的任务，更新 DOM

第三个 tick(文档提到的：下次 DOM 更新循环结束之后)  
通过 Vue.nextTick 获取到改变后的 DOM

## 实现

nextTick 的实现原理也是利用事件循环来进行异步操作，然后等 vue 的事件循环结束之后，再执行回调函数；

vue 将传入的回调函数包装成异步任务（通常是用微任务 promise.then 进行包装，加入微任务队列），nextTick 还设置了状态锁 pedding，通过 pedding 来判断当前队列当中是否已经存在一个 nextTick 的任务；

## 怎么保证顺序的？

先改值，再调nextTick

由 nextTick 的源码可以看出，nextTick 本质就是创建了一个微任务（不考虑 setTimeout），将其回调推入微任务队列。
vue 中一个事件循环中的所有 dom 更新操作也是一个微任务，两者属于同一优先级，`执行先后只于入队的先后有关`，

换句话说，如果你先写了 nextTick，再写赋值语句（在此之前没有触发 dom 更新的操作），那在 nextTick 中获取的可就不是更新后的 dom 了

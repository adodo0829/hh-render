# 微前端

为什么需要微前端？ 当然是业务需要。

微应用不宜拆分过细，建议按照业务域来做拆分。业务关联紧密的功能单元应该做成一个微应用，反之关联不紧密的可以考虑拆分成多个微应用。

一个判断业务关联是否紧密的标准：
看这个微应用与其他微应用是否有频繁的通信需求。
如果有可能说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。

## 改造背景

1.代码设计 & 产品可维护性问题
系统菜单资源，按钮资源可以在前端定义写入，但不能放在前端维护，需要落库维护，不然定制化还是得拉分支改代码；
统一登录目前是两个系统组成，权限系统 + 基座系统；每次迭代都需要改两个系统的代码，且版本控制数量会出现交叉，不利于迭代维护。
可以考虑直接把权限管理系统做成基座应用，用来接入业务子系统；

顶部的公共区域（系统切换，用户信息，消息通知等）应该只在基座应用里开发和维护，业务子系统不需要关心 （产品设计问题）
各子系统路径跳转目前都在前端代码里进行拼接，需要把所有的统一平台里的跳转业务系统的逻辑通过前端界面配置后写到后台数据库进行维护
前端存在的写死代码；
需要将大部分前端写死的逻辑抽离到前端界面进行配置落库，根据接口来动态化渲染和操作

基座系统存在设计问题
编译时融合

2.产品设计问题
新建系统个数 数量限制 考虑了没？可以无限创建
权限系统的消息通知功能 会耦合 业务子系统的代码逻辑；这个功能应该设计在基座系统里，不应该去影响其他业务系统的代码逻辑

3.产品体验问题
对于系统内输入的未知路径，主应用未匹配到的或者无权限的，可以增加 404 空白占位页面

## 重构目标

a.将路由基座系统 和 权限控制系统 合并为一个应用，减少系统依赖个数，降低维护成本

b.去掉不合理产品功能，前后端功能设计；重新设计此部分功能 （待具体评估）

c.将基于前端项目构建融合 改为 基于前端运行时提供共用容器(微应用的架构方式)

d.涉及到动态路由逻辑()，一定要不要写死，动态接口返回或者用配置表来维护

e.统一平台主要功能：

给用户配置权限，权限控制逻辑应用在业务系统自己做(按钮，页面等)
控制主，子应用菜单资源展示
公共功能配置，业务系统通过接口拉取， 勿要写死在前端

f.简化路由菜单配置文件，增加字段适配自定义路由菜单需求已经其他自定义控制需求

## qiankun

qiankun 通过使用 single-spa，实现了应用的懒加载、路由处理和应用入口选择等功能。
它使用了一个更完整的应用加载方案：import-html-entry
允许以 html 文件为应用入口，然后通过一个 html 解析器从文件中提取 js 和 css 依赖，并通过 fetch 下载依赖

路由机制：single-spa 通过监听 URL 的变化，自动加载和卸载对应的微应用。
它在初始化时会注册一个全局的路由钩子，当 URL 发生变化时，该钩子会根据当前的 URL 匹配到对应的微应用，并触发微应用的生命周期钩子

#### 使用须知

后端所有的接口和资源都需要支持跨域，需要后端放开处理。
主应用的项目需要支持 history 模式用来兼容子应用加载。
子应用不应具有登录、权限体系，所有统一的鉴权体系应服从主应用管理。
vue-router 要加上 subapp 名称或者严格的业务路由名称作为标识的基准路由，以防止路由冲突。
禁止污染全局样式或者 UI 组件库样式，严格遵守样式开发规范(修改局部样式加上自定义的类名)，原则上所有组件样式均加上 scoped 作用域，以防止污染主应用样式。
禁用 window.localStorage.clear()。对自身的本地数据单独 remove。
子应用实例化时，如果选择以 id 形式初始化$el 元素，id 的值要加上具体的 subapp 名称(如 id=”wms-app”)，不能直接写 id=”app”,防止多个 subapp 实例化冲突。

## micro-app

`micro-app` 是一个微前端框架，其运行原理主要基于 Web Components 技术，特别是 Custom Elements 和 Shadow DOM。以下是 `micro-app` 的核心运行原理：

1. **类 WebComponent 实现**：
   `micro-app` 借鉴了 Web Components 的思想，通过 Custom Element 结合自定义的 Shadow DOM 实现了类似于 WebComponent 的功能。这允许 `micro-app` 在基座应用中以一行代码的形式渲染微前端应用，同时保持了样式和脚本的隔离。

2. **Custom Elements 基础**：
   `micro-app` 的核心功能构建在 Custom Elements 基础之上。Custom Elements 用于创建自定义标签，并提供了元素的渲染、卸载、属性修改等钩子函数。这些钩子函数帮助开发者获知微应用的渲染时机，并将自定义标签作为容器，确保微应用的所有元素和样式作用域都无法逃离容器边界，形成一个封闭的环境。

3. **Shadow DOM 隔离**：
   `micro-app` 使用 Shadow DOM 提供了样式隔离和元素隔离，确保子应用的样式和脚本不会影响主应用，也不会被主应用影响。这种隔离机制减少了不同应用之间的冲突，提高了系统的稳定性。

4. **数据通信**：
   `micro-app` 实现了主应用和子应用之间的数据通信机制。这种通信是绑定的，主应用只能向指定的子应用发送数据，子应用只能向主应用发送数据，有效避免了数据污染和多个子应用间的相互影响。通信和数据请求是异步执行的，多个请求会在下一帧合并为一次执行。

5. **资源系统**：
   `micro-app` 提供了资源系统的管理，包括自动补全子应用相对地址的资源路径、资源共享以及资源过滤。资源共享可以提升渲染速度，而资源过滤允许指定某些资源不被加载。

6. **预加载机制**：
   `micro-app` 支持预加载子应用的静态资源，以提升子应用的首次渲染速度。预加载会在浏览器空闲时间执行，以避免影响主应用的性能。

7. **兼容性**：
   `micro-app` 不依赖特定的前端框架，可以与任意前端技术栈集成，包括但不限于 React、Vue、Angular 等。

8. **零依赖**：
   `micro-app` 没有任何外部依赖，这使得它体积小巧且具有更高的扩展性。

总结来说，`micro-app` 通过利用 Web Components 的 Custom Elements 和 Shadow DOM，实现了微前端应用的封装、隔离和通信，提供了一种简单、高效且兼容多种技术栈的微前端解决方案。

```js
// 定义
class MicroApp extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    this.shadowRoot.innerHTML = `<p>Hello, World!</p>`;
  }
}

window.customElements.define("micro-app", MyElement);
```

使用

```html
<body>
  <micro-app></micro-app>
</body>
```

### 遇到的问题

#### 权限信息传递

子应用 有独立运行模式 & 集成运行模式；
集成运行时，通过基座系统 统一派发的 store 信息，在子应用初始化时也存一份；
独立运行时，通过登录界面种下 cookie，跳转子系统时独立调用 auth 接口获取资源信息

#### 多个融合系统同时运行下的数据隔离

多个基座系统同时开启，系统内部的页签功能冲突；
利用 sessionStorage 的会话级的存储空间，在每个标签页都是单独内存，互不影响来实现

#### 子应用 keep-alive 缓存失效问题

主应用引入子应用时，加上 keep-alive 属性；
重写 vue 的 keep-alive 组件， 原来是一组件的 name 属性来判断去缓存的 cnode，改为 path；

#### 子组件跳转 & 非权限路由跳转

由于主子系统路由实例不一致，所以需要单独处理路由跳转逻辑；
router.afterEach 判断子系统路由前缀（每个系统定义不一样）；
microApp.setData(microAppName, sendData); 向子组件发送消息

#### 共用布局框架带来的问题

nav 导航栏状态通信处理

隐藏路由跳转，新增，编辑是一个单独的组件页面，添加到导航栏上

subAppRouter.beforeEach 中 操作 下发 的主应用 store 来实现

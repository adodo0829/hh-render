# 运维平台

设备调度，本质解决的是 仓库容器搬到 到哪里的问题;

自动化设备的设调度执行系统，负责设备管理和搬运任务执行; 它面向仓储物流和工业搬运等行业，提供的是点到点搬运的解决方案。

上层调度简单化，调度执行系统智能化。上层系统只需要决策从哪到哪，调度执行系统通过调度策略和算法赋能，会将点到点搬运做到效率极致。

前端层面：
WCS 运维平台核心功能是 实时监控，实现了对仓库 各库区的 2D 层面的静态地图展示，（地图数据来源是 在规划初期， 实时人员基于地图编辑器绘制的一份仓库地图）；
同时也实现了 对 动态设备（agv，ps，提升机等）的实时位置监控，运动动画绘制（平移，旋转等），
可以直接在页面端 对这些设备进行指令下发（包括移动，搬运容器，充电，占用，拍照，索引学习等）

通过 2D 建模技术还原真实智能仓场景，实时采集设备和业务数据，将作业过程、设备运行情况进行多维可视化展示，实现仓库管理的快速决策。

## 为什么重构？

1.x 的版本中，地图绘制使用的是自研的 wegbl 渲染引擎，当时的一批人已经离职，处于暂停维护阶段；
面对全新的改版需求，如果基于以前的自研引擎，改造成本较大，开发周期更长；而且需要熟悉 glsl 语言，经过调研后 采用了 pixijs 2d 渲染引擎

## 地图设计架构

### 渲染层

渲染器只是做一件事: 那就是根据设计的逻辑进行元素渲染
所以我们设计的核心: 数据模型的设计才是本质
数据结构体定义
数据转换
数据操作

- 静态渲染
  采用图层架构模式
  对业务地图元素进行分类，划分到不同图层
  点，边，设备，辅助图层（弹框，气泡，高亮，路线等等）

- 动态渲染
  设备实时动画
  开启动画循环进行实时绘制

实时动画是一个比较消耗硬件资源(CPU&GPU)的功能点, 需要维持一个持续渲染的状态, 1s 绘制大概 60 次, 也就是在 16ms 内 需要完成 设备属性(最新位置,方向)的计算, 并添加到缓冲区进行渲染;
这里可以先做一个优化, 只有增量数据推送了 设备位置信息时 (increase 模式下, move 对象的 device 有数据), 我们才开启 逐帧渲染模式, 没有数据时关闭逐帧渲染. 做到按需开启, 故可以引入一个操作模式: 逐帧渲染模式

增量推送的 时间点
增量推送的 设备位置,方向

### 数据层

- 静态数据 （静态业务点）
  http 获取
- 动态数据（设备 和 容器， 索引点）
  mqtt 推送

### 事件交互层

点选，拖拽，缩放，框选等

## 动画架构

渲染策略 1: 只要推送了设备移动数据, 我们就全量更新设备最新的位置数据, 没考虑时间问题; 这样没有平滑移动的效果

如果加上时间轴动画, 渲染策略也需要发生改变

首先, 因为要做动画, 必然会消耗时间, 那么 server 推送的数据肯定是无法及时渲染的, 必然会导致延迟, 就像直播一样, 中间的采集和转化也需要时间来处理, 会有一定延迟;

其次, server 不会考虑我们的动画要花费的时间, 肯定是不断给前端推 server 时间轴的数据 (某个时刻, 设备的位置), 而此时前端正在做上一个时刻的 动画, 所以这些对前端时间轴来说属于 未来时刻的位置, 前端肯定不能随便丢弃这些数据, 所以每个设备需要新增一个 `动画帧数据队列` 来维护这些数据, 做完动画再删除这些数据; 并且还要根据 现实时间 判断 目前维护的运动数据 是否是过期, 过期的数据还需要进行删除, 不然会一直占用内存

给动态设备数据绑定一个 动画队列字段， 将后端推送的小车到达的位置存储起来，然后按帧绘制，绘制完后进行清除

# 问题

## 地图性能瓶颈问题

### 内存优化

地图支持的渲染元素展示数量优化

由于 gpu 和 cpu 都有着内存大小限制，纯静态地图下，我们测试的极限是 3-4w 个储位节点；
地图渲染数量最大的是，点，储位，我们的实现方式是用 图片纹理

#### gpu 内存

- 纹理切图，宽高最好是 2 的幂，可以减少 GPU 的计算负担
- 纹理压缩，可以减少图形数据
- 纹理合并（未验证）

- 开发自定义的网格 mesh 需要自己开发(顶点, 片段)着色器代码
  相比通过 Graphics 生成的元素实例减少很多不必要属性绑定

  顶点数据优化，双向边 20 个顶点 优化为 10 个顶点
  顶点数据优化，单向边 12 个顶点 优化为 7 个顶点

#### cpu 内存

点的类型：储存点，巷道，胡同，休息点，等待点，充电点，门，队列，反光柱，反光条，二维码，旋转点
合并业务逻辑元素，合并为一个图层来实现，通过增加 showType 来渲染不同类型的业务元素

设备的状态纹理

### drawCall 绘制优化

因为我们开启了动画循环，去掉 pixi 自带的 ticker， 手动实现了一个 ticker， 每个 16 毫秒去渲染一次；
所有去掉代码里手动调用渲染器的代码，避免不必要的渲染

### 瓶颈优化

产品侧：大地图分层，按楼层 分为小地图进行渲染

## 动画性能问题

当动画设备数增加到 200, 随着时间的推移， 会出现小车重叠的现象, 以及动画稍有延时的问题, 即数据推送和消费渲染速度不在频率不一致

因为同时推送 200 台设备的实时动态点位，我们每个设备的动画队列里存储了很多帧节点， 由于渲染量和计算量都增大，导致前端渲染跟不上 后台的推送速度，可能小车在 b 点，但是数据已经推送到 d 点了，实时性就出现了问题

方案 1:
动画帧固定的补间节点 换成动态的 补间节点数，当渲染比较卡时，fps 低，次数我们就少补一点动画帧节点，加快动队列数据的消费

方案 2：
还是保持固定的补间节点, 删除动画队列中的中间节点数据

方案 3：组合上面
动画主要分为旋转 和 平移，我们可以把同方向的平移帧节点合并，也可以减少绘制次数，意味着每次平移的步长 dx 和 dy 增加，动画显示会没那么平滑

## 交互问题

1.slam 地图中贝塞尔曲线选中问题

- 曲线边的顶点长度 length 为 N，那么就会产生 N-2 个三角形，N 越大，遍历判断次数越多
- 曲线边宽度过细，鼠标点击选中困难

图层 layer 对象保存了 vertexData 顶点坐标信息

优化思路：
按顶点顺序把 2 个三角形，或者 3/4/5 个合并成一组，形成一个新的多边形区域，然后再判断鼠标点击的点位是否在该区域内，减少遍历判断次数
这样虽然会减少精度，但是扩大一定的模糊选中范围，可以带来性能提升，提示也方便用户更好的选中曲线边

# 统一平台重构

河图标准产品存在以下问题
重复登录: WMS, WCS 各自一条登录功能
功能重复: WMS, WCS 各自一套权限管理

实现单点登录, 一次登录,全部产品可用
实现统一配置, 一次配置,全部产品可用

## 旧架构问题

### 可维护方面差

两个系统，一个系统用来做登录和权限管理，一个融合系统（可以把业务系统组合为一个新的系统）
菜单资源在前端维护，不利于管理

### 架构设计带来的技术债

融合系统的价格问题：融合系统是一个代码仓库，类似一个空壳子，有一个配置文件，执行初始化脚本会把需要融合的业务系统 git 仓库拉取到它本地，
并且收集所有系统的依赖，依赖包的版本要保持一致，且接口请求拦截器也要做重写兼容；

各工程依赖包统一，避免编译问题产生
webpack 相关配置需要根据工程进行规范（比如 alias），避免编译问题产生
需要增加相关检查机制及脚本，避免重复路径出现。
新建工程无数量限制
跨工程模块依赖
版本控制
样式隔离
各业务系统代码可能互相耦合，会出现各类意想不到的问题，样式互相影响呀

带来的问题就是，每次想创建一个融合系统都需要定制化拉取一个分支；
且在业务系统升级后，如果融合系统依赖了该业务系统也得重新拉取代码，创建分支来实现
在项目交付过程中，对交付实施人员来的 技术负担大， 不友好

1、定制化提测融合系统多个页面不可用, 阻塞整体流程进度
2、在标准产品测完没有问题的功能, 需要也在融合系统再重复测试一遍, 以保证融合系统没有问题, 测试成本较高

## 功能介绍

- 所有 hetu 业务系统的登录入口
- 所有 hetu 业务系统页面 和 用户角色权限管理配置
- 支持将 各个子业务系统的页面资源 整理合并为 一个新业务系统， 可以理解为资源融合系统

## 新架构设计

- 1.将融合系统 和 权限登录系统 合并为一个标准系统，我们称为基座系统，采用微前端的架构方式实现
- 2.对融合系统功能重新设计实现， 定义一套标准的 权限资源管理数据模型
  一个资源 url 对应一个页面
  每个业务系统增加唯一前缀来区分

只需要子应用改造 mian.js 入口函数即可

## 项目问题

各业务系统和权限系统都是比较独立的，主要是融合功能带来的一些问题

- 系统设计问题： 融合系统数据隔离问题

融合系统在代码层都是同一个应用，只不过每个系统在运行时都有自己的路由菜单，数据权限等；
假如浏览器打开了多个融合系统，如何区分不同融合系统？url 传参判断

前打开页面的导航数据是存在浏览器本地的，多个融合系统会在浏览器本地存储读取导航信息，如果保证互不影响？
利用 sessionStorage 的跨标签页/窗口隔离的特性，即使是同一个页面，不同浏览器标签页或窗口中的 sessionStorage 也是隔离的，它们之间不能共享数据。

micro 基座初始化流程：
主应用配置路由指向子应用的容器组件；
子应用初始化：通过 fetch + url 获取子应用的 HTML，处理 HTML 文本获取 CSS 和 JS 的资源地址，然后通过 fetch 获取子应用的静态资源；
将处理过的 HTML 放入 WebComponent 容器中，给 CSS 加上 scope 机制，并 append 到 head 标签中，在沙箱中执行 JS 代码；
完成子应用的初始化并渲染子应用；
Micro-app 实现了路由隔离，确保主应用和子应用的路由系统相互独立

iframe 沙箱 和 with + proxy 沙箱， 可以确保代码的行为被限制在一个安全的范围内，防止其超出预期权限进行操作

- 微前端框架-导航路由跳转问题
  由于路由 mirco 的路由系统实现中，主子应用是隔离的，所有主子应用路由互跳需要额外进行处理

  所有从主应用基座发出去的路由跳转请求，如果是主应用自己的，有自己的路由实例来处理， 如果是子应用的路由地址都通过事件的方式向子应用派发，子应用接受到了用自己的路由实例进行跳转；

  子应用在内部跳转时理论上也需要通知主应用去更新当前打开的导航页面，但是这里我们设计的是 直接去更改主应用内部的 store 数据源来实现数据 和 UI 同步，这样我们所有的代码逻辑都在 mian.js 实现，方便维护

- 微前端框架-子系统路由页面的缓存问题
  一般状态下，我们用 vue 的 keep-alive 组件可以实现页面级别的缓存，下次打开时不直接从 0 渲染，而是用缓存组件来渲染；
  我们根据 框架文档 对子应用配置完成发现有些页面并未生效

查看 ka 源码发现，当时 keepalive 组件是 组件 name 为 key 来实现缓存的，那我们在开发过程中会遇到 各开发定义的页面组件 name 相同的情况，这里缓存可能会出现失效的情况，我们对 keepalive 进行了重新实现，由于我们在设计时每个页面的 path 是唯一的，我们已 path 为 key 对 keepalive 进行重写，在主子页面互相切换的过程中，keepalive 依然是生效的

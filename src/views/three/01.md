# three 使用

## 视口操作

import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

平移，旋转，缩放

## 渲染循环

```js
// 自动调用
function renderLoop() {
  window.requestAnimationFrame(renderLoop);
  controls.update();
  renderer.render(scene, camera);
}

// 手动根据触发时机调用
renderer.render(scene, camera);
```

## 点击交互

```js
// 全局一次性创建
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
const pickableObjects = []; // 把需要拾取的对象 push 进来（或直接用 scene.children）

// 推荐用 pointer 事件
renderer.domElement.addEventListener("pointerdown", onPointerDown, false);

function onPointerDown(event) {
  // 1) 获取 canvas 的屏幕位置与尺寸（考虑滚动、布局、CSS 缩放等）
  const rect = renderer.domElement.getBoundingClientRect();

  // 2) clientX/Y 减去 rect.left/top，归一化到 [0,1]，再转 NDC [-1,1]
  const x = (event.clientX - rect.left) / rect.width;
  const y = (event.clientY - rect.top) / rect.height;

  pointer.x = x * 2 - 1;
  pointer.y = -(y * 2 - 1); // 注意 y 方向需要取反

  // 3) 更新相机矩阵（确保最新）
  camera.updateMatrixWorld();
  // 4) 从相机和 NDC 构建射线
  raycaster.setFromCamera(pointer, camera);

  // 5) 进行相交测试（true 表示递归检查子对象）
  const intersects = raycaster.intersectObjects(
    pickableObjects.length ? pickableObjects : scene.children,
    true
  );

  if (intersects.length > 0) {
    const hit = intersects[0]; // 最近的交点
    console.log("hit object:", hit.object);
    console.log("hit point (world):", hit.point);
    console.log(
      "face:",
      hit.face,
      "uv:",
      hit.uv,
      "instanceId:",
      hit.instanceId
    ); // 若是 InstancedMesh 会有 instanceId
    // 在这里做高亮 / 相机聚焦 / 显示信息面板
    showHit(hit);
  } else {
    console.log("no hit");
  }
}
```

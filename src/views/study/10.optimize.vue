<template>
  <div>
    <p>
      思考一下：为什么要优化，有必要一开始就优化吗？排期与优化冲突时如何抉择？
    </p>
    <h3>通用的优化手段</h3>
    <pre>
web前端优化：无非就是让软件界面如何 快速响应 （主要分为时间，空间两大方向）。

# 1.空间内存优化
1.静态资源压缩
前端所有的文件程序代码都是要通过浏览器下载下来运行使用，涉及到网络和请求延时，所以前端文件的精简和压缩决定了前端性能的第一步
html，css，js，图片压缩等，gizp，icon替代图片等
需要Nginx配置

2.资源合并
减少文件请求次数（H5中比较明显）

# 2.响应时间优化
1.根据浏览器加载规则 来 合理安排静态资源引用的顺序；
2.缓存优化
HTTP协议缓存 =》到浏览器缓存 =》app cache
- 强缓存：Expires 和 Cache-Control
- 协商缓存：Last-Modified & Etag
- 浏览器缓存 一些系统常量数据
- Service Worker 代理服务器，离线资源缓存

3.懒加载与预加载
4.升级为http2
需要升级服务器配置，nginx1.9.5以上，配置SSL
5.首屏资源优化
Preload 和 Prefetch
Preload 一个基本的用法是提前加载资源,告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级，加载但是不运行，占用浏览器对同一个域名的并发数:
Prefetch 一个一般用法是浏览器会在空闲的时候，下载资源, 并缓存起来。当有页面使用的时候，直接从缓存中读取。其实就是把决定是否和什么时间加载这个资源的决定权交给浏览器。
对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。

# 纯 前端层面的优化
渲染优化
- 重绘和重排控制（布局css使用）
- requestAnimationFrame
- requestIdleCallback,浏览器处于空闲状态执行，可以理解为后台运行，不要操作任何DOM
- 虚拟列表等
- 防抖节流等
    </pre>

    <h3>其他</h3>
    <pre>
# 如何排查内存泄漏导致的卡顿？
根据现象推断问题，页面卡顿，说明渲染线程阻塞了，什么能导致阻塞呢？该分给他的执行资源被别的模块占用了

1.内存泄漏
变量没有被手动的回收或自动回收；
JavaScript的垃圾回收机制是自动执行的，并且会通过标记来识别并清除垃圾数据，
在离开局部作用域后，若该作用域内的变量没有被外部作用域所引用，则在后续会被清除；
JavaScript是运行在主线程上的，所以执行垃圾回收机制时会暂停js的运行，若垃圾回收执行时间过长，则会给用户带来明显的卡顿现象，
所以垃圾回收机制会被分成一个个的小任务，穿插在js任务之中，即交替执行，尽可能得保证不会带来明显的卡顿感

排查：
Chrome devTools =》performance =》 录制快照
    </pre>

    <h3>业务上的优化思路</h3>
    <pre>
同样也是时间和空间上的优化：利用相关特性
1.切片思想
大任务切片，切成小任务
2.合并思想
gpu批处理

</pre
    >
  </div>
</template>

<script>
export default {
  name: "xxx",
  components: {},
  data() {
    return {};
  },
  mounted() {},
  methods: {},
};
</script>

<style lang="scss" scoped></style>

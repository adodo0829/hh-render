<template>
  <div>
    <h3>微前端</h3>
    <pre>
随着业务的复杂程度越来越高，我们的项目也变的越来越大，越来越臃肿，达到一定程度以后，如果后期想要重构，那将是灾难级别的。
而且技术随着不断的更新，以前的老项目使用的老旧的技术栈，项目更新新技术就只能从新开一个项目。

一个管理系统，里面有各种模块。我们可以按照业务拆分为多个系统进行开发。
我们可以有一个主应用，然后把多个系统当成是子应用，独立开发，独立测试，独立部署，最后所有的子应用就承载到主应用上。

需要先加载基座（主应用），再把选择权交给主应用，由主应用根据注册过的子应用来抉择加载谁，当子应用加载成功后，再由vue-router或react-router来根据路由渲染组件

# 微前端的核心价值
- 技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权
- 独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
- 增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略
- 独立运行时每个微应用之间状态隔离，运行时状态不共享

# 主流方案
## iframe
天生隔离样式与脚本、多页
1. 不是单页应用，会导致浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用
2. 弹框类的功能无法应用到整个大应用中，只能在对应的窗口内展示
3. 由于可能应用间不是在相同的域内，主应用的 cookie 要透传到根域名都不同的子应用中才能实现免登录效果
4. 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程，占用大量资源的同时也在极大地消耗资源
5. iframe的特性导致搜索引擎无法获取到其中的内容，进而无法实现应用的seo

## Web Components（micro app）
天生隔离样式与脚本，
无法兼容所有浏览器

## ESM
远程加载模块
1. 无法兼容所有浏览器(但可以通过编译工具解决)
2. 需手动隔离样式（可通过css module解决）

## qiankun
1. HTML Entry 接入方式
2. 资源预加载

    </pre>
  </div>
</template>

<script>
export default {
  name: "xxx",
  components: {},
  data() {
    return {};
  },
  mounted() {},
  methods: {},
};
</script>

<style lang="scss" scoped></style>

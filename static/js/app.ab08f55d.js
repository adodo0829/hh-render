(function(t){function n(n){for(var r,a,s=n[0],c=n[1],l=n[2],u=0,d=[];u<s.length;u++)a=s[u],Object.prototype.hasOwnProperty.call(o,a)&&o[a]&&d.push(o[a][0]),o[a]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(t[r]=c[r]);h&&h(n);while(d.length)d.shift()();return i.push.apply(i,l||[]),e()}function e(){for(var t,n=0;n<i.length;n++){for(var e=i[n],r=!0,s=1;s<e.length;s++){var c=e[s];0!==o[c]&&(r=!1)}r&&(i.splice(n--,1),t=a(a.s=e[0]))}return t}var r={},o={app:0},i=[];function a(n){if(r[n])return r[n].exports;var e=r[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,a),e.l=!0,e.exports}a.m=t,a.c=r,a.d=function(t,n,e){a.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:e})},a.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},a.t=function(t,n){if(1&n&&(t=a(t)),8&n)return t;if(4&n&&"object"===typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(a.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var r in t)a.d(e,r,function(n){return t[n]}.bind(null,r));return e},a.n=function(t){var n=t&&t.__esModule?function(){return t["default"]}:function(){return t};return a.d(n,"a",n),n},a.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},a.p="/hh-render/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=n,s=s.slice();for(var l=0;l<s.length;l++)n(s[l]);var h=c;i.push([0,"chunk-vendors"]),e()})({0:function(t,n,e){t.exports=e("56d7")},"0721":function(t,n,e){},"0b6d":function(t,n,e){t.exports=e.p+"static/img/matrix1.bb4340c6.png"},"0f9f":function(t,n,e){"use strict";e("859d")},"11d9":function(t,n,e){t.exports=e.p+"static/img/3.5c73f25e.jpg"},"1aa6":function(t,n,e){t.exports=e.p+"static/img/matrix.57e09dd0.png"},2487:function(t,n,e){},3260:function(t,n,e){t.exports=e.p+"static/img/vector1.73452b9b.png"},"34a5":function(t,n,e){t.exports=e.p+"static/img/coord1.5b2ba5f4.png"},"3d36":function(t,n,e){},"405a":function(t,n,e){t.exports=e.p+"static/img/2.5debf06e.jpg"},"52fe":function(t,n,e){},"56d7":function(t,n,e){"use strict";e.r(n);var r=e("2b0e"),o=function(){var t=this,n=t._self._c;return n("div",{attrs:{id:"app"}},[n("section",{attrs:{id:"nav"}},t._l(t.routeList,(function(e){return n("router-link",{key:e.path,attrs:{to:e.path}},[t._v(t._s(e.name))])})),1),n("section",{attrs:{id:"content"}},[n("router-view")],1)])},i=[],a=(e("0643"),e("2382"),{name:"App",components:{},data(){return{routeList:[]}},mounted(){this.init()},methods:{init(){const{options:t}=this.$router;let n=t.routes.filter(t=>"/"!==t.path);this.routeList=n}}}),s=a,c=(e("a396"),e("2877")),l=Object(c["a"])(s,o,i,!1,null,null,null),h=l.exports,u=e("8c4f"),d=function(){var t=this;t._self._c;return t._m(0)},p=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"home"},[n("p",[t._v("GLSL ES 3.00")]),t._v(" 中文手册 https://github.com/adodo0829/GLSL-Card 游戏引擎 https://github.com/ThisisGame/cpp-game-engine-book "),n("pre",[n("h3",[t._v("基本结构")]),t._v("\n预处理器指令：\n#version 300 es：指定着色器语言的版本。\n变量类型：\n\n基本数据类型：float, int, bool, vec2, vec3, vec4, mat2, mat3, mat4, sampler2D 等。\n限定词：in, out, inout（仅在函数参数中使用）。\n主函数：\n\nvoid main()：着色器程序的入口点。\n\n"),n("h3",[t._v("输入和输出")]),t._v("\nin：用于顶点着色器的输入和片段着色器的输出。\nout：用于顶点着色器的输出和片段着色器的输入。\n\n"),n("h3",[t._v("Uniforms")]),t._v("\nUniform变量：\n用于在应用程序和着色器之间传递数据。\n声明方式：uniform type name;\n\nuniform 用来修饰统一变量。\nGPU是并行的，Shader是执行在GPU上的程序。\n当我们需要绘制3个顶点，GPU将3个顶点数据，分摊到3个GPU逻辑单元并行处理，每个逻辑单元处理的不同的顶点坐标数据，称之为属性变量。\n每个逻辑单元也会需要一些相同的数据，这些相同的数据，称之为统一变量。\nuniform mat4 u_mvp;\n\n"),n("p",[t._v("es2.0语法")]),t._v("\nattribute 表示这个变量，每执行一次Shader，都需要被赋值\nattribute vec3 a_pos;\nattribute vec4 a_color;\n输出变量由varying关键字修饰，用于从顶点着色器，传递数据到片段着色器\nvarying vec4 v_color;\n\n"),n("h3",[t._v("布局限定词")]),t._v("\n位置：\nlayout(location = N)：指定变量在属性数组中的位置。\n接口块：\n使用in和out关键字定义块，用于组织和传递复杂的数据结构。\n\n"),n("h3",[t._v("构造函数")]),t._v("\n支持多种构造函数，例如：vec4(float x, float y, float z, float w)。\n\n"),n("h3",[t._v("控制流")]),t._v("\n条件语句：if, else。\n循环语句：for, while。\n\n"),n("h3",[t._v("函数")]),t._v("\n支持用户定义函数。\n内置函数：如sin, cos, pow等。\n\n"),n("h3",[t._v("精度限定词")]),t._v("\n精度限定词：\nhighp, mediump, lowp：指定变量或uniform的精度。\n\n"),n("h3",[t._v("纹理采样和处理")]),t._v("\n纹理函数：\ntexture, texture2D, textureCube等。\n\n"),n("h3",[t._v("构造几何形状")]),t._v("\n几何着色器：\n可以定义几何着色器来处理几何图形的顶点。\n\n"),n("h3",[t._v("变换反馈：")]),t._v("\n允许着色器将数据直接输出到缓冲区。\n    ")]),n("div",[t._v("内置函数")]),n("pre",[t._v("\nGLSL ES 3.00支持的内置函数非常丰富，涵盖了数学运算、几何函数、矩阵操作、纹理查询等多个方面。\n以下是一些主要的内置函数类别及其部分代表函数：\n\n### 1. 角度和三角函数\n- `radians(d)`：将角度转换为弧度。\n- `degrees(r)`：将弧度转换为角度。\n- `sin(x)`：正弦函数。\n- `cos(x)`：余弦函数。\n- `tan(x)`：正切函数。\n- `asin(x)`：反正弦函数。\n- `acos(x)`：反余弦函数。\n- `atan(x)`：反正切函数。\n- `atan(x, y)`：双参数反正切函数。\n\n### 2. 指数函数\n- `pow(x, y)`：幂函数。\n- `exp(x)`：指数函数。\n- `log(x)`：自然对数。\n- `exp2(x)`：以2为底的指数函数。\n- `log2(x)`：以2为底的对数。\n\n### 3. 通用函数\n- `abs(x)`：绝对值。\n- `sign(x)`：符号函数。\n- `floor(x)`：向下取整。\n- `ceil(x)`：向上取整。\n- `fract(x)`：取小数部分。\n- `mod(x, y)`：取模。\n- `min(x, y)`：最小值。\n- `max(x, y)`：最大值。\n- `clamp(x, minVal, maxVal)`：将x限制在[minVal, maxVal]之间。\n- `mix(x, y, a)`：线性插值。\n- `step(edge, x)`：阶梯函数。\n- `smoothstep(edge0, edge1, x)`：平滑阶梯函数。\n\n### 4. 浮点数打包和解包函数\n- `packHalf2x16(v)`：将两个16位半精度浮点数打包成一个32位无符号整数。\n- `unpackHalf2x16(v)`：将一个32位无符号整数解包成两个16位半精度浮点数。\n\n### 5. 几何函数\n- `length(v)`：向量v的长度。\n- `distance(p0, p1)`：两点之间的距离。\n- `dot(x, y)`：向量x和y的点积。\n- `cross(x, y)`：向量x和y的叉积。\n- `normalize(v)`：向量v的单位向量。\n- `faceforward(N, I, Nref)`：根据法线N和参考向量Nref调整向量I的方向。\n- `reflect(I, N)`：向量I关于法线N的反射。\n- `refract(I, N, eta)`：向量I在法线N上的折射，其中eta是折射率。\n\n### 6. 矩阵函数\n- 矩阵的构造函数，如`mat2`, `mat3`, `mat4`。\n- `matrixCompMult(x, y)`：矩阵逐元素乘法。\n- `outerProduct(a, b)`：计算两个向量的外积。\n- `transpose(m)`：矩阵转置。\n- `inverse(m)`：矩阵求逆。\n\n### 7. 向量关系函数\n- `lessThan(x, y)`：逐元素比较x和y是否小于。\n- `greaterThan(x, y)`：逐元素比较x和y是否大于。\n- `equal(x, y)`：逐元素比较x和y是否相等。\n- `notEqual(x, y)`：逐元素比较x和y是否不相等。\n\n### 8. 纹理查询函数\n- `texture(sampler, P)`：从纹理采样器sampler中获取纹理坐标P处的颜色。\n- `textureLod(sampler, P, lod)`：从纹理采样器sampler中获取指定层次lod处的纹理坐标P处的颜色。\n- `textureProj(sampler, P)`：进行投影纹理采样。\n- `textureGrad(sampler, P, dPdx, dPdy)`：使用显式梯度进行纹理采样。\n    ")]),n("h3",[t._v("顶点着色器")]),n("p",[n("pre",[t._v("void main()\n{\n    gl_Position = vec4(vPos, 1.0);\n}\n\t\t")]),t._v(" 每个Shader都有入口函数 main()，顶点Shader主要工作就是：计算坐标。 得到坐标计算结果后，传给内置变量 gl_Position。 ")]),n("p",[t._v("在线测试 https://thebookofshaders.com/edit.php")]),n("pre",[t._v("  export const vertexString = `\n    #version 300 es\n    // 指定currVertexAndRatio变量在顶点属性数组中的位置是1\n\tlayout(location=1) in vec4 currVertexAndRatio;\t\t\t// 顶点坐标和变形系数\n\tlayout(location=2) in vec4 prevVertexAndRatio;\n\tlayout(location=3) in vec4 nextVertexAndRatio;\n\tlayout(location=4) in vec4 uvAndEdgeOffsetRatio;\t\t// UV\n\tlayout(location=5) in vec4 vertexAndEdgeOffsetValueAndNotFollowViewport;\t// 顶点形变  边形变值  是否不跟随视口\n\tlayout(location=6) in vec4 UVRect;\t\t\t\t\t\t// UVRect\n\tlayout(location=7) in vec4 backgroundColor;\t\t\t\t// 背景色\n\tlayout(location=8) in vec4 translationAndRotation;\t\t// 形变\n\tlayout(location=9) in vec4 isTextAndBorderWidthAndDashedAndScale;\t\t// 是否渲染文字 以及 文字边框粗细 以及物体边框虚线 缩放\n\tlayout(location=10) in vec4 textBorderColor;\t\t\t// 文字边框颜色\n\tlayout(location=11) in vec4 opacityAndDisplayAndVpScaleAndVpTrans;\t\t\t// 透明度 是否显示 是否跟随视口缩放 是否跟随视口平移\n    \n    // out是从顶点着色器传递到片段着色器（用于处理像素颜色）的数据\n\tout vec2 vTexCoord;\t\t\t\t// UV\n\tout vec4 vBgColor;\n\tout float vIsText;\n\tout float vTextBorderWidth;\n\tout vec4 vTextBorderColor;\n\tout float vHasTexture;\n\tout vec4 vPos;\n\tout float vNotBorder;\n\tout float vBorderDashed;\n\tout float vOpacity;\n\tout float vDisplay;\n\n  // 应用程序和着色器之间传递传递参数\n\tuniform vec2 uConversionVec2;\t//坐标转换\n\tuniform vec2 uViewportTranslation;\t//视口平移\n\tuniform vec2 uViewportScale;\t\t//视口缩放\n\tuniform float uViewportRotation;\t//视口旋转\n\tuniform vec4 uOpacity;\t\t\t\t//全局透明度\n\n\tmat4 getScaleMatrix(vec2 scale) {\n\t\treturn mat4(\n\t\t\tscale.x, 0.0, 0.0, 0.0,\n\t\t\t0.0, scale.y, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getRotationMatrix(float radian) {\n\t\tfloat cost = cos(radian);\n\t\tfloat sint = sin(radian);\n\t\treturn mat4(\n\t\t\tcost, -sint, 0.0, 0.0,\n\t\t\tsint, cost, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getTranslationMatrix(vec2 translation) {\n\t\treturn mat4(\n\t\t\t1.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\ttranslation.x, translation.y, 0.0, 1.0\n\t\t);\n\t}\n\n    // 找到两个向量夹角平分线上的一个特定点，这个点距离每个向量的端点都是 offset 距离\n\tvec2 getIntersectionVertex(\n\t\tin vec2 v1,\n\t\tin vec2 v2,\n\t\tin float offset\n\t) {\n\t\tvec4 vv1 = vec4(v1, 0.0, 1.0);\n\t\tvec4 vv2 = vec4(v2, 0.0, 1.0);\n\t\t// 向量夹角\n\t\tvec2 mid = normalize(normalize(v1) + normalize(v2));\n\t\tfloat theta = acos(dot(v1, v2) / (length(v1) * length(v2)));\n\t\t// 右手法则，判断夹角正负\n\t\tvec3 c = cross(vv1.xyz, vv2.xyz);\n\t\tfloat l = offset / sin(theta * 0.5);\n\t\treturn mid * l * (- sign(c.z));\n\t}\n\n    // 将一个点按照给定的比率和值进行偏移，用于创建动画、调整对象位置\n\tvec2 getVertex(\n\t\tin vec2 origin,\n\t\tin vec2 offsetRatio,\n\t\tin vec2 offsetValue\n\t) {\n\t\tvec2 offset = offsetRatio * offsetValue;\n\t\treturn origin + offset;\n\t}\n   \n\tvec2 getFollowViewport() {\n\t\tfloat outViewportStatus = vertexAndEdgeOffsetValueAndNotFollowViewport.w;  // 跟随视口状态\t\n\t\tvec3 f = vec3(outViewportStatus - 1.0, outViewportStatus - 2.0, outViewportStatus - 3.0);\n\t\tf = step(vec3(0.5, 0.5, 0.5), abs(f));\n\t\treturn vec2(f.x * f.z, f.y * f.z);\n\t}\n\n\t// 获取缩放矢量\n\tvec2 getScaleVec(float scale, vec2 followViewport, vec2 notFollowViewport) {\n\t\tvec2 scaleVec = vec2(scale, scale);\n\t\tvec2 isVpScale = vec2(1.0, 1.0) - opacityAndDisplayAndVpScaleAndVpTrans.zz;\n\t\tvec2 dscaleVec = vec2(1.0, 1.0) / uViewportScale * scaleVec * isVpScale + scaleVec * (1.0-isVpScale);\n\t\treturn dscaleVec * followViewport + scaleVec * notFollowViewport;\n\t}\n\n\tvoid main(void) {\n\t\tvec2 pv = getVertex(prevVertexAndRatio.xy, prevVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 cv = getVertex(currVertexAndRatio.xy, currVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 nv = getVertex(nextVertexAndRatio.xy, nextVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 pe = pv - cv;\n\t\tvec2 ne = nv - cv;\n\n\t\t// 判断是否需要乘视口矩阵\n\t\tvec2 followViewport = getFollowViewport();\n\t\tvec2 notFollowViewport = vec2(1.0, 1.0) - followViewport;\n\n\t\t// 各种矩阵\n\t\tmat4 rotationMatrix = getRotationMatrix(translationAndRotation.z);\n\t\t// 缩放矩阵，如果设置了脱离视口，则需要计算一个反向缩放矩阵\n\t\tmat4 scaleMatrix = getScaleMatrix(getScaleVec(isTextAndBorderWidthAndDashedAndScale.w, followViewport, notFollowViewport));\n\t\tmat4 transMat = getTranslationMatrix(translationAndRotation.xy);\n\t\tmat4 converMat = getScaleMatrix(uConversionVec2.xy);\n\t\t// 视口矩阵\n\t\tmat4 vpScaleMatrix = getScaleMatrix(uViewportScale);\n\t\tmat4 vpTranslationMatrix = getTranslationMatrix(uViewportTranslation);\n\t\tmat4 vpRotationMatrix = getRotationMatrix(uViewportRotation);\n\t\tmat4 vpMat = vpTranslationMatrix * vpScaleMatrix * converMat * vpRotationMatrix;\n\n\t\t// 求相邻两边交点向量\n\t\tvec2 intersection = getIntersectionVertex(pe, ne, vertexAndEdgeOffsetValueAndNotFollowViewport.z * uvAndEdgeOffsetRatio.z);\n\n\t\tvec4 posOrigin = transMat * scaleMatrix * rotationMatrix * vec4(cv, 0.0, 1.0);\n\t\tvec4 posBorder = rotationMatrix * vec4(intersection, 0.0, 0.0);\n\t\tposBorder = converMat * vec4(vec2(vpRotationMatrix * posBorder) * followViewport + posBorder.xy * notFollowViewport, 0, 0);\n\t\tposOrigin = vec4(vec2(vpMat * posOrigin) * followViewport + vec2(converMat * posOrigin) * notFollowViewport, 0.0, 1.0);\n\n\t\tgl_Position = posOrigin + posBorder;\n\n\t\t// out\n\t\t// 如果材质宽度为0 则标志为无材质\n\t\tvHasTexture = step(0.0, UVRect.z);\n\t\tvTexCoord = uvAndEdgeOffsetRatio.xy * UVRect.zw + UVRect.xy;\n\t\tvBgColor = backgroundColor;\n\t\tvIsText = isTextAndBorderWidthAndDashedAndScale.x;\n\t\tvTextBorderWidth = isTextAndBorderWidthAndDashedAndScale.y;\n\t\tvTextBorderColor = textBorderColor;\n\t\tvNotBorder = step(vertexAndEdgeOffsetValueAndNotFollowViewport.z, 0.0);\n\n\t\tvPos = rotationMatrix * vec4(cv, 0.0, 1.0); // 用于边框渲染计算\n\t\tvPos = vec4(vec2(vpRotationMatrix * vPos) * followViewport + vPos.xy * notFollowViewport, 0.0, 1.0);\n\n\t\tvBorderDashed = isTextAndBorderWidthAndDashedAndScale.z;\n\t\tvOpacity = opacityAndDisplayAndVpScaleAndVpTrans.x * uOpacity.x;\n\t\tvDisplay = opacityAndDisplayAndVpScaleAndVpTrans.y;\n\t}\n`;\n")]),n("h3",[t._v("片段着色器")]),n("pre",[t._v("片段着色器(像素着色器)的功能就是：输出颜色；\nvarying vec4 v_color;\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n\n片段着色器(像素着色器)也是并行的，不过执行的次数不是顶点个数，而是屏幕像素个数。\n假如绘制一个960x540的长方形，每一个像素点的颜色，都是通过执行一次片段着色器来得到，那么GPU需要执行960x540次\n\n顶点数越多，顶点着色器执行次数越多。\n屏幕分辨率越高，片段着色器执行次数越多。\n这里可以推出手游常见的两种优化方式：减少顶点、降低分辨率\n\n绘制一个200x200 左右大小的正方形\n正方形四个顶点，顶点着色器只需要执行4次，而面对200x200个像素，片段着色器，需要执行200x200次。\n只有正方形四个顶点的那四个像素，才能直接从顶点着色器拿到颜色数据，那中间的像素颜色数据从哪里来？\n\n插值\n中间的像素颜色，都是插值得到的。\n\n左上角顶点颜色是红色，右上角顶点颜色是蓝色，可以看到中间颜色是由红色、蓝色插值混合而成。\n\n注意：所有从顶点着色器输出到片段着色器的数据，都会插值\n\nexport const fragmentString = `\n  #version 300 es\n\tprecision mediump float;\n\tuniform sampler2D uSampler;\n\t// uniform vec2 uConversionVec2;\t// 坐标转换\n\tin vec2 vTexCoord; // 从顶点着色器传入的纹理坐标\n\tin vec4 vBgColor; // 从顶点着色器传入的背景颜色\n\tin float vIsText;\n\tin float vTextBorderWidth;\n\tin vec4 vTextBorderColor;\n\tin float vHasTexture;\n\tin vec4 vPos;\n\tin float vNotBorder;\n\tin float vBorderDashed;\n\tin float vOpacity;\n\tin float vDisplay;\n\tout vec4 fragColor; // 片段着色器的输出颜色，将被用于最终的像素颜色\n\n    // 确定一个片段是否应该被渲染为虚线边框的一部分\n\tfloat inBorderDashed() {\n\t\t// 是否绘制虚线\n\t\tfloat hasDashed = 1.0 - step(vBorderDashed, 0.0);\n\t\tvec2 fw = fwidth(vPos.xy);\n\t\tfloat k = fw.y * (1.0/fw.x);\n\t\t// 如果k在 0.95 和 1.05 之间\n\t\tfloat c1 = step(0.95, k) * step(k, 1.05);\n\t\t// 如果 c1 == 0.1 则 c2 = 0.0 否则 c2 = 1.0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 如果 c1 条件成立 则 gl_FragCoord.x 否则 ...\n\t\tfloat d = gl_FragCoord.x * c1 + (step(1.0, k) * gl_FragCoord.y + step(k, 1.0) * gl_FragCoord.x) * c2;\n\t\treturn step(mod(floor( d * (1.0/vBorderDashed) ), 2.0), 0.0) * hasDashed;\n\t}\n\n\tvec4 drawText(vec4 texture) {\n\t\t// 文字边框是否大于0\n\t\tfloat c1 = step(0.1, vTextBorderWidth);\n\t\t// 文字边框是否小于等于0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 第一个插值阶梯\n\t\tfloat start = max(0.0, 0.5 - vTextBorderWidth * 0.1);\n\t\t// 边框插值系数\n\t\tfloat r1 = smoothstep(start, start + 0.2, texture.r) * c1;\n\t\t// 文字插值系数\n\t\tfloat r2 = smoothstep(0.5, 0.85, texture.r);\n\n\t\treturn vec4(mix(vTextBorderColor.rgb, vBgColor.rgb, r2), r2+(1.0-r2)*r1);\n\t}\n\n\tvec4 drawNormal(vec4 texture, vec4 bgColor) {\n\t\tfloat a1 = texture.a * vHasTexture;\n\t\tfloat a2 = bgColor.a;\n\t\treturn vec4(mix(bgColor.rgb, texture.rgb, a1), a1+(1.0-a1)*a2);\n\t}\n\n\tvoid main(void) {\n        // 丢弃不显示的片段\n\t\tif(vDisplay == 0.0 || vOpacity == 0.0) {\n\t\t\tdiscard;\n\t\t\treturn;\n\t\t}\n\n\t\t// ib == 0.0 则正常渲染， ib == 1.0 则渲染反色\n\t\tfloat ib = inBorderDashed();\n\t\tvec4 bgColor = vec4(vBgColor.rgb * (1.0 - ib) + (vec3(1.0, 1.0, 1.0) - vBgColor.rgb) * ib, vBgColor.a);\n\n\t\t// 材质\n\t\tvec4 tColor = texture(uSampler, vTexCoord);\n\t\t// 绘制字体\n\t\tvec4 textColor = drawText(tColor);\n\t\t// 绘制普通对象\n\t\tvec4 normalColor = drawNormal(tColor, bgColor);\n\n\t\tvec4 color = vIsText * textColor + (1.0 - vIsText) * normalColor;\n\t\tcolor.a *= vOpacity;\n\t\tfragColor = color;\n\t}\n`;\n")]),n("div",[n("h3",[t._v("贴图显示逻辑")]),n("pre",[t._v("顶点色能做到的效果有限，所以有另一套机制:UV坐标。\nUV坐标指的是顶点对应在图片的哪个位置，仍旧拿上面的效果举例，4个顶点(左下、右下、右上、左上)分别和图片的4个角对应，那么UV坐标就是下面这样:\n\nstatic const glm::vec3 Positions[6] =\n{\n    //第一个三角形\n    { -1.0f, -1.0f, 0.0f},//左下\n    {  1.0f, -1.0f, 0.0f},//右下\n    {  1.0f,  1.0f, 0.0f},//右上\n    //第二个三角形\n    {  1.0f,  1.0f, 0.0f},//右上\n    { -1.0f,  1.0f, 0.0f},//左上\n    { -1.0f, -1.0f, 0.0f} //左下\n};\nstatic const glm::vec2 UVs[6] = \n{\n    //第一个三角形\n    {  0.0f,  0.0f},//左下\n    {  1.0f,  0.0f},//右下\n    {  1.0f,  1.0f},//右上\n    //第二个三角形\n    {  1.0f,  1.0f},//右上\n    {  0.0f,  1.0f},//左上\n    {  0.0f,  0.0f} //左下\n}\n\nUV坐标范围是[0,1]；顶点坐标和图片对应起来的操作，一般叫做UV映射\n\t")])]),n("section",[n("pre",[t._v("CPU与GPU的通信方式：\n\nCPU和GPU是一种CS模式，即客户端-服务器模式。\n客户端不能直接访问服务器资源，客户端想对服务器资源进行操作，只能通过网络协议交互，由服务器进行操作。\nCPU就是客户端，GPU就是服务器。\n\n上传图片数据到显卡分为几步\n1   glGenTextures\t通知显卡创建纹理对象，返回句柄;\n2\tglBindTexture\t将纹理绑定到特定纹理目标;\n3\tglTexImage2D\t将图片rgb数据上传到GPU;\n\n上面的API都是阻塞式的。\n所以在游戏中，需要减小图片尺寸减少上传时间，需要打包图集减少上传次数\n\n")])]),n("pre",[t._v("引擎主循环每执行一次，都需要上传顶点数据到GPU\n在实际项目中是不可行的，游戏同屏顶点数普遍超过10w，每一帧都上传10w顶点数据到GPU，想想都可怕。\n\n针对性的优化有2点：\n1.减少上传数据量---- 顶点索引\n2.在GPU上缓存数据---- 缓冲区对象\n\n\n顶点坐标数据是一个数组，那么顶点索引就是这个数组的index; 将顶点坐标去重，然后新建数组存储下标\n一个顶点，包含了顶点坐标、顶点颜色、UV坐标这三个数据\n使用顶点索引(kVertexIndexVector)进行绘制，需要引入新的API - glDrawElements\n\nglDrawElements 通过顶点索引进行绘制，大幅度减少了上传到GPU的数据，但是仍然是每一帧都上传一次。\n是否可以将数据缓存在GPU，这样只需要上传一次即可？ OpenGL引入了Buffer Object，即缓冲区对象;\n顶点数据上传到GPU之后，就缓存起来，后续渲染直接从显存获取,\n\n使用缓冲区对象进行绘制分为以下步骤：\n创建VBO(顶点缓冲区对象) 和 EBO(索引缓冲区对象)，并上传数据\n将Shader变量和缓冲区对象进行关联\n使用EBO绘制\n")]),n("p",[t._v(" openGL3.0 ")]),n("pre",[t._v("从 #version 110 升级为 #version 330\n增加了顶点数组对象(Vertex Array Object，简称VAO)\n使用关键字in 替代 attribute\n使用关键字out 替代varying\n采样函数从texture2D变为texture\n片段着色器的输出，可以使用关键字out指定自定义变量。\n\n顶点着色器\n#version 330 core\nuniform mat4 u_mvp;\nlayout(location = 0) in  vec3 a_pos;\nlayout(location = 1) in  vec4 a_color;\nout vec4 v_color;\nvoid main()\n{\n    gl_Position = u_mvp * vec4(a_pos, 1.0);\n    v_color = a_color;\n};\n\n片段着色器\n#version 330 core\nin vec4 v_color;\nlayout(location = 0) out vec4 o_fragColor;\nvoid main()\n{\n    o_fragColor = v_color;\n}\n\n顶点数组对象(Vertex Array Object，简称VAO)可以减少OpenGL API的调用次数。\nVAO就像一个容器，在GPU端记录了一次绘制的顶点的状态。\n\n每次绘制时，需要绑定VBO、EBO，这就调用了2次API\n//指定当前使用的VBO\nglBindBuffer(GL_ARRAY_BUFFER, kVBO);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, kEBO);\n\n// 生成一个VAO\nglGenVertexArrays(1,kVAO);\nglBindVertexArray(kVAO);\n{\n    //指定当前使用的VBO\n    glBindBuffer(GL_ARRAY_BUFFER, kVBO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, kEBO);\n}\nglBindBuffer(GL_ARRAY_BUFFER, 0);\n\n在绘制的时候只要绑定VAO\nglBindVertexArray(kVAO);\n{\n    glDrawElements(GL_TRIANGLES,36,GL_UNSIGNED_SHORT,0);//使用顶点索引进行绘制，最后的0表示数据偏移量。\n}\nglBindVertexArray(0);\n\n将非动态的内容，都可以设置到VAO里面\n\n"),n("h3",[t._v("Mesh")]),t._v("\n"),n("p",[t._v("模型就是指Mesh")]),t._v("\nmesh包含一些列顶点数据，静态模型\n\n相机的作用就是提供View、Projection这两个矩阵，MeshRenderer拿到这两个矩阵和模型世界坐标相乘得到mvp，传入GPU。\n多相机渲染，就是要遍历多个相机，用当前 index 相机的View、Projection矩阵，提供给MeshRenderer拿去做计算\n\n所谓材质，就是一系列属性的集合。\n模型材质，是渲染这个模型所需要的一系列属性的集合，例如指定贴图、颜色。\n物理材质，就是物体用于物理计算所需要的一系列属性的集合，例如摩擦系数、弹性系数\n\n")]),n("pre",[t._v("代码主逻辑：\nOpenGL初始化，创建视口。\n初始化着色器。\n关联着色器变量和顶点数据\n执行主循环\n\n主循环：\n坐标系转换\n上传mvp矩阵\n调用 glDrawArrays 上传顶点数据并进行绘制(这就是一个DrawCall完成)\n")])])}],v={name:"Home",components:{}},f=v,_=(e("b77c"),Object(c["a"])(f,d,p,!1,null,"35c56331",null)),g=_.exports,b=function(){var t=this;t._self._c;return t._m(0)},m=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"wrapper"},[n("h3",[t._v("坐标系")]),n("img",{attrs:{width:"400px",src:e("34a5"),alt:""}}),n("p",[t._v("xyz")]),n("pre",[t._v("坐标系是描述物体或点的位置和方向的一种数学工具。它由坐标轴和原点组成，通常用于二维或三维空间中。\n\n坐标轴是一条直线，其上有等距离的点，用来表示某个方向上的距离。在二维坐标系中，通常有两条垂直的坐标轴，即水平轴和垂直轴；在三维坐标系中，则需要增加一条竖直的轴。这些轴通常用 x、y 和 z 表示，并通过原点相交。\n\n位置可以用一组数字（称为坐标）来描述。在二维坐标系中，每个点都有一个唯一的坐标，由它在水平轴和垂直轴上的位置确定。在三维坐标系中，每个点由它在三个轴上的位置确定。\n\n坐标系不仅可以用来描述物体或点在空间中的位置和方向，还可以用于计算距离、角度、速度、加速度等物理量。它在数学、物理、工程、计算机科学等领域都有广泛应用。\n\n## 二维笛卡尔坐标系\n\n笛卡尔坐标系由两条互相垂直的直线，即 x 轴和 y 轴组成\n\n在平面直角坐标系中，每个点都可以通过一对有序实数(x, y)来表示。其中，x 坐标表示点到 y 轴的水平距离；y 坐标表示点到 x 轴的竖直距离。通常情况下，x 轴向右为正方向，y 轴向上为正方向。\n\n参考系不一样，最终造成二者的坐标表示内容也是不一样的，其实这点可以类推我们在图形学中讲到的物体坐标系。每个物体都有自己单独的坐标系，这样就会造成标准不统一，难以在统一的条件下进行控制多个物体。\n\n## 三维笛卡尔坐标系\n\nx、y、z 分别表示点到 yz 平面、xz 平面和 xy 平面的距离。通常情况下，x 轴向右为正方向，y 轴向上为正方向，z 轴向前为正方向。三维笛卡尔坐标系广泛应用于各种领域，如数学、物理、工程、计算机图形学等。\n在计算机图形学中，三维坐标系被用来描述三维物体的位置、大小和形状等属性，是实现三维渲染、动画和虚拟现实等技术的基础。\n\n### 基向量\n\n在线性代数中，三个轴（在一维和二维情况下分别为一个或两个）构成了我们所说的该坐标系的基础。基向量是一组线性独立的向量，它们以线性组合表示给定向量空间（坐标系）中的每个向量。更改基向量或更改坐标系是数学和图形管道中的常见操作。\n\n基向量是一个矩阵或向量空间中的一组线性无关向量，可以通过它们来表示该空间中的任何向量。基向量集通常被称为基。\n在二维空间中，通常使用两个向量作为基向量。在三维空间中，则通常使用三个向量作为基向量。这些基向量被选为互相垂直且长度为 1，因此它们可以用来描述空间中的任何向量。\n更一般地说，在 n 维向量空间中，需要 n 个线性无关的基向量才能表示该空间中的所有向量。这些基向量通常被写成列向量的形式，并排列成一个矩阵，这个矩阵就被称为基矩阵。\n\n## 左手坐标系与右手坐标系\n\n"),n("img",{attrs:{width:"400px",src:e("8a76"),alt:""}}),t._v("\n\n坐标系标准\n\n当 x 轴指向右侧，y 轴指向上方时，如果 z 轴指向远离你，则为左手坐标系。如果它指向你的方向，则为右手坐标系。\n\n- 左手：远离你\n- 右手：朝你\n\n坐标系的惯用手性在从多边形面的边计算的法线方向中也起着重要作用。\n例如，如果方向为右手，则其折点按逆时针顺序指定的面将朝前。\n\n## 物体坐标系（模型坐标系、身体坐标系、个体坐标系）\n\n物体坐标系是三维空间中的一个坐标系，用于描述物体在三维空间中的位置和方向。通常情况下，物体坐标系的原点被定义为物体的质心或几何中心，并且其轴线会根据物体的形状而确定。\n\n物体坐标系是和特定物体相关联的坐标系。每个物体都有它们独立的坐标系。\n\n结合实现的例子给大家举例子，比如此刻你要去北京天安门玩耍，高德导航会告诉你“向左转，向右转”。此时是以你个人为中心，也就等同于我们所讲的物体坐标系下的运动。\n\n有时候你行走的方向相反了，或者你偏移了很大角度，高德地图一般会提示你“您的方向偏移，请向南出发”此时他的意思就是在世界坐标系下进行的提醒，此刻你的目的地和你本身都是放在世界坐标系下去衡量的。\n\n**在计算机图形学中，物体坐标系通常被用来描述三维模型的位置、旋转和缩放状态。当需要对三维模型进行变换时，可以通过对其物体坐标系进行变换来实现**\n例如，通过对物体坐标系进行平移变换，可以将模型沿着某个轴线上移动一定距离；通过对物体坐标系进行旋转变换，可以将模型绕某个轴线旋转一定角度。\n\n## 世界坐标系（全局坐标系、宇宙坐标系）\n\n世界坐标系有很多名字，它类同于笛卡尔坐标系，只是它具有了物理属性，赋予了它在实际中的例子。\n上面我们提到其实每个物体都有自己的坐标系，但是实际我们在日常应用中，我们需要将各个坐标系进行统一化，在一个相同的约束下进行计算。所以世界坐标系就产生了，每个物体相对于世界坐标系都有自己的坐标。\n我们经常在小学学习地理的时候，老师告诉我们更具地球经纬度就可以获取到你的位置，所以人类根据这个基本原理，设定了 WGS 84 坐标系。学地理或者学 GIS 的同学一定对这个概念很清楚。实际上相对于地球来说，世界坐标系在球体的质心。\n\n世界坐标系是一个特殊的坐标系，它建立了描述其他坐标系所需要的参考框架。\n从另一方面说，能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系来描述世界坐标系。在世界坐标系里面的任何一个东西，我们都能用世界坐标表示。\n\n## 惯性坐标系\n\n惯性坐标系实际上是世界坐标系与物体坐标系的中间模块，为了方便二者转换，引入了一种新的坐标系，称作惯性坐标系。惯性坐标系的原点和物体坐标系的原点重合，惯性坐标系的轴平行于世界标系的轴\n\n- 为什么引入惯性坐标系\n  因为从物体标系转换到惯性标系只需旋转；\n  从惯性标系转换到界坐标系只需要平移。\n\n## 嵌套坐标系\n\n所谓的“嵌套坐标系”实际上是世界坐标系和物体坐标系的综合，\n比如举个例子，你仍然要去北京天安门游玩，在去的路上你相对地球来说，你的位置不断发生位移，这就属于在世界坐标系的坐标变换，\n\n在去天安门游玩的路上，你在路上吸了口烟，吐了口吐沫。这两个动作实际上是相对于你本身而言的，也就是物体坐标系。在实际程序开发中，我们应用嵌套坐标系的例子很多，比如我们在做人物奔跑、漫游、行走、坐下等连续式动画的时候\n\n## 相机坐标系\n"),n("img",{attrs:{width:"400px",src:e("cff6"),alt:""}}),t._v("\n\n相机坐标系可以想象成你本人的观察视角。\n\n摄像机坐标系能被看作是一种特殊的“物体”坐标系，该“物体”坐标系就定义在摄像机的屏幕可视区域。\n摄像机坐标系中，摄像机在原点，x 轴向右，z 轴向前(朝向屏幕内或摄像机方向)，y 轴向上(不是世界的上方而是摄像机本身的上方)。\n\n## 投影坐标系（裁减坐标系）\n\n投影坐标系，也称为裁减坐标系，是计算机图形学中一个重要的概念。\n在三维图形学中，我们通常使用三维对象描述场景。然而，在实际应用中，我们需要在二维屏幕上显示这些场景。因此，必须将三维场景中的点映射到二维投影平面上。这个过程就需要用到投影坐标系。\n\n投影坐标系一般分为正交投影和透视投影。\n\n## 屏幕坐标系\n\n屏幕坐标系是计算机图形学中用于表示屏幕上的像素位置的坐标系。\n它通常是一个以左上角为原点（0,0）的二维直角坐标系，其中水平方向向右为正方向，垂直方向向下为正方向。\n在屏幕坐标系中，每个像素都可以由其 x 和 y 坐标确定。\n例如，屏幕上的某个像素可能具有坐标 (100, 200)，这意味着它距离屏幕左侧 100 个像素，距离屏幕顶部 200 个像素。\n\n## 坐标系转换\n\n其实坐标系转换是同一个事物在不同坐标系下的表现形式。两个不同坐标的转换过程被称为“坐标系转换”。\n\nhttps://www.bilibili.com/video/BV1HU4y1e7JS/?vd_source=01ae3fc576acbf5bd3e59f3307bb594f\n\n    ")])])}],A={name:"Home",components:{}},x=A,M=(e("b75e"),Object(c["a"])(x,b,m,!1,null,"444e43a2",null)),O=M.exports,T=function(){var t=this;t._self._c;return t._m(0)},w=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"wrapper"},[n("h2",[t._v("点&向量")]),n("img",{attrs:{width:"400px",src:e("3260"),alt:""}}),n("h3",[t._v("点")]),t._v(" 点是最基础的几何形状了吧。点是三维空间中的一个位置 vec3 a= vec3(0.5,0.5,1); // 函数用来表示一个在 z 轴上面的点 "),n("h3",[t._v("向量")]),n("pre",[t._v("物理层面：大小，方向的箭头，起点 》终点\n计算机层面：坐标系中的点坐标 x，y\n\n二维空间中， 原点 -> 终点\n[1\n2]\n\n三维空间\n[1\n2\n3]\n\n### 向量加法\n\n各坐标轴的分量相加，平移\n数乘，缩放\n\n## 2.向量坐标\n\n坐标轴看着标量\n\n基向量：坐标系中单位长度为 1\na = bW + vV\n二维向量 a 都可以看做基向量 v，w 的线性组合\nv 和 w 全部的向量组合为 张成的空间\n")]),n("h3",[t._v("向量desc")]),n("pre",[t._v("\n向量又称为矢量，具体定义我们不再过多介绍。但向量可以在 CG 中可以用数字数组表示。这个数字数组可以假定任何所需的长度，有时也称为数学中的元组\n\n元组是数学中的一个概念，它指的是有序数对或者有序 n 元组。元组的形式可以表示为 (a1, a2, ..., an)，其中每个元素 ai 可以是任意数值类型，也可以是其他数据类型。在数学中，元组通常用于描述多个变量之间的关系或者属性。例如，一个二维平面上的点可以表示为一个含有两个元素的元组 (x, y)\n\n在计算机图形学中，向量可以表示空间中的位置或方向。CG 中提供了很多方法来操控这些向量，变换这些向量的方法我们称为线性变换: 线性变换是指一种将一个向量空间中的向量映射到另一个向量空间中的操作。线性变换在向量空间中有着广泛的应用，包括矩阵乘法、旋转、缩放、投影等等\n\n### 行向量与列向量\n\n行向量: directX 就是行向量\n行向量是一个 1 × n 的矩阵，其中 n 是元素的数量。例如：\nA=[a₁,a₂,...,aₙ]\n\n列向量: opengl 就是列向量\n列向量是一个 n × 1 的矩阵，其中 n 是元素的数量。例如：\nb=[\n1,\n2,\n3\n]\n\n```js\n/**\n * 向量通常指一个有长度有方向的量。向量使所有的移动和空间行为更容易理解和在代码中实现。\n * 向量可以相加，缩放，旋转，指向某物体。\n * 在javascript中，一个方向和长度(即向量)在二维空间中可以用横坐标x和纵坐标y表示。\n */\n\nconst EPSILON = 0.00000001;\nconst areEqual = (one, other, epsilon = EPSILON) => Math.abs(one - other) < epsilon;\n\n// 向量由一系列数值构成，每维数值都是向量的一个分量\n// 1.方向\n// 2.长度\n// const length = Math.sqrt(x * x + y * y);\n\n// ** 角是以弧度( radian )为单位，不是角度( degree ) **\n// 1弧度是弧长和半径相等的弧，圆的周长：2*Math.PI*R(R为半径)，圆的弧度：2*Math.PI\n//弧度转角度\nconst toDegrees = (radians) => (radians * 180) / Math.PI;\n//角度转弧度\nconst toRadians = (degrees) => (degrees * Math.PI) / 180;\n\n// ======= 向量的运算 =======\nclass Vector {\n  constructor(...vectors) {\n    this.vectors = vectors; // [1, 2]\n  }\n\n  // 向量加：返回一个新向量\n  // 1.向量相加\n  // 将向量看成一个运动，从原点出发，向v方向移动长度∣v∣后，再向w方向移动长度∣w∣后，就等于直接向 v+w方向移动长度∣v+w∣\n  add({ vectors }) {\n    return new Vector(...vectors.map((v, index) => this.vectors[index] + v));\n  }\n  // 向量减：返回一个新向量\n  subtract({ vectors }) {\n    return new Vector(...vectors.map((v, index) => this.vectors[index] - v));\n  }\n  // 对一个向量进行缩放，缩放比例可为任意数值 α ∈ R。缩放时，对所有向量分量都乘以缩放因子 α。\n  // 当 α > 1 时，向量会变得更长；\n  // 当 0 ≤ α ≤ 1 时，向量会变得更短。\n  // 如果 α 是负数，缩放后的向量将会指向原向量的反方向。\n  // 乘法\n  scaleBy(number) {\n    return new Vector(...this.vectors.map((v) => v * number));\n  }\n  // 向量长度可由勾股定理导出\n  length() {\n    return Math.hypot(...this.vectors);\n  }\n  // 点积\n  // 点积可以计算出两个向量的相似程度。点积方法接收两个向量作为输入，并输出一个数值。\n  // 两个向量的点积等于它们各自对应分量的乘积之和。\n  // a*b = |a|*|b|*con0\n  // 计算投影， 分解， 方向\n  // https://docs.pingcode.com/ask/38308.html\n  dotProduct({ otherVectors }) {\n    return otherVectors.reduce(\n      (acc, ov, index) => acc + ov * this.vectors[index],\n      0\n    );\n  }\n  // 在我们观察几个向量间的方向关系前，需要先实现一种将向量长度归一化为 1 的方法\n  // 归一化向量，该方向的单位向量\n  normalize() {\n    return this.scaleBy(1 / this.length());\n  }\n  // 如果两个归一化后的向量的点积结果等于 1，则意味着这两个向量的方向相同。\n  haveSameDirectionWith(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, 1);\n  }\n  // = -1， 反向\n  haveOppositeDirectionTo(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, -1);\n  }\n  // = 0， 垂直\n  isPerpendicularTo(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, 0);\n  }\n  // 叉积\n  // 叉积仅对三维向量适用，它会产生垂直于两个输入向量的向量\n  // 只适用于 3 维向量， 计算法向量， 计算三维坐标系\n  // |a*b| = |a||b|sin0\n  // 用来判断方向，两个向量的左右关系， 是否在三角形内外\n  crossProduct({ others }) {\n    return new Vector(\n      this.vectors[1] * others[2] - this.vectors[2] * others[1],\n      this.vectors[2] * others[0] - this.vectors[0] * others[2],\n      this.vectors[0] * others[1] - this.vectors[1] * others[0]\n    );\n  }\n\n  // 计算夹角\n  angleBetween(other) {\n    return toDegrees(\n      Math.acos(this.dotProduct(other) / (this.length() * other.length()))\n    );\n  }\n\n  // 当需要将一个向量的方向指向反向时，我们可以对这个向量进行 -1 缩放\n  negate() {\n    return this.scaleBy(-1);\n  }\n\n  // 投影\n  // 在向量other上的投影\n  projectOn(other) {\n    // other的单位向量\n    const otherStandardVect = other.normalize();\n    // other的单位向量和one的点乘值\n    const sv = this.dotProduct(otherStandardVect);\n    return otherStandardVect.scaleBy(sv);\n  }\n\n  // 为了判断两个向量是否相等，可以对它们对应的分量使用 areEqual 函数\n  equalTo({ components }) {\n    return components.every((component, index) =>\n      areEqual(component, this.vectors[index])\n    );\n  }\n\n  // 单位向量与基底\n}\n```\n\n## 法线\n\n法线（Normal）是指垂直于曲面或多边形表面的向量。法线通常被用来计算光照和阴影，以及决定物体表面如何反射光线\n\n## 向量的基\n\n对于任何二维的向量点 C\n[1,\n2]\n\nC = Ai + Bj, i 和 j 为基向量\n基可以变化\n\n## 线性相关\n\n## 向量张成的空间\n\n由基向量组合的所有向量形成的空间\n\n    ")])])}],y={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},S=y,E=(e("d733"),Object(c["a"])(S,T,w,!1,null,"f7343104",null)),R=E.exports,D=function(){var t=this;t._self._c;return t._m(0)},V=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"wrapper"},[n("h2",[t._v("矩阵")]),n("img",{attrs:{width:"600px",src:e("1aa6"),alt:""}}),n("h3",[t._v("矩阵本质")]),n("img",{attrs:{width:"400px",src:e("0b6d"),alt:""}}),n("img",{attrs:{width:"400px",src:e("de67"),alt:""}}),n("pre",[t._v("        矩阵如同线性变换 =》一种空间变换\n\n- 线性变换\n  输入向量 =》 输出向量\n\n从输入向输出移动，理解为一种运动\n\n所有的输入点 经过变换 到达输出点\n\n线性变换：1.原点不变， 2.直线还是线\n- 变换基向量即可\n\nn阶矩阵列 可以理解为 变换基\n\n矩阵 * 向量 =》新向量\n    ")]),n("h3",[t._v("# 矩阵 matrix")]),n("pre",[t._v("\n由 `m*n 个数排成的 m 行 n 列的数表称为 m 行 n 列的矩阵，简称 m*n` 矩阵;\n行数与列数都等于 n 的矩阵称为 n 阶矩阵或 n 阶方阵\n\n线性变换\n\n- 原点不变，直线性不变\n\nVin \\* Mat = Vout\n\n向量乘矩阵： 变换得到一个新向量\nx[] + y[] = v\n\n## 秩\n\n矩阵秩是矩阵理论中的一个重要概念，它描述了矩阵所包含的线性无关向量的个数\n\n矩阵秩的通俗易懂定义是：一个矩阵的秩就是它所包含的线性无关列向量（或行向量）的最大数量。\n可以简单地理解为一个矩阵中不重复的列向量（或行向量）的数量\n\nhttps://www.zhihu.com/question/21605094\n`「秩」是图像经过矩阵变换之后的空间维度 `\n\n秩」是列空间的维度; 首先看下什么是列空间\n\n```js\nconst m = [1, 2\n           2, 1]\n\n// 所以，列空间就是矩阵的列向量 ai + bj 来表示的空间。\n\n```\n\n## 奇异矩阵\n\n奇异矩阵是线性代数的概念，就是该矩阵的秩不是满秩。\n\n首先，看这个矩阵是不是方阵（即行数和列数相等的矩阵，若行数和列数不相等，那就谈不上奇异矩阵和非奇异矩阵）。如是方阵，再看此矩阵的行列式|A|是否等于 0，若等于 0，称矩阵 A 为奇异矩阵；若不等于 0，称矩阵 A 为非奇异矩阵。\n\n## 逆矩阵\n\n逆矩阵是指对于一个给定的方阵 A，如果存在一个方阵 B 使得 A 乘以 B 等于 B 乘以 A 等于单位矩阵 I，则称方阵 B 为 A 的逆矩阵，记作\nA−1\n其中，我们上面讲到单位矩阵指的是对角线上所有元素都为 1，其余元素都为 0 的方阵。\n\n要求一个矩阵 A 的逆矩阵，需要保证以下两个条件都满足：\n\n- 矩阵 A 必须是一个方阵。只有方阵才具有逆矩阵。\n- 矩阵 A 必须是可逆的。即行列式不为 0。\n\n## 转置\n\n考虑一个 RXC 矩阵 M。M 的转置记作 MT，是一个 RXC 矩阵，它的列由 M 的行组成。可以从另一方面理解，MT=M，即沿着矩阵的对角线翻折。如下面这个例子\n\n对于任意矩阵 M，(MT)T=M 。从另一方面来说，将一个矩阵转置后，再转置一次，便会得到原矩阵。\n这条法则对向量也适用,对于任意对角矩阵 D，都有 DT =D，包括单位矩阵 I 也如此。\n\n    ")])])}],I={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},N=I,P=(e("0f9f"),Object(c["a"])(N,D,V,!1,null,"24b2cdae",null)),C=P.exports,L=function(){var t=this,n=t._self._c;return n("div",[n("h2",[t._v("测试图形api")]),n("div",{staticClass:"api-wrapper"},[n("div",[n("span",[t._v("箭头mesh")]),n("input",{directives:[{name:"model",rawName:"v-model",value:t.arrowType,expression:"arrowType"}],attrs:{type:"radio",value:"1"},domProps:{checked:t._q(t.arrowType,"1")},on:{change:function(n){t.arrowType="1"}}}),t._v(" 单向 "),n("input",{directives:[{name:"model",rawName:"v-model",value:t.arrowType,expression:"arrowType"}],attrs:{type:"radio",value:"2"},domProps:{checked:t._q(t.arrowType,"2")},on:{change:function(n){t.arrowType="2"}}}),t._v(" 双向 "),n("button",{on:{click:t.handleDrawArrow}},[t._v("绘制箭头mesh")])]),n("div",[n("span",[t._v("矩形mesh")]),n("button",{on:{click:t.handleDrawRect}},[t._v("绘制矩形mesh")])]),n("div",[t._v("清除 "),n("button",{on:{click:t.handleClear}},[t._v("清除上下文")])]),n("div",[n("h3",[t._v("视口操作")]),n("div",[t._v(" 偏移： x："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOffsetX,expression:"vpOffsetX"}],domProps:{value:t.vpOffsetX},on:{input:function(n){n.target.composing||(t.vpOffsetX=n.target.value)}}}),t._v(" y："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOffsetY,expression:"vpOffsetY"}],domProps:{value:t.vpOffsetY},on:{input:function(n){n.target.composing||(t.vpOffsetY=n.target.value)}}})]),n("div",[t._v(" 缩放原点： x："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOx,expression:"vpOx"}],domProps:{value:t.vpOx},on:{input:function(n){n.target.composing||(t.vpOx=n.target.value)}}}),t._v(" y："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOy,expression:"vpOy"}],domProps:{value:t.vpOy},on:{input:function(n){n.target.composing||(t.vpOy=n.target.value)}}})]),n("div",[t._v(" 缩放比率(0.05-2)："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpScaleRatio,expression:"vpScaleRatio"}],domProps:{value:t.vpScaleRatio},on:{input:function(n){n.target.composing||(t.vpScaleRatio=n.target.value)}}}),n("button",{on:{click:t.handleSetVp}},[t._v("设置视口")])])])]),n("canvas",{attrs:{id:"canvas",width:"600px",height:"600px"}})])},j=[],B=(e("a573"),e("ade3"));e("d9e2"),e("14d9"),e("2c66"),e("249d"),e("40e9"),e("907a"),e("986a"),e("1d02"),e("3c5d"),e("6ce5"),e("2834"),e("4ea1"),e("4e3e");const U="#version 300 es\n\tlayout(location=1) in vec4 currVertexAndRatio;\t\t\t // 指定currVertexAndRatio变量在顶点属性数组中的位置是1 // 顶点坐标和变形系数\n\tlayout(location=2) in vec4 prevVertexAndRatio;\n\tlayout(location=3) in vec4 nextVertexAndRatio;\n\tlayout(location=4) in vec4 uvAndEdgeOffsetRatio;\t\t// UV\n\tlayout(location=5) in vec4 vertexAndEdgeOffsetValueAndNotFollowViewport;\t// 顶点形变  边形变值  是否不跟随视口\n\tlayout(location=6) in vec4 UVRect;\t\t\t\t\t\t// UVRect\n\tlayout(location=7) in vec4 backgroundColor;\t\t\t\t// 背景色\n\tlayout(location=8) in vec4 translationAndRotation;\t\t// 形变\n\tlayout(location=9) in vec4 isTextAndBorderWidthAndDashedAndScale;\t\t// 是否渲染文字 以及 文字边框粗细 以及物体边框虚线 缩放\n\tlayout(location=10) in vec4 textBorderColor;\t\t\t// 文字边框颜色\n\tlayout(location=11) in vec4 opacityAndDisplayAndVpScaleAndVpTrans;\t\t\t// 透明度 是否显示 是否跟随视口缩放 是否跟随视口平移\n    \n\tout vec2 vTexCoord;\t\t\t\t// UV  // out是从顶点着色器传递到片段着色器（用于处理像素颜色）的数据\n\tout vec4 vBgColor;\n\tout float vIsText;\n\tout float vTextBorderWidth;\n\tout vec4 vTextBorderColor;\n\tout float vHasTexture;\n\tout vec4 vPos;\n\tout float vNotBorder;\n\tout float vBorderDashed;\n\tout float vOpacity;\n\tout float vDisplay;\n\n    // 应用程序和着色器之间传递传递参数\n\tuniform vec2 uConversionVec2;\t//坐标转换\n\tuniform vec2 uViewportTranslation;\t//视口平移\n\tuniform vec2 uViewportScale;\t\t//视口缩放\n\tuniform float uViewportRotation;\t//视口旋转\n\tuniform vec4 uOpacity;\t\t\t\t//全局透明度\n\n\tmat4 getScaleMatrix(vec2 scale) {\n\t\treturn mat4(\n\t\t\tscale.x, 0.0, 0.0, 0.0,\n\t\t\t0.0, scale.y, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getRotationMatrix(float radian) {\n\t\tfloat cost = cos(radian);\n\t\tfloat sint = sin(radian);\n\t\treturn mat4(\n\t\t\tcost, -sint, 0.0, 0.0,\n\t\t\tsint, cost, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getTranslationMatrix(vec2 translation) {\n\t\treturn mat4(\n\t\t\t1.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\ttranslation.x, translation.y, 0.0, 1.0\n\t\t);\n\t}\n\n    // 找到两个向量夹角平分线上的一个特定点，这个点距离每个向量的端点都是 offset 距离\n\tvec2 getIntersectionVertex(\n\t\tin vec2 v1,\n\t\tin vec2 v2,\n\t\tin float offset\n\t) {\n\t\tvec4 vv1 = vec4(v1, 0.0, 1.0);\n\t\tvec4 vv2 = vec4(v2, 0.0, 1.0);\n\t\t// 向量夹角\n\t\tvec2 mid = normalize(normalize(v1) + normalize(v2));\n\t\tfloat theta = acos(dot(v1, v2) / (length(v1) * length(v2)));\n\t\t// 右手法则，判断夹角正负\n\t\tvec3 c = cross(vv1.xyz, vv2.xyz);\n\t\tfloat l = offset / sin(theta * 0.5);\n\t\treturn mid * l * (- sign(c.z));\n\t}\n\n    // 将一个点按照给定的比率和值进行偏移，用于创建动画、调整对象位置\n\tvec2 getVertex(\n\t\tin vec2 origin,\n\t\tin vec2 offsetRatio,\n\t\tin vec2 offsetValue\n\t) {\n\t\tvec2 offset = offsetRatio * offsetValue;\n\t\treturn origin + offset;\n\t}\n   \n\tvec2 getFollowViewport() {\n\t\tfloat outViewportStatus = vertexAndEdgeOffsetValueAndNotFollowViewport.w;  // 跟随视口状态\t\n\t\tvec3 f = vec3(outViewportStatus - 1.0, outViewportStatus - 2.0, outViewportStatus - 3.0);\n\t\tf = step(vec3(0.5, 0.5, 0.5), abs(f));\n\t\treturn vec2(f.x * f.z, f.y * f.z);\n\t}\n\n\t// 获取缩放矢量\n\tvec2 getScaleVec(float scale, vec2 followViewport, vec2 notFollowViewport) {\n\t\tvec2 scaleVec = vec2(scale, scale);\n\t\tvec2 isVpScale = vec2(1.0, 1.0) - opacityAndDisplayAndVpScaleAndVpTrans.zz;\n\t\tvec2 dscaleVec = vec2(1.0, 1.0) / uViewportScale * scaleVec * isVpScale + scaleVec * (1.0-isVpScale);\n\t\treturn dscaleVec * followViewport + scaleVec * notFollowViewport;\n\t}\n\n\tvoid main(void) {\n\t\tvec2 pv = getVertex(prevVertexAndRatio.xy, prevVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 cv = getVertex(currVertexAndRatio.xy, currVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 nv = getVertex(nextVertexAndRatio.xy, nextVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 pe = pv - cv;\n\t\tvec2 ne = nv - cv;\n\n\t\t// 判断是否需要乘视口矩阵\n\t\tvec2 followViewport = getFollowViewport();\n\t\tvec2 notFollowViewport = vec2(1.0, 1.0) - followViewport;\n\n\t\t// 各种矩阵\n\t\tmat4 rotationMatrix = getRotationMatrix(translationAndRotation.z);\n\t\t// 缩放矩阵，如果设置了脱离视口，则需要计算一个反向缩放矩阵\n\t\tmat4 scaleMatrix = getScaleMatrix(getScaleVec(isTextAndBorderWidthAndDashedAndScale.w, followViewport, notFollowViewport));\n\t\tmat4 transMat = getTranslationMatrix(translationAndRotation.xy);\n\t\tmat4 converMat = getScaleMatrix(uConversionVec2.xy);\n\t\t// 视口矩阵\n\t\tmat4 vpScaleMatrix = getScaleMatrix(uViewportScale);\n\t\tmat4 vpTranslationMatrix = getTranslationMatrix(uViewportTranslation);\n\t\tmat4 vpRotationMatrix = getRotationMatrix(uViewportRotation);\n\t\tmat4 vpMat = vpTranslationMatrix * vpScaleMatrix * converMat * vpRotationMatrix;\n\n\t\t// 求相邻两边交点向量\n\t\tvec2 intersection = getIntersectionVertex(pe, ne, vertexAndEdgeOffsetValueAndNotFollowViewport.z * uvAndEdgeOffsetRatio.z);\n\n\t\tvec4 posOrigin = transMat * scaleMatrix * rotationMatrix * vec4(cv, 0.0, 1.0);\n\t\tvec4 posBorder = rotationMatrix * vec4(intersection, 0.0, 0.0);\n\t\tposBorder = converMat * vec4(vec2(vpRotationMatrix * posBorder) * followViewport + posBorder.xy * notFollowViewport, 0, 0);\n\t\tposOrigin = vec4(vec2(vpMat * posOrigin) * followViewport + vec2(converMat * posOrigin) * notFollowViewport, 0.0, 1.0);\n\n\t\tgl_Position = posOrigin + posBorder;\n\n\t\t// out\n\t\t// 如果材质宽度为0 则标志为无材质\n\t\tvHasTexture = step(0.0, UVRect.z);\n\t\tvTexCoord = uvAndEdgeOffsetRatio.xy * UVRect.zw + UVRect.xy;\n\t\tvBgColor = backgroundColor;\n\t\tvIsText = isTextAndBorderWidthAndDashedAndScale.x;\n\t\tvTextBorderWidth = isTextAndBorderWidthAndDashedAndScale.y;\n\t\tvTextBorderColor = textBorderColor;\n\t\tvNotBorder = step(vertexAndEdgeOffsetValueAndNotFollowViewport.z, 0.0);\n\n\t\tvPos = rotationMatrix * vec4(cv, 0.0, 1.0); // 用于边框渲染计算\n\t\tvPos = vec4(vec2(vpRotationMatrix * vPos) * followViewport + vPos.xy * notFollowViewport, 0.0, 1.0);\n\n\t\tvBorderDashed = isTextAndBorderWidthAndDashedAndScale.z;\n\t\tvOpacity = opacityAndDisplayAndVpScaleAndVpTrans.x * uOpacity.x;\n\t\tvDisplay = opacityAndDisplayAndVpScaleAndVpTrans.y;\n\t}\n",F=" #version 300 es\n\tprecision mediump float;\n\tuniform sampler2D uSampler;\n\t// uniform vec2 uConversionVec2;\t// 坐标转换\n\tin vec2 vTexCoord; // 从顶点着色器传入的纹理坐标\n\tin vec4 vBgColor; // 从顶点着色器传入的背景颜色\n\tin float vIsText;\n\tin float vTextBorderWidth;\n\tin vec4 vTextBorderColor;\n\tin float vHasTexture;\n\tin vec4 vPos;\n\tin float vNotBorder;\n\tin float vBorderDashed;\n\tin float vOpacity;\n\tin float vDisplay;\n\tout vec4 fragColor; // 片段着色器的输出颜色，将被用于最终的像素颜色\n\n    // 确定一个片段是否应该被渲染为虚线边框的一部分\n\tfloat inBorderDashed() {\n\t\t// 是否绘制虚线\n\t\tfloat hasDashed = 1.0 - step(vBorderDashed, 0.0);\n\t\tvec2 fw = fwidth(vPos.xy);\n\t\tfloat k = fw.y * (1.0/fw.x);\n\t\t// 如果k在 0.95 和 1.05 之间\n\t\tfloat c1 = step(0.95, k) * step(k, 1.05);\n\t\t// 如果 c1 == 0.1 则 c2 = 0.0 否则 c2 = 1.0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 如果 c1 条件成立 则 gl_FragCoord.x 否则 ...\n\t\tfloat d = gl_FragCoord.x * c1 + (step(1.0, k) * gl_FragCoord.y + step(k, 1.0) * gl_FragCoord.x) * c2;\n\t\treturn step(mod(floor( d * (1.0/vBorderDashed) ), 2.0), 0.0) * hasDashed;\n\t}\n\n\tvec4 drawText(vec4 texture) {\n\t\t// 文字边框是否大于0\n\t\tfloat c1 = step(0.1, vTextBorderWidth);\n\t\t// 文字边框是否小于等于0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 第一个插值阶梯\n\t\tfloat start = max(0.0, 0.5 - vTextBorderWidth * 0.1);\n\t\t// 边框插值系数\n\t\tfloat r1 = smoothstep(start, start + 0.2, texture.r) * c1;\n\t\t// 文字插值系数\n\t\tfloat r2 = smoothstep(0.5, 0.85, texture.r);\n\n\t\treturn vec4(mix(vTextBorderColor.rgb, vBgColor.rgb, r2), r2+(1.0-r2)*r1);\n\t}\n\n\tvec4 drawNormal(vec4 texture, vec4 bgColor) {\n\t\tfloat a1 = texture.a * vHasTexture;\n\t\tfloat a2 = bgColor.a;\n\t\treturn vec4(mix(bgColor.rgb, texture.rgb, a1), a1+(1.0-a1)*a2);\n\t}\n\n\tvoid main(void) {\n        // 丢弃不显示的片段\n\t\tif(vDisplay == 0.0 || vOpacity == 0.0) {\n\t\t\tdiscard;\n\t\t\treturn;\n\t\t}\n\n\t\t// ib == 0.0 则正常渲染， ib == 1.0 则渲染反色\n\t\tfloat ib = inBorderDashed();\n\t\tvec4 bgColor = vec4(vBgColor.rgb * (1.0 - ib) + (vec3(1.0, 1.0, 1.0) - vBgColor.rgb) * ib, vBgColor.a);\n\n\t\t// 材质\n\t\tvec4 tColor = texture(uSampler, vTexCoord);\n\t\t// 绘制字体\n\t\tvec4 textColor = drawText(tColor);\n\t\t// 绘制普通对象\n\t\tvec4 normalColor = drawNormal(tColor, bgColor);\n\n\t\tvec4 color = vIsText * textColor + (1.0 - vIsText) * normalColor;\n\t\tcolor.a *= vOpacity;\n\t\tfragColor = color;\n\t}\n";var k=e("25a5");function W(t,n){for(var e=t[0],r=t[1],o=!1,i=n.length/2,a=0,s=i-1;a<i;s=a,a++){var c=n[2*a],l=n[2*a+1],h=n[2*s],u=n[2*s+1];if(c===e&&l===r||h===e&&u===r){o=!0;break}if(l<r&&u>=r||l>=r&&u<r){var d=c+(r-l)*(h-c)/(u-l);if(d===e){o=!0;break}d>e&&(o=!o)}}return o}class G{constructor(){Object(B["a"])(this,"_sobj",void 0),Object(B["a"])(this,"_buffer",void 0),this._sobj=new k(200),this._buffer=new Map}objToItem(t){return Object.assign(t.bounds,{id:t.id})}insert(t){if(!t)return void console.log("Searcher: ","Can not insert.",t);const n=t.bounds;if(!((n.minX-n.maxX)*(n.minY-n.maxY)))return void console.log("Searcher: ","Can not insert, width or height equals 0.");const e=t.id,r=this._buffer.get(e);r&&this.remove(e),this._sobj.insert(this.objToItem(t)),this._buffer.set(t.id,t)}remove(t){let n=this._buffer.get(t);n&&(this._sobj.remove(this.objToItem(n)),this._buffer.delete(n.id))}search(t,n,e=0,r=0){let o=this._sobj.search({minX:t,minY:n,maxX:e+t,maxY:r+n}).map(t=>this._buffer.get(t.id));return 0==e&&0==r&&(o=o.filter(e=>W([t,n],e.vertexes))),o}}class H{constructor(t){Object(B["a"])(this,"_srh",void 0),Object(B["a"])(this,"_sable",!1),Object(B["a"])(this,"_expandRadius",0),this._srh=t}set searchable(t){t!=this._sable&&(this._sable=t,!0===t?this.registToSearcher():this.deregistToSearcher())}get searchable(){return this._sable}set expandRadius(t){this._expandRadius!=t&&(this._expandRadius=t,this._sable&&this.registToSearcher())}get expandRadius(){return this._expandRadius}get id(){return""}getVertexPositions(t=0){return[]}registToSearcher(){const t=this.getVertexPositions(this._expandRadius),n=t.filter((t,n)=>n%2==0),e=t.filter((t,n)=>n%2!=0),r={id:this.id,bounds:{minX:Math.min.apply(null,n),maxX:Math.max.apply(null,n),minY:Math.min.apply(null,e),maxY:Math.max.apply(null,e)},vertexes:t};this._srh.insert(r)}deregistToSearcher(){this._srh.remove(this.id)}}class Y{constructor(t=0,n=0){Object(B["a"])(this,"root",void 0),Object(B["a"])(this,"mw",void 0),Object(B["a"])(this,"mh",void 0),this.mw=t,this.mh=n}fit(t){var n,e,r,o=t.length,i=o>0?t[0].w:0,a=o>0?t[0].h:0;for(this.root={x:0,y:0,w:i,h:a},n=0;n<o;n++)r=t[n],(e=this.findNode(this.root,r.w,r.h))?r.fit=this.splitNode(e,r.w,r.h):r.fit=this.growNode(r.w,r.h);return t}findNode(t,n,e){return t.used?this.findNode(t.right,n,e)||this.findNode(t.down,n,e):n<=t.w&&e<=t.h?t:null}splitNode(t,n,e){return t.used=!0,t.down={x:t.x,y:t.y+e,w:t.w,h:t.h-e},t.right={x:t.x+n,y:t.y,w:t.w-n,h:e},t}growNode(t,n){if(!(this.root.w+t>this.mw||this.root.h+n>this.mh)){var e=t<=this.root.w,r=n<=this.root.h,o=r&&this.root.h>=this.root.w+t,i=e&&this.root.w>=this.root.h+n;return o?this.growRight(t,n):i?this.growDown(t,n):r?this.growRight(t,n):e?this.growDown(t,n):null}console.error("Texture too large.")}growRight(t,n){this.root={used:!0,x:0,y:0,w:this.root.w+t,h:this.root.h,down:this.root,right:{x:this.root.w,y:0,w:t,h:this.root.h}};let e=this.findNode(this.root,t,n);return e?this.splitNode(e,t,n):null}growDown(t,n){this.root={used:!0,x:0,y:0,w:this.root.w,h:this.root.h+n,down:{x:0,y:this.root.h,w:this.root.w,h:n},right:this.root};let e=this.findNode(this.root,t,n);return e?this.splitNode(e,t,n):null}}var q=e("f0e6");class z{constructor(){Object(B["a"])(this,"eventList",{})}dispatchEvent(t,...n){let e=this.eventList[t];e&&e.forEach(t=>{t[0].apply(t[1],n)})}addEventListener(t,n,e){let r=this.eventList[t];r||(r=[],this.eventList[t]=r),r.push([n,e])}removeEventListener(t,n,e){var r=this.eventList[t];if(r)for(var o=r.length,i=o-1;i>=0;i--)r[i][0]==n&&r[i][1]==e&&r.splice(i,1);r&&0==r.length&&(this.eventList[t]=null,delete this.eventList[t])}}const X={MAX_WIDTH:Math.pow(2,11),MAX_HEIGHT:Math.pow(2,11)},J={fontSize:Math.pow(2,7),fontFamily:"Sans-serif",fontWeight:"normal"},K=Math.pow(2,1);class ${constructor(t){Object(B["a"])(this,"gl",void 0),Object(B["a"])(this,"packer",void 0),Object(B["a"])(this,"blocks",[]),Object(B["a"])(this,"fontMaps",new Map),Object(B["a"])(this,"texture",void 0),this.gl=t;const n=t,e=X.MAX_WIDTH,r=X.MAX_HEIGHT;this.packer=new Y(e,r),this.texture=n.createTexture(),n.bindTexture(n.TEXTURE_2D,this.texture),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,1),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR),n.texStorage2D(n.TEXTURE_2D,1,n.RGBA8,e,r)}getOriginTexture(){return this.texture}createTexture(t,n,e){t||(t=new Uint8Array(n*e*4),t.fill(0));const r=new Q;return r.index=this.blocks.length,this.blocks.push({w:n+K,h:e+K,data:{source:t,texture:r}}),this.updateToGL(),r}getFontTexture(t){const n=t.substr(0,1);return""==n?null:(this.fontMaps.has(n)||(this.embedFont(n),this.updateToGL()),this.fontMaps.get(t))}getFontTextures(){return this.fontMaps}embedFont(t){const n=new q(J.fontSize,J.fontSize/8,J.fontSize/3,null,J.fontFamily,J.fontWeight),e=n.size;for(let r=0;r<t.length;r++){let o=t[r];const i=this.fontMaps.get(o);if(i&&i instanceof Q)continue;const a=n.draw(o,e);let s=new Q;s.index=this.blocks.length,this.blocks.push({w:e+K,h:e+K,data:{source:a,texture:s}}),this.fontMaps.set(o,s)}}updateToGL(){this.gl,this.blocks;this.packer.fit(this.blocks);const t=this.blocks.map((t,n)=>t.data.texture).filter(t=>0==t.isReady);t.forEach(t=>this.updateTextureToGL(t))}updateTextureToGL(t){const n=t.index,e=this.blocks[n],r=this.gl,o=K,i=.5*o,a=e.fit.x+i,s=e.fit.y+i,c=e.w-o,l=e.h-o;t.update(a,s,c,l),r.texSubImage2D(r.TEXTURE_2D,0,a,s,c,l,r.RGBA,r.UNSIGNED_BYTE,e.data.source),t.isReady=!0}copyToTexture(t,n=0,e=0){const r=t.index,o=this.blocks[r],i=this.gl,a=K,s=.5*a,c=o.fit.x+s,l=o.fit.y+s,h=o.w-a,u=o.h-a;i.copyTexSubImage2D(i.TEXTURE_2D,0,c,l,n,e,h,u)}}const Z={UPDATE:"update"};class Q extends z{constructor(){super(),Object(B["a"])(this,"u",0),Object(B["a"])(this,"v",0),Object(B["a"])(this,"width",0),Object(B["a"])(this,"height",0),Object(B["a"])(this,"index",0),Object(B["a"])(this,"isReady",!1)}update(t,n,e,r,o=-1){const i=X.MAX_WIDTH,a=X.MAX_HEIGHT;this.u=t/i,this.v=n/a,this.width=e/i,this.height=r/a,o>=0&&(this.index=o),this.dispatchEvent(Z.UPDATE,this)}}var tt=e("c83a");tt["vec2"];const nt=tt["vec3"];const et={NONE:0,DISPLAY:1};function rt(t){return new Promise((n,e)=>{const r=new Image;r.onload=()=>n(r),r.src=t})}function ot(t){return Promise.all(t.map(t=>rt(t)))}class it{static createId(){return this.num++,this.num.toString()}}function at(t,n,e,r){const o=nt.normalize(nt.create(),t),i=nt.normalize(nt.create(),n);let a=nt.add(nt.create(),o,i);a=nt.normalize(a,a);let s=Math.acos(nt.dot(t,n)/(nt.length(t)*nt.length(n))),c=nt.cross(nt.create(),o,i),l=Math.sign(c[2]),h=r/Math.sin(.5*s);return a.map((t,n)=>t*h*l+e[n])}function st(t,n,e){return t.map((t,r)=>t+n[r]*e[r])}function ct(t,n,e){return Math.min(n,Math.max(t,e))}Object(B["a"])(it,"num",0);const lt=tt["mat4"],ht=(tt["vec2"],tt["vec3"]),ut=window.devicePixelRatio,dt={TRANSLATION_CHANGE:"translationChange",SCALE_CHANGE:"scaleChange",SIZE_CHANGE:"sizeChange",ROTATION_CHANGE:"rotationChange"};class pt extends z{constructor(t){super(),Object(B["a"])(this,"_engine",void 0),Object(B["a"])(this,"_gl",void 0),Object(B["a"])(this,"_cvec2",new Float32Array(2)),Object(B["a"])(this,"_vpScaleVec2",new Float32Array(2)),Object(B["a"])(this,"_vpTranslationVec2",new Float32Array(2)),Object(B["a"])(this,"_vpRotation",0),Object(B["a"])(this,"_bgColor",[0,0,0,1]),Object(B["a"])(this,"_vpWidth",void 0),Object(B["a"])(this,"_vpHeight",void 0),Object(B["a"])(this,"tempMat4",lt.create()),Object(B["a"])(this,"tempVec3",ht.create()),Object(B["a"])(this,"scaleMin",.05),Object(B["a"])(this,"scaleMax",2),Object(B["a"])(this,"cvMatIsModified",!0),Object(B["a"])(this,"vpScaleIsModified",!0),Object(B["a"])(this,"vpTranslationIsModified",!0),Object(B["a"])(this,"vpRotationIsModified",!0),this._gl=t.gl,this._engine=t;const n=this._gl.canvas;this.setViewportSize(n.width,n.height),this.reset()}setBackgroundColor(t){this._bgColor=t,this._gl.clearColor.apply(this._gl,t.map(t=>t/255))}getBackgroundColor(){return this._bgColor}setViewportSize(t,n,e=!0){this._vpWidth=t,this._vpHeight=n;const r=this._gl,o=t*ut,i=n*ut;if(r.viewport(0,0,o,i),this._cvec2.set([1/t*2,1/n*2]),this.cvMatIsModified=!0,e){const e=r.canvas;e.width=o,e.height=i,e.style.width=t+"px",e.style.height=n+"px"}this.dispatchEvent(dt.SIZE_CHANGE)}getViewportSize(){return[this._vpWidth,this._vpHeight]}scaleOrigin(t,n,e,r=!0){t=ct(this.scaleMin,this.scaleMax,t);const o=this._vpScaleVec2,i=this._engine.sizeRatio,a=(this.scale-t)*i,s=t/this.scale;o[0]*=s,o[1]*=s;const c=Math.cos(this._vpRotation),l=Math.sin(this._vpRotation);let h=n*c+e*l,u=e*c-n*l;this.translate(h*a,u*a,r),this.vpScaleIsModified=!0,r&&this.dispatchEvent(dt.SCALE_CHANGE)}translate(t,n,e=!0){const r=this._vpWidth,o=this._vpHeight;this._vpTranslationVec2[0]+=t/r*2,this._vpTranslationVec2[1]+=n/o*2,this.vpTranslationIsModified=!0,e&&this.dispatchEvent(dt.TRANSLATION_CHANGE)}rotate(t,n=!0){this._vpWidth,this._vpHeight;this._vpRotation+=t,this.vpRotationIsModified=!0,n&&this.dispatchEvent(dt.ROTATION_CHANGE)}reset(t=!0){this._gl,this._vpWidth,this._vpHeight;this._vpTranslationVec2.set([-1,-1]),this._vpScaleVec2.set([1,1]),this._vpRotation=0,this.vpTranslationIsModified=!0,this.vpScaleIsModified=!0,this.vpRotationIsModified=!0,t&&(this.dispatchEvent(dt.SCALE_CHANGE),this.dispatchEvent(dt.TRANSLATION_CHANGE),this.dispatchEvent(dt.ROTATION_CHANGE))}resetTranslationAndScale(t,n,e=1,r=0,o=0,i=!0){const a=this._engine.sizeRatio;this.reset(!1),this.translate(t*a,n*a,!1),this.scaleOrigin(e,r,o,!1),i&&(this.dispatchEvent(dt.SCALE_CHANGE),this.dispatchEvent(dt.TRANSLATION_CHANGE),this.dispatchEvent(dt.ROTATION_CHANGE))}get scale(){return this._vpScaleVec2[0]}get translation(){const t=this._vpTranslationVec2,n=this._engine.sizeRatio,e=this.scale*n;return[(t[0]+1)*this._vpWidth*.5/e,(t[1]+1)*this._vpHeight*.5/e]}set scaleRange(t){this.scaleMin=t[0],this.scaleMax=t[1]}get scaleRange(){return[this.scaleMin,this.scaleMax]}changeCoordinateFromScreen(t,n){const e=this.tempVec3,r=this.tempMat4,o=this._engine;lt.identity(r),e.set([this._vpTranslationVec2[0],this._vpTranslationVec2[1],0]),lt.translate(r,r,e),e.set([this._vpScaleVec2[0]*o.sizeRatio,this._vpScaleVec2[1]*o.sizeRatio,1]),lt.scale(r,r,e),e.set([this._cvec2[0],this._cvec2[1],1]),lt.scale(r,r,e),lt.rotateZ(r,r,-this._vpRotation),lt.invert(r,r);const i=this._vpWidth/2,a=this._vpHeight/2;return e.set([t/i-1,-n/a+1,0]),ht.transformMat4(e,e,r),e.subarray(0,2)}get cvec2(){return this._cvec2}get vpScaleVec2(){return this._vpScaleVec2}get vpTranslationVec2(){return this._vpTranslationVec2}get vpRotation(){return this._vpRotation}}tt["glMatrix"].setMatrixArrayType(Float32Array);class vt{constructor(t){if(Object(B["a"])(this,"_gl",void 0),Object(B["a"])(this,"_prg",void 0),Object(B["a"])(this,"_searcher",void 0),Object(B["a"])(this,"_tf",void 0),Object(B["a"])(this,"_vp",void 0),Object(B["a"])(this,"_unitList",void 0),Object(B["a"])(this,"_vpScaleLocal",void 0),Object(B["a"])(this,"_vpTranslationLocal",void 0),Object(B["a"])(this,"_vecLocal",void 0),Object(B["a"])(this,"_vpRotationLocal",void 0),Object(B["a"])(this,"_sizeRatio",1),Object(B["a"])(this,"isDebug",!0),Object(B["a"])(this,"canRending",!0),this._gl=t.getContext("webgl2",{alpha:!1,premultiplyAlpha:!1,antialias:!0}),!this._gl)throw Error("not support WebGL2");this._unitList=[],this._searcher=new G,this._tf=new $(this._gl),this._vp=new pt(this),this.initPrg(),window["unitlist"]=this._unitList}get gl(){return this._gl}get prg(){return this._prg}get searcher(){return this._searcher}get textureFactroy(){return this._tf}get viewport(){return this._vp}get sizeRatio(){return this._sizeRatio}set sizeRatio(t){this._sizeRatio=t,this._vp.vpScaleIsModified=!0}initPrg(){let t=this.gl;const n=this.loadShader(t,t.VERTEX_SHADER,U),e=this.loadShader(t,t.FRAGMENT_SHADER,F);this._prg=t.createProgram(),t.attachShader(this._prg,n),t.attachShader(this._prg,e),t.linkProgram(this._prg),t.getProgramParameter(this._prg,t.LINK_STATUS)||alert("Could not initialise shaders"),t.useProgram(this._prg),t.enable(t.BLEND),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_DST_COLOR),this._vpScaleLocal=t.getUniformLocation(this._prg,"uViewportScale"),this._vpTranslationLocal=t.getUniformLocation(this._prg,"uViewportTranslation"),this._vpRotationLocal=t.getUniformLocation(this._prg,"uViewportRotation"),this._vecLocal=t.getUniformLocation(this._prg,"uConversionVec2")}loadShader(t,n,e){const r=t.createShader(n);return t.shaderSource(r,e),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)?r:(alert("An error occurred compiling the shaders: "+t.getShaderInfoLog(r)),t.deleteShader(r),null)}render(){this.canRending&&(this.draw(),window.requestAnimationFrame(()=>this.render()))}draw(t=null,n=!1){const e=this.gl,r=this.updateViewport(),o=this.updateConversionVec();let i=!1,a=[];const s=this._unitList;a=t&&t.length>0?t.map(t=>s[t]):s,a.forEach(t=>{t.forEach(t=>{t.updateToGL()&&(i=!0)})}),(n||r||o||i)&&(e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),a.forEach(t=>{t.filter(t=>t.display==et.DISPLAY).forEach(t=>{t.updateUniform(),t.draw()})}))}updateViewport(){const t=this.gl;let n=!1;return this._vp.vpScaleIsModified&&(t.uniform2fv(this._vpScaleLocal,this._vp.vpScaleVec2.map(t=>t*this._sizeRatio)),this._vp.vpScaleIsModified=!1,n=!0),this._vp.vpTranslationIsModified&&(t.uniform2fv(this._vpTranslationLocal,this._vp.vpTranslationVec2),this._vp.vpTranslationIsModified=!1,n=!0),this._vp.vpRotationIsModified&&(t.uniform1f(this._vpRotationLocal,this._vp.vpRotation),this._vp.vpRotationIsModified=!1,n=!0),n}updateConversionVec(){if(this._vp.cvMatIsModified){const t=this.gl;return t.uniform2fv(this._vecLocal,this._vp.cvec2),this._vp.cvMatIsModified=!1,!0}return!1}registVAO(t,n=0){return this._unitList[n]||(this._unitList[n]=[]),this._unitList[n].push(t),t}unRegistVAO(t,n=0){if(n>=this._unitList.length)return;const e=this._unitList[n].indexOf(t);e<0||this._unitList[n].splice(e,1)}}const ft={TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class _t{constructor(t,n,e,r,o){Object(B["a"])(this,"_vertexes",void 0),Object(B["a"])(this,"_offsetRatios",void 0),Object(B["a"])(this,"_uv",void 0),Object(B["a"])(this,"_indeces",void 0),Object(B["a"])(this,"_primitiveMode",void 0),this._vertexes=n,this._offsetRatios=e,this._uv=r,this._indeces=o,this._primitiveMode=t}get currVertexes(){return this._vertexes}get prevVertexes(){let t=this._vertexes;return t.slice(-2).concat(t.slice(0,t.length-2))}get nextVertexes(){let t=this._vertexes;return t.slice(2).concat(t.slice(0,2))}get currOffsetRatios(){return this._offsetRatios}get prevOffsetRatios(){let t=this._offsetRatios;return t.slice(-2).concat(t.slice(0,t.length-2))}get nextOffsetRatios(){let t=this._offsetRatios;return t.slice(2).concat(t.slice(0,2))}get originMeshConfig(){let t=new Array(this._vertexes.length);return t.fill(0),{currVertexes:this.currVertexes,prevVertexes:this.prevVertexes,nextVertexes:this.nextVertexes,currOffsetRatios:this.currOffsetRatios,prevOffsetRatios:this.prevOffsetRatios,nextOffsetRatios:this.nextOffsetRatios,edgeOffsetRatios:t,indeces:this._indeces,uvs:this._uv,primitiveMode:this._primitiveMode}}get borderMeshConfig(){let t=this.currVertexes.length,n=this.currVertexes,e=this.prevVertexes,r=this.nextVertexes,o=this.currOffsetRatios,i=this.prevOffsetRatios,a=this.nextOffsetRatios,s=new Array(2*t),c=new Array;s.fill(0);let l=new Array(t/2);l.fill(0);let h=new Array(t/2);h.fill(1);let u=l.concat(h);t/=2;for(let d=0;d<t;d++)c[2*d]=d,c[2*d+1]=t+d;return c.push(c[0],c[1]),n=n.concat(n),e=e.concat(e),r=r.concat(r),o=o.concat(o),i=i.concat(i),a=a.concat(a),{currVertexes:n,prevVertexes:e,nextVertexes:r,currOffsetRatios:o,prevOffsetRatios:i,nextOffsetRatios:a,edgeOffsetRatios:u,indeces:c,uvs:s,primitiveMode:ft.TRIANGLE_STRIP}}}class gt extends _t{constructor(t=0,n=0){const e=[0,0,0,0,0,0,0,0];let r=[-.5,.5,-.5,-.5,.5,-.5,.5,.5];const o=[0,1,0,0,1,0,1,1],i=[0,1,3,2];r=r.map((e,r)=>r%2==0?e-t:e-n),super(ft.TRIANGLE_STRIP,e,r,o,i)}}class bt extends _t{constructor(t=20,n=20){const e=[-.2,0,.2,0,.2,0,.5,0,0,1,-.5,0,-.2,0].map((e,r)=>r%2==0?e*t:e*n),r=[0,0,0,0,0,1,0,1,0,1,0,1,0,1],o=new Array(e.length),i=[0,1,6,2,5,3,4];super(ft.TRIANGLE_STRIP,e,r,o,i)}}class mt extends _t{constructor(t=20,n=20){const e=[0,0,.5,1,.2,1,.2,1,.5,1,0,2,-.5,1,-.2,1,-.2,1,-.5,1].map((e,r)=>r%2==0?e*t:e*n),r=[0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0],o=new Array(e.length),i=[0,1,9,2,8,3,7,4,6,5];super(ft.TRIANGLE_STRIP,e,r,o,i)}}const At=3e3,xt=tt["mat4"],Mt=tt["vec3"],Ot={CURR_VERTEX_AND_RATIO:"currVertexAndRatio",NEXT_VERTEX_AND_RATIO:"nextVertexAndRatio",PREV_VERTEX_AND_RATIO:"prevVertexAndRatio",UV_AND_EDGE_OFFSET_RATIO:"uvAndEdgeOffsetRatio"};var Tt=new Map;Tt.set(Ot.CURR_VERTEX_AND_RATIO,4),Tt.set(Ot.NEXT_VERTEX_AND_RATIO,4),Tt.set(Ot.PREV_VERTEX_AND_RATIO,4),Tt.set(Ot.UV_AND_EDGE_OFFSET_RATIO,4);const wt={VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT:"vertexAndEdgeOffsetValueAndNotFollowViewport",BACKGROUND_COLOR:"backgroundColor",UV_RECT:"UVRect",TRANSLATION_AND_ROTATION:"translationAndRotation",IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE:"isTextAndBorderWidthAndDashedAndScale",TEXT_BORDER_COLOR:"textBorderColor",OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS:"opacityAndDisplayAndVpScaleAndVpTrans"};var yt=new Map;yt.set(wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,4),yt.set(wt.BACKGROUND_COLOR,4),yt.set(wt.UV_RECT,4),yt.set(wt.TRANSLATION_AND_ROTATION,4),yt.set(wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,4),yt.set(wt.TEXT_BORDER_COLOR,4),yt.set(wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,4);const St=[wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,wt.BACKGROUND_COLOR,wt.UV_RECT,wt.TRANSLATION_AND_ROTATION,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,wt.TEXT_BORDER_COLOR,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS],Et={OPACITY:"uOpacity"},Rt=[Et.OPACITY];class Dt{constructor(t,n,e=0){Object(B["a"])(this,"_engine",void 0),Object(B["a"])(this,"idmap",void 0),Object(B["a"])(this,"idlist",void 0),Object(B["a"])(this,"_meshConfig",void 0),Object(B["a"])(this,"vao",void 0),Object(B["a"])(this,"instanceCount",0),Object(B["a"])(this,"instanceCountMax",0),Object(B["a"])(this,"instanceCountInited",0),Object(B["a"])(this,"attribBuffers",new Map),Object(B["a"])(this,"attribBufferDatas",new Map),Object(B["a"])(this,"attribIsModifieds",new Map),Object(B["a"])(this,"attribLocals",new Map),Object(B["a"])(this,"uniformLocals",new Map),Object(B["a"])(this,"uniformDatas",new Map),Object(B["a"])(this,"_display",et.DISPLAY),Object(B["a"])(this,"displayIsModified",!1),this._engine=t,this._meshConfig=n;const r=t.gl,o=t.prg,i=Math.floor(e);this.instanceCountMax=i>0?i:At,this.instanceCountInited=this.instanceCountMax,St.forEach(t=>{const n=new Float32Array(this.instanceCountMax*yt.get(t));this.attribBuffers.set(t,r.createBuffer()),this.attribBufferDatas.set(t,n),this.attribIsModifieds.set(t,!0),this.attribLocals.set(t,r.getAttribLocation(o,t))}),Rt.forEach(t=>{this.uniformLocals.set(t,r.getUniformLocation(o,t)),this.uniformDatas.set(t,new Float32Array(4))}),this.uniformDatas.set(Et.OPACITY,new Float32Array([1,0,0,0])),this.idmap=new Map,this.idlist=[]}regist(){const t=this._engine.gl,n=this._meshConfig,e=n.currVertexes,r=n.prevVertexes,o=n.nextVertexes,i=n.currOffsetRatios,a=n.prevOffsetRatios,s=n.nextOffsetRatios,c=e.length/2,l=[],h=[],u=[],d=[],p=n.uvs,v=n.edgeOffsetRatios;for(let f=0;f<c;f++)l.push(e[2*f],e[2*f+1],i[2*f],i[2*f+1]),h.push(r[2*f],r[2*f+1],a[2*f],a[2*f+1]),u.push(o[2*f],o[2*f+1],s[2*f],s[2*f+1]),d.push(p[2*f],p[2*f+1],v[f],0);return this.vao=t.createVertexArray(),t.bindVertexArray(this.vao),this.registAttribute(Ot.CURR_VERTEX_AND_RATIO,new Float32Array(l)),this.registAttribute(Ot.PREV_VERTEX_AND_RATIO,new Float32Array(h)),this.registAttribute(Ot.NEXT_VERTEX_AND_RATIO,new Float32Array(u)),this.registAttribute(Ot.UV_AND_EDGE_OFFSET_RATIO,new Float32Array(d)),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint32Array(this._meshConfig.indeces),t.STATIC_DRAW),t.bindVertexArray(null),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),this}updateToGL(){const t=this._engine.gl;let n=this.displayIsModified;return t.bindVertexArray(this.vao),St.forEach(t=>{!0===this.attribIsModifieds.get(t)&&(this.updateBufferToGL(t,this.attribBuffers.get(t),this.attribBufferDatas.get(t),yt.get(t)),this.attribIsModifieds.set(t,!1),n=!0)}),this.displayIsModified=!1,n}updateUniform(){const t=this.engine.gl;Rt.forEach(n=>{t.uniform4fv(this.uniformLocals.get(n),this.uniformDatas.get(n))})}setAttribute(t,n,e,r=0){if(!t||""==t)return;const o=this.idmap.get(t),i=yt.get(n);let a;a=this.attribBufferDatas.get(n),this.attribIsModifieds.set(n,!0),a.set(e.slice(0,i-r),o*i+r)}getAttribute(t,n,e=0,r=0){const o=this.idmap.get(t),i=yt.get(n);let a;a=this.attribBufferDatas.get(n),this.attribIsModifieds.set(n,!0);const s=o*i+e;let c;return c=r>0?Math.min(s+r,(o+1)*i):(o+1)*i,Array.from(a.subarray(s,c))}add(){this.instanceCount==this.instanceCountMax&&this.grow();const t=this.createId(),n=this.instanceCount;return this.idmap.set(t,n),this.idlist[n]=t,this.instanceCount++,St.forEach(t=>this.attribIsModifieds.set(t,!0)),t}remove(t){const n=this.idmap.get(t),e=this.instanceCount;if(e<1||n<0||n>=e)return;St.forEach(n=>{this.removeAttributeBufferData(t,n),this.attribIsModifieds.set(n,!0)});const r=this.idlist[this.instanceCount-1];this.idmap.set(r,n),this.idlist[n]=r,this.idmap.delete(t),this.idlist.pop(),this.instanceCount--}clear(){if(this.instanceCountMax>this.instanceCountInited){const t=this.instanceCountMax/this.instanceCountInited;St.forEach(n=>{const e=this.attribBufferDatas.get(n).length;this.attribBufferDatas.set(n,new Float32Array(e/t))}),this.instanceCountMax=this.instanceCountInited}else this.attribBufferDatas.forEach(t=>t.fill(0));this.attribIsModifieds.forEach((t,n)=>this.attribIsModifieds.set(n,!0)),this.idmap.clear(),this.idlist=[],this.instanceCount=0}fill(t,n){this.attribBufferDatas.get(t).fill(n),this.attribIsModifieds.set(t,!0)}batchSet(t,n,e=0){const r=yt.get(t);if(r<=e)return;const o=this.attribBufferDatas.get(t),i=this.instanceCount,a=n.slice(0,r-e);let s=e;for(let c=0;c<i;c++)o.set(a,s),s+=r;this.attribIsModifieds.set(t,!0)}batchAdd(t,n,e=0){const r=yt.get(t);if(r<=e)return;const o=this.attribBufferDatas.get(t),i=this.instanceCount,a=n.slice(0,r-e),s=a.length;let c=e;for(let l=0;l<i;l++){for(let t=0;t<s;t++)o[c+t]+=a[t];c+=r}this.attribIsModifieds.set(t,!0)}destroy(){this.attribBuffers.clear(),this.attribBufferDatas.clear(),this.attribIsModifieds.clear(),this.idmap.clear(),this.idlist=[],this.instanceCount=0,this.vao=null}draw(){const t=this._engine.gl,n=this._meshConfig;t.bindVertexArray(this.vao),t.drawElementsInstanced(n.primitiveMode,n.indeces.length,t.UNSIGNED_INT,0,this.instanceCount)}set display(t){this._display=t}get display(){return this._display}set opacity(t){const n=Math.max(0,t),e=this.uniformDatas.get(Et.OPACITY);e.set([n],0),this.displayIsModified=!0}get opacity(){return this.uniformDatas.get(Et.OPACITY)[0]}get engine(){return this._engine}getVertexesPositionById(t,n=0){let e=this._meshConfig.currVertexes;const r=this._meshConfig.currOffsetRatios,o=this.getAttribute(t,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,0,2),i=this.getAttribute(t,wt.TRANSLATION_AND_ROTATION,0,2),a=this.getAttribute(t,wt.TRANSLATION_AND_ROTATION,2,1)[0],s=e.length/2;let c=xt.create();xt.fromZRotation(c,-a);let l=[];for(let u=0;u<s;u++){const t=Mt.fromValues(e[2*u],e[2*u+1],0),n=Mt.fromValues(r[2*u],r[2*u+1],0);let i=st(t,n,Mt.fromValues(o[0],o[1],0));l.push(i)}const h=[];for(let u=0;u<s;u++){let t=0==u?s-1:u-1,e=u==s-1?0:u+1;const r=l[t],o=l[u],a=l[e],d=r.map((t,n)=>t-o[n]),p=a.map((t,n)=>t-o[n]);let v=at(d,p,o,n);Mt.transformMat4(v,v,c),Mt.add(v,v,Mt.fromValues(i[0],i[1],0)),h.push(v[0],v[1])}return h}createId(){return it.createId()}registAttribute(t,n){const e=this.engine.gl,r=this.engine.prg,o=e.createBuffer(),i=Tt.get(t),a=e.getAttribLocation(r,t);e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),e.vertexAttribPointer(a,i,e.FLOAT,!1,0,0),e.enableVertexAttribArray(a)}updateBufferToGL(t,n,e,r,o=0){const i=this._engine.gl,a=(this._engine.prg,e.BYTES_PER_ELEMENT),s=this.attribLocals.get(t),c=this.instanceCount;i.bindBuffer(i.ARRAY_BUFFER,n),i.bufferData(i.ARRAY_BUFFER,e,i.DYNAMIC_DRAW,0,c*r),i.enableVertexAttribArray(s),i.vertexAttribPointer(s,r,i.FLOAT,!1,r*a,o*a),i.vertexAttribDivisor(s,1),i.bindBuffer(i.ARRAY_BUFFER,null)}removeAttributeBufferData(t,n){const e=this.idmap.get(t),r=this.attribBufferDatas.get(n),o=yt.get(n),i=Math.max(1,this.instanceCount-1),a=new Array(o);a.fill(0),r.set(r.slice(i*o,(i+1)*o),e*o),r.set(a,i*o)}grow(){St.forEach(t=>{let n=this.attribBufferDatas.get(t),e=new Float32Array(2*n.length);e.set(n),this.attribBufferDatas.set(t,e),n=null}),this.instanceCountMax*=2}}const Vt=window.devicePixelRatio,It={NONE:0,X:1,Y:2,BOTH:3};class Nt extends H{constructor(t,n){super(t.engine.searcher),Object(B["a"])(this,"_id",void 0),Object(B["a"])(this,"_originUnit",void 0),Object(B["a"])(this,"_borderUnit",void 0),Object(B["a"])(this,"_originId",void 0),Object(B["a"])(this,"_borderId",void 0),Object(B["a"])(this,"_isAdded",void 0),Object(B["a"])(this,"_isBorderAdded",void 0),Object(B["a"])(this,"_texture",void 0),Object(B["a"])(this,"_needReset",!1),Object(B["a"])(this,"_attribs",{translation:[0,0],rotation:0,scale:1,backgroundColor:[0,0,0,0],uv:null,vertexOffsetValue:[0,0],isText:!1,textBorderWidth:0,textBorderColor:[0,0,0,0],borderWidth:0,borderColor:[0,0,0,0],borderDashed:0,opacity:1,display:et.DISPLAY,outViewportStatus:It.NONE,attachViewportScale:!0,attachViewportTranslation:!0}),Object(B["a"])(this,"_attriblist",["vertexOffsetValue","translation","rotation","scale","backgroundColor","uv","borderWidth","borderColor","borderDashed","isText","textBorderWidth","textBorderColor","opacity","display","outViewportStatus","attachViewportScale","attachViewportTranslation"]),this._originUnit=t,this._borderUnit=n,this._id=it.createId()}get id(){return this._id}get engine(){return this._originUnit.engine}get isShown(){return this._isAdded}show(){return this._isAdded||(this._originId=this._originUnit.add(),this._isAdded=!0,this.updateStatus(),this.searchable&&this.registToSearcher()),this.borderWidth=this.borderWidth,this}hide(){return this._isAdded&&this._originUnit.remove(this._originId),this._isBorderAdded&&this._borderUnit.remove(this._borderId),this._isAdded=!1,this._isBorderAdded=!1,this._originId=null,this._borderId=null,this.deregistToSearcher(),this}set translation(t){this._isAdded&&this._originUnit.setAttribute(this._originId,wt.TRANSLATION_AND_ROTATION,t,0),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,wt.TRANSLATION_AND_ROTATION,t,0),this._attribs["translation"]=t,this.searchable&&this.registToSearcher()}get translation(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.TRANSLATION_AND_ROTATION,0,2):this._attribs["translation"]}set rotation(t){const n=[t];this._isAdded&&this._originUnit.setAttribute(this._originId,wt.TRANSLATION_AND_ROTATION,n,2),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,wt.TRANSLATION_AND_ROTATION,n,2),this._attribs["rotation"]=t,this.searchable&&this.registToSearcher()}get rotation(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.TRANSLATION_AND_ROTATION,2,1)[0]:this._attribs["rotation"]}set scale(t){const n=[t];this._isAdded&&this._originUnit.setAttribute(this._originId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,n,3),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,n,3),this._attribs["scale"]=t,this.searchable&&this.registToSearcher()}get scale(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,3,1)[0]:this._attribs["scale"]}set backgroundColor(t){const n=t.map(t=>t/255);this._isAdded&&this._originUnit.setAttribute(this._originId,wt.BACKGROUND_COLOR,n),this._attribs["backgroundColor"]=t}get backgroundColor(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.BACKGROUND_COLOR,0,4).map(t=>255*t):this._attribs["backgroundColor"]}set texture(t){if(null==t)return this._texture&&this._texture instanceof Q&&(this._texture.removeEventListener(Z.UPDATE,this.changeUV,this),this._texture=null),void this.changeUV(null);if(!(t instanceof Q))return;const n=this._texture,e=t;(this._needReset||n!=e)&&(n instanceof Q&&n.removeEventListener(Z.UPDATE,this.changeUV,this),this._texture=t,this.changeUV(this._texture),this._texture.addEventListener(Z.UPDATE,this.changeUV,this))}set borderWidth(t){if(this._isBorderAdded&&t==this._attribs.borderWidth)return;this._attribs["borderWidth"]=t;const n=[t];this._isBorderAdded?t>0?this._borderUnit.setAttribute(this._borderId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,n,2):this.removeBorder():t>0&&this.addBorder()}get borderWidth(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,2,1)[0]:this._attribs["borderWidth"]}set borderColor(t){const n=t.map(t=>t/255);this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,wt.BACKGROUND_COLOR,n),this._attribs["borderColor"]=t}get borderColor(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,wt.BACKGROUND_COLOR,0,4).map(t=>255*t):this._attribs["borderColor"]}set borderDashed(t){this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[t*Vt],2),this._attribs.borderDashed=t}get borderDashed(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,2,1)[0]:this._attribs.borderDashed}set vertexOffsetValue(t){this._originUnit.setAttribute(this._originId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,t),this._borderUnit.setAttribute(this._borderId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,t),this._attribs["vertexOffsetValue"]=t,this.searchable&&this.registToSearcher()}get vertexOffsetValue(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,0,2):this._attribs["vertexOffsetValue"]}set size(t){this.vertexOffsetValue=t}get size(){return this.vertexOffsetValue}set isText(t){let n=t?1:0;const e=[n];this._originUnit.setAttribute(this._originId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,e,0),this._attribs["isText"]=t}get isText(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,0,1)[0]:this._attribs["isText"]}set textBorderWidth(t){const n=[t];this._originUnit.setAttribute(this._originId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,n,1),this._attribs["textBorderWidth"]=t}get textBorderWidth(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,1,1)[0]:this._attribs["textBorderWidth"]}set textBorderColor(t){this._originUnit.setAttribute(this._originId,wt.TEXT_BORDER_COLOR,t.map(t=>t/255)),this._attribs["textBorderColor"]=t}get textBorderColor(){return this._attribs["textBorderColor"]}set opacity(t){const n=Math.max(0,t),e=[n];this._originUnit.setAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,0),this._borderUnit.setAttribute(this._borderId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,0),this._attribs["opacity"]=n}get opacity(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,0,1)[0]:this._attribs["opacity"]}set display(t){const n=[t];this._originUnit.setAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,1),this._borderUnit.setAttribute(this._borderId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,1),this._attribs["display"]=t}get display(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,1)[0]:this._attribs["display"]}set outViewportStatus(t){const n=[t];this._originUnit.setAttribute(this._originId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,n,3),this._borderUnit.setAttribute(this._borderId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,n,3),this._attribs["outViewportStatus"]=t}get outViewportStatus(){return this._isAdded?this._originUnit.getAttribute(this._originId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,3,1)[0]:this._attribs["outViewportStatus"]}set attachViewportScale(t){const n=t?1:0,e=[n];this._originUnit.setAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,2),this._borderUnit.setAttribute(this._borderId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,2),this._attribs["attachViewportScale"]=t}get attachViewportScale(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,2,1)[0]:this._attribs["attachViewportScale"]}set attachViewportTranslation(t){const n=t?1:0,e=[n];this._originUnit.setAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,3),this._borderUnit.setAttribute(this._borderId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,3),this._attribs["attachViewportTranslation"]=t}get attachViewportTranslation(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,3,1)[0]:this._attribs["attachViewportTranslation"]}getVertexPositions(t=0){return this._originUnit.getVertexesPositionById(this._originId,t)}changeUV(t){if(t&&t instanceof Q){const n=[t.u,t.v,t.width,t.height];this._isAdded&&this._originUnit.setAttribute(this._originId,wt.UV_RECT,n),this._attribs["uv"]=n}else this._isAdded&&this._originUnit.setAttribute(this._originId,wt.UV_RECT,[0,0,0,0])}updateStatus(){this._needReset=!0;this._attriblist;const t=this._attribs;this._isAdded&&(this._originUnit.setAttribute(this._originId,wt.TRANSLATION_AND_ROTATION,[t["translation"][0],t["translation"][1],t["rotation"]]),this._originUnit.setAttribute(this._originId,wt.BACKGROUND_COLOR,t["backgroundColor"].map(t=>t/255)),this._originUnit.setAttribute(this._originId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[t["isText"]?1:0,0,0,t["scale"]]),this._originUnit.setAttribute(this._originId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,[t["opacity"],t["display"],t["attachViewportScale"]?1:0,t["attachViewportTranslation"]?1:0]),this._originUnit.setAttribute(this._originId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,[t["vertexOffsetValue"][0],t["vertexOffsetValue"][1],t["borderWidth"],t["outViewportStatus"]])),this.changeUV(this._texture),this._needReset=!1}addBorder(){this._isBorderAdded||(this._borderId=this._borderUnit.add(),this._borderUnit.setAttribute(this._borderId,wt.TRANSLATION_AND_ROTATION,[this.translation[0],this.translation[1],this.rotation],0),this._borderUnit.setAttribute(this._borderId,wt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,[this.vertexOffsetValue[0],this.vertexOffsetValue[1],this.borderWidth,this.outViewportStatus],0),this._borderUnit.setAttribute(this._borderId,wt.BACKGROUND_COLOR,this.borderColor.map(t=>t/255),0),this._borderUnit.setAttribute(this._borderId,wt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[this.borderDashed*Vt,this.scale],2),this._borderUnit.setAttribute(this._borderId,wt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,[this.opacity,this.display,this.attachViewportScale?1:0,this.attachViewportTranslation?1:0],0),this._isBorderAdded=!0)}removeBorder(){this._isBorderAdded&&(this._borderUnit.remove(this._borderId),this._borderId=void 0,this._isBorderAdded=!1)}}const Pt=tt["vec2"],Ct={ONE_WAY:1,TWO_WAY:2};class Lt extends H{constructor(t,n,e,r=0){super(t.engine.searcher),Object(B["a"])(this,"_type",Ct.ONE_WAY),Object(B["a"])(this,"_id",void 0),Object(B["a"])(this,"_height",void 0),Object(B["a"])(this,"_indent",void 0),Object(B["a"])(this,"_fromTo",[0,0,0,0]),Object(B["a"])(this,"_oneObj",void 0),Object(B["a"])(this,"_twoObj",void 0),Object(B["a"])(this,"_isShown",!1),this._id=it.createId(),this._oneObj=t,this._twoObj=n,this._height=e,this._indent=r}get robj(){return this._type==Ct.ONE_WAY?this._oneObj:this._twoObj}get nobj(){return this._type==Ct.TWO_WAY?this._oneObj:this._twoObj}get id(){return this._id}get isShown(){return this._isShown}show(){return this._isShown||(this.robj.show(),this.nobj.hide(),this.setFromToAndWidth(),this._isShown=!0),this}hide(){return this._isShown?(this.robj.hide(),this._isShown=!1,this.deregistToSearcher(),this):this}get rid(){return this.robj.id}set fromTo(t){this._fromTo=t,this.setFromToAndWidth()}get fromTo(){return this._fromTo}set type(t){t!=this._type&&(this._type=t,this.nobj.hide(),this._isShown&&(this.robj.show(),this.borderWidth=this.nobj.borderWidth,this.borderColor=this.nobj.borderColor,this.borderDashed=this.nobj.borderDashed,this.opacity=this.nobj.opacity,this.display=this.nobj.display,this.backgroundColor=this.nobj.backgroundColor,this.outViewportStatus=this.nobj.outViewportStatus,this.attachViewportScale=this.nobj.attachViewportScale,this.attachViewportTranslation=this.nobj.attachViewportTranslation,this.setFromToAndWidth()))}get type(){return this._type}set backgroundColor(t){this.robj.backgroundColor=t}get backgroundColor(){return this.robj.backgroundColor}set borderWidth(t){this.robj.borderWidth=t}get borderWidth(){return this.robj.borderWidth}set borderColor(t){this.robj.borderColor=t}get borderColor(){return this.robj.borderColor}set borderDashed(t){this.robj.borderDashed=t}get borderDashed(){return this.robj.borderDashed}set opacity(t){this.robj.opacity=t}get opacity(){return this.robj.opacity}set display(t){this.robj.display=t}get display(){return this.robj.display}set outViewportStatus(t){this.robj.outViewportStatus=t}get outViewportStatus(){return this.robj.outViewportStatus}set attachViewportScale(t){this.robj.attachViewportScale=t}get attachViewportScale(){return this.robj.attachViewportScale}set attachViewportTranslation(t){this.robj.attachViewportTranslation=t}get attachViewportTranslation(){return this.robj.attachViewportTranslation}setFromToAndWidth(){const t=this._fromTo,n=this._indent,e=Pt.fromValues(t[0],t[1]),r=Pt.fromValues(t[2],t[3]),o=Pt.sub(Pt.create(),r,e),i=Pt.normalize(Pt.create(),o),a=Pt.len(o)-2*n,s=Pt.add(Pt.create(),i.map(t=>t*n),e),c=Math.atan2(o[0],o[1]);let l;l=this.type==Ct.ONE_WAY?Math.max(0,a-this._height):Math.max(0,a-2*this._height),this.robj.translation=s,this.robj.rotation=c,this.robj.vertexOffsetValue=[0,l],this.searchable&&this.registToSearcher()}getVertexPositions(t=0){return this.robj.getVertexPositions(t)}}class jt{constructor(t,n,e=0,r=1,o=0){Object(B["a"])(this,"_engine",void 0),Object(B["a"])(this,"originUnit",void 0),Object(B["a"])(this,"borderUnit",void 0),Object(B["a"])(this,"originIdx",void 0),Object(B["a"])(this,"borderIdx",void 0),this._engine=t,this.originIdx=Math.floor(e),this.borderIdx=Math.floor(r),this.originUnit=new Dt(t,n.originMeshConfig,o).regist(),this.borderUnit=new Dt(t,n.borderMeshConfig,o).regist(),this.engine.registVAO(this.originUnit,this.originIdx),this.engine.registVAO(this.borderUnit,this.borderIdx)}instance(){return new Nt(this.originUnit,this.borderUnit)}destroy(){this.engine.unRegistVAO(this.originUnit,this.originIdx),this.engine.unRegistVAO(this.borderUnit,this.borderIdx),this.originUnit.destroy(),this.borderUnit.destroy(),this.originUnit=null,this.borderUnit=null}clear(){this.originUnit.clear(),this.borderUnit.clear()}set opacity(t){this.originUnit.opacity=t,this.borderUnit.opacity=t}set display(t){this.originUnit.display=t,this.borderUnit.display=t}set translate(t){this.originUnit.batchAdd(wt.TRANSLATION_AND_ROTATION,t,0),this.borderUnit.batchAdd(wt.TRANSLATION_AND_ROTATION,t,0)}get engine(){return this._engine}}class Bt{constructor(t,n,e,r=0,o=0,i=1,a=0){Object(B["a"])(this,"_engine",void 0),Object(B["a"])(this,"og",void 0),Object(B["a"])(this,"tg",void 0),Object(B["a"])(this,"_height",void 0),Object(B["a"])(this,"_indent",void 0),this._engine=t,this.og=new jt(t,new bt(n,e),o,i,a),this.tg=new jt(t,new mt(n,e),o,i,a),this._height=e,this._indent=r}instance(){return new Lt(this.og.instance(),this.tg.instance(),this._height,this._indent)}destroy(){this.og.destroy(),this.tg.destroy(),this.og=null,this.tg=null}clear(){this.og.clear(),this.tg.clear()}set translate(t){this.og.translate=t,this.tg.translate=t}set display(t){this.og.display=t,this.tg.display=t}set opacity(t){this.og.opacity=t,this.tg.opacity=t}get engine(){return this._engine}}function Ut(){return[255*Math.random(),255*Math.random(),255*Math.random(),255]}function Ft(t,n,e=!1){let r=null;return function(...o){if(r&&window.clearTimeout(r),e){let e=!r;e&&t.apply(this,o),r=setTimeout(()=>{r=null},n)}else r=setTimeout(()=>{t.apply(this,o),r=null},n)}}function kt(t,n){let e=!0;return function(...r){e&&(t.apply(this,r),e=!1,setTimeout(()=>{e=!0},n))}}const Wt=e("8554"),Gt=e("405a"),Ht=e("11d9"),Yt=e("bafb");var qt={name:"xxx",components:{},data(){return{arrowType:1,vpOffsetX:0,vpOffsetY:0,vpOx:0,vpOy:0,vpScaleRatio:1}},mounted(){this.initCtx()},methods:{initCtx(){const t=document.getElementById("canvas");let n=new vt(t);n.isDebug=!1,n.sizeRatio=1;n.searcher;let e=n.textureFactroy,r=n.viewport;r.setBackgroundColor([186,186,186,255]),window.vp=r,window.engine=n;let o=[];console.log("engine",n),ot([Wt,Gt,Ht,Yt]).then(t=>{o=t.map(t=>{e.createTexture(t,t.width,t.height)}),window.textures=o,this.initRender(n,o)})},initRender(t,n){t.render()},handleClear(){window.g1&&window.g1.clear(),window.g2&&window.g2.clear(),window.g3&&window.g3.clear()},handleSetVp(){const t=+this.vpOffsetX,n=+this.vpOffsetY,e=+this.vpScaleRatio,r=+this.vpOx,o=+this.vpOy;window["vp"].resetTranslationAndScale(t,n,e,r,o),console.log(window["vp"])},handleDrawArrow(){1==this.arrowType?this.drawOneWayArrow():this.drawTwoWayArrow()},handleDrawRect(){this.drawRects(window.engine,window.textures[0],10,0,0,600)},drawRects(t,n,e,r,o,i){const a=new gt,s=new jt(t,a);window.g1=s;const c=e,l=i/c;for(let h=0;h<c;h++)for(let t=0;t<c;t++){let e=Ut();e[3]=200;let i=s.instance();i.searchable=!1,i.show(),i.translation=[h*l+l/2+r,t*l+l/2+o],i.backgroundColor=e,i.texture=n,i.size=[l,l],i.rotation=Math.PI/6,h%3==0&&(i.borderWidth=1,i.borderDashed=2,i.borderColor=Ut())}},drawOneWayArrow(){const t=new bt(100,100),n=new jt(window.engine,t);window.g2=n;const e=n.instance().show();e.translation=[300,300],e.vertexOffsetValue=[0,100],e.rotation=Math.PI/4,e.backgroundColor=Ut(),e.searchable=!0,e.expandRadius=20},drawTwoWayArrow(){const t=new Bt(window.engine,100,100,10);window.g3=t;const n=t.instance();n.fromTo=[0,0,200,200],n.type=2,n.show(),n.backgroundColor=Ut(),n.borderWidth=3,n.borderDashed=10,n.borderColor=[0,0,0,255],n.searchable=!0,n.expandRadius=20}}},zt=qt,Xt=(e("e891"),Object(c["a"])(zt,L,j,!1,null,"59e8921a",null)),Jt=Xt.exports,Kt=function(){var t=this,n=t._self._c;return n("div",[n("div",{staticClass:"i-nav"},t._l(t.interviewsList,(function(e){return n("router-link",{key:e.path,attrs:{to:e.path}},[t._v(t._s(e.name))])})),1),n("router-view")],1)},$t=[],Zt={name:"xxx",components:{},data(){return{interviewsList:[]}},mounted(){const t=this.$router.options.routes.filter(t=>"Study"===t.name)[0].children;this.interviewsList=t},methods:{}},Qt=Zt,tn=(e("b1b7"),Object(c["a"])(Qt,Kt,$t,!1,null,"4525cc4a",null)),nn=tn.exports,en=function(){var t=this;t._self._c;return t._m(0)},rn=[function(){var t=this,n=t._self._c;return n("div",[n("section",[t._v(" html超文本标记语言，由一系列的元素（elements）组成；元素可以告诉浏览器如何展示内容； "),n("pre",[t._v("      文档类型声明（DOCTYPE）!DOCTYPE html ；\n      html 元素：文档的根元素，所有的内容都包含在这个元素内。\n      head 元素：包含文档的元数据，如字符集声明、页面标题和链接到 CSS 文件。\n      body 元素：包含可见的页面内容\n      标题和段落：h1 到 h6 定义标题，p 定义段落\n      链接：a 元素用于创建链接\n      图片：img 元素用于嵌入图片\n      列表：ul 表示无序列表，ol 表示有序列表，li 表示列表项。\n      表格：table 用于创建表格，tr 用于行，th 和 td 分别用于表头和单元格\n      "),n("a",{attrs:{href:"https://evelance.notion.site/Table-8dde6cdd0844459b96f2fc9ec7ba8793"}},[t._v("表格：table注意事项")]),t._v("\n      表单：form 用于创建表单，input 用于收集用户输入\n      ")])]),n("section",[t._v(" https://evelance.notion.site/56e3e25360914897ad0717fbd06a17d1 "),n("pre",[t._v("      ## 语义化的理解\n- 用正确的标签做正确的事情，结构清晰，可读性高，方便维护\nheader / main / aside / section / article / footer / canvas / video / audio\n- 利于 SEO（搜索引擎优化）\n\n## SEO\n一种搜索引擎的搜索规则，可利用它来提高网站在搜索结果中的排名\n前端 SEO 实践与注意点：\n- 实践：\n    - head 标签中：\n        - `title`：言简意赅，需要体现出页面的主要内容\n        - `description`：对页面内容的高度概括\n        - `keywords`：列举出网站重要关键词\n- 注意点：\n    - 重要内容不要 JS 输出，爬虫不会执行 JS 获取内容\n    - 非装饰性图片必须加 alt\n    - 提高网站访问速度\n    ")])]),n("section",[n("p",[t._v("Web Worker")]),t._v(" 在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。 web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面你的性能。并且通过 postMessage 将结果回传到主线程。 这样在进行复杂计算操作的时候，就不会阻塞主线程了。 如何创建 web worker: 1. 检测浏览器对于 web worker 的支持性 2. 创建 web worker 文件(js，回传函数等) 3. 创建 web worker 对象 https://github.com/mdn/dom-examples/tree/main/web-workers ")]),n("section",[t._v(" Canvas 和 SVG 有什么区别 绘制方式：js xml 分辨率影响: 逐像素，矢量图(独立于像素) 元素事件：不支持， 支持 场景：频繁重绘，数据量大；svg是dom操作，不适用频繁重绘 ")])])}],on={name:"HHHH",components:{},data(){return{}},mounted(){},methods:{}},an=on,sn=Object(c["a"])(an,en,rn,!1,null,null,null),cn=sn.exports,ln=function(){var t=this;t._self._c;return t._m(0)},hn=[function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("1.引入 CSS 的 4 种方式")]),n("div",[t._v('导入 @import "mystyle.css";')]),n("div",[t._v('外链 link rel="stylesheet" type="text/css" href="my.css" ;')]),n("div",[t._v('行内式 div style="border:1px red solid;";')]),n("div",[t._v('style标签 style type="text/css" div { margin: 0; } style')])]),n("section",[n("h3",[t._v("盒模型")]),n("p",[t._v(" Dom中对一个元素在占据布局空间的描述，从内到外：content，padding，border，margin ")]),n("pre",[t._v("box-sizing影响盒模型的计算方式：同样是设置的css宽高像素100px；\n标准的 content-box： 内容宽度（100px） 不包括 内边距 + 边框宽度\nIE的border-box：  内容宽度 100px（包括了内边距+边框）\n")])]),n("section",[n("h3",[t._v("display属性")]),n("pre",[t._v("    block，inline 和 inline-block：\n    - `inline`\n    - 不会独占一行；相邻的排同一行；一行排不下会换行\n    - 不可设置宽高\n    - `padding`、`margin` **水平**方向上设置**有效**，**垂直**方向上**无效**\n\n    - `inline-block`\n    - 和其他元素同一行（行内元素特点）\n    - 可以设置宽高（块级元素特点）\n    - `padding`、`margin` **设置有效**\n\n    - `block`\n    - 独占一行\n    - 可以设置宽高\n    - `padding`、`margin` 设置有效\n\n比较 opacity: 0、visibility: hidden、display: none 的区别\n结构：\ndisplay:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，\nvisibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击\nopacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击\n\n继承：\ndisplay: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。\nvisibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。\n\n性能：\ndisplay：none 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大\nvisibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容\nopacity: 0 ： 修改元素会造成重绘，性能消耗较少\n      ")])]),n("section",[n("h3",[t._v("css选择器")]),n("a",{attrs:{href:"https://evelance.notion.site/CSS-757cd0fa3932490bb5abd723b7726345",target:"_blank"}},[t._v("css选择器")]),n("p",[t._v("选择器匹配规则: 从右往左， why？")]),n("pre",[t._v('        **1. 从右向左匹配的步骤**\n假设有一个选择器 `div ul > li a.active`：\n\n1. **从最右边的选择器开始**，即 `.active`，查找所有带有 `class="active"` 的 `a` 元素。\n2. 然后**往左移动**到 `li a.active`，过滤掉不在 `li` 内部的 `a` 元素。\n3. 接着移动到 `ul > li a.active`，进一步过滤掉不在直接子元素 `li` 内部的 `a` 元素。\n4. 最后到 `div ul > li a.active`，过滤掉不在 `div` 内部的 `ul` 内部的 `li` 内部的 `a` 元素。\n\n**2. 优化原因**\n\n这种从右向左的匹配方式主要是为了优化选择器的性能：\n- **减少不必要的查找**：从右向左匹配能够立即定位具体的元素，从而避免从文档根部开始的全局搜索。\n假设选择器是从左到右匹配，会从文档根部开始搜索所有 `div`，然后查找每个 `div` 下的 `ul`，再查找 `ul` 下的 `li`，最后检查 `li` 下是否有符合条件的 `a`。\n  这可能导致大量无效的查找。\n- **降低复杂度**：CSS 引擎可以快速排除不符合条件的元素。\n例如，选择器 `.active` 可以迅速筛选出特定的 `a` 元素，大大减少需要进一步检查的元素数量。\n      ')])]),n("section",[n("h3",[t._v("CSS 优先级算法")]),n("pre",[t._v("    - 优先级：\n    - 同权重下: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）\n    - !important > id > class > tag\n    - !important 比 内联优先级高\n\n    - **同权重下**：\n    - 优先级就近原则，样式定义最近者为准\n    - 载入样式以最后载入的定位为准\n      ")])]),n("section",[n("h3",[t._v("BFC")]),n("pre",[t._v("        BFC块级格式化上下文 是 CSS 中页面的一块独立渲染区域，内部元素的渲染遵循特定规则，与区域外部的元素相互隔离。\n触发条件:\n- `html` 根元素（整个文档的根元素自动成为 BFC）。\n- 元素的 `float` 属性值不是 `none`（即设置了浮动 `left` 、 `right`）。\n- 元素的 `position` 属性值是 `absolute`（绝对定位）或 `fixed`（固定定位）。\n- 元素的 `display` 属性值是 `inline-block`、`table-cell`、`flex`、`table-caption`、`inline-flex` 等。\n- 元素的 `overflow` 属性值不是 `visible`（如 `auto`、`hidden`、`scroll`）。\n特点：\n1. 同一个 BFC 内部的盒子会按照正常文档流一个接一个地放置。\n2. BFC 内部的元素垂直方向的距离由`margin`决定，属于同一个 BFC 的两个相邻元素的`margin`会发生重叠。\n3. BFC 的区域不会与浮动盒子重叠。\n4. BFC 是一个隔离的独立容器，容器里面的子元素不会影响外面的元素，反之亦然。\n作用：\n清除浮动影响 和 margin重叠\n      ")])]),n("section",[n("h3",[t._v("CSS 单位: px, %, em, rem, vw/vh")]),n("pre",[t._v("- 使用 `px` ，结合 Media Query 进行阶梯式的适配\n- 使用 `%` ，按百分比自适应布局\n- `em`，相对单位，相对于父元素的字体大小\n- `rem`，也是相对单位，相对于根元素 `html`。使用`rem`，结合 `html` 元素的 `font-size` 来根据屏幕宽度适配\n- 使用 `vw`、`vh`，直接根据视口宽高适配。\n1. 在视觉稿要求固定尺寸的元素上使用 `px`。比如 `1px` 线，`4px` 的圆角边框。\n2. 在字号、（大多数）间距上使用 `rem`。\n3. 慎用 `em`。\n      ")])]),n("section",[n("h3",[t._v("css3新特性")]),n("pre",[t._v("        transition: CSS属性，花费时间，运动曲线(默认ease)，延迟时间(默认0)\n        animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），\n是否反向播放动画（默认normal），是否暂停动画（默认running）\n        transform：\ntransform: rotate(30deg);\ntransform: translate(30px, 30px);\ntransform: scale(.8);\ntransform: skew(10deg, 10deg);\ntransform-origin: left top; 左上（默认中心）【改变元素变形的原点】\n\nFlex 布局：\nflex 弹性盒布局模型的目的：提供一种更加高效的方式来对容器中的元素进行布局、对齐和分配空间\n主轴方向：水平排列（默认） | 水平反向排列 | 垂直排列 | 垂直反向排列\nflex-direction: row | row-reverse | column | column-reverse;\n\n换行：不换行（默认） | 换行 | 反向换行(第一行在最后面)\nflex-wrap: nowrap | wrap | wrap-reverse;\n\nflex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\nflex-flow: flex-direction || flex-wrap;\n\n主轴对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐\njustify-content: flex-start | flex-end | center | space-between | space-around;\n\n交叉轴对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 第一行文字的基线对齐\nalign-items: stretch | flex-start | flex-end | center | baseline;\n\n多根轴线对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐\nalign-content: stretch | flex-start | flex-end | center | space-between | space-around;\n\n- `flex` 默认设置是 `flex: 0 1 auto`\n- 意思是项目默认有剩余空间也不放大（0），但空间不足会缩小（1）\n\n      ")])]),n("section",[n("h3",[t._v("响应式设计")]),n("p",[t._v(" 一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 ")]),n("pre",[t._v("@media screen and (max-width: 990px) {\n    .container {\n        background: orange;\n    }\n}\n\n@media (max-width: 575px) {\n   .call-me {\n      .call-item:first-child {\n         border-right: 0 !important;\n         border-bottom: 1px solid #e6e6e6;\n      }\n   }\n}\n      ")])])])}],un={name:"css",components:{},data(){return{}},mounted(){},methods:{}},dn=un,pn=Object(c["a"])(dn,ln,hn,!1,null,"24e97c58",null),vn=pn.exports,fn=function(){var t=this;t._self._c;return t._m(0)},_n=[function(){var t=this,n=t._self._c;return n("div",[n("a",{attrs:{href:"https://github.com/Troland/how-javascript-works/tree/master"}},[t._v("how-javascript-works")]),n("h3",[t._v("=====语法======")]),n("pre",[t._v("1.数据类型\n# 基本类型\n- `undefined` 、 `null`\n- `string` 、 `boolean` 、 `number`\n- `symbol` （es6）、`bigint` （es10）\n# 复杂类型\n- `object`\n    - Array，Date，RegExp，Function\n    - 基本包装类型 Boolean，Number，String\n    - 单体内置对象 Global，Math\n- 值类型存储在栈(stack)中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n- 引用类型存储在堆(heap)中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；\n\n引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n- 栈(stack)：是栈内存的简称，栈是自动分配相对固定大小的内存空间，并由系统自动释放，栈数据结构先进后出的原则\n- 堆(heap)：是堆内存的简称，堆是动态分配内存，内存大小不固定，也不会自动释放，堆数据结构是一种无序的树状结构\n# 类型检测\ntypeof x =》 'undefined'\ninstanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\nauto instanceof Car =》 true/false\n\n使用 if(xx == null) 来判断变量 xx 是否为 undefined 和 null，更加简洁。\n（在目前最新的语法中 ?? 就是只针对 undefined 和 null 做判断处理，如 let a = xx ?? 123）\n\n# 进制装换\n十进制 → n进制\nfunction decimalToBaseN(decimalNumber, base) {\n    if (base 《= 2 || base > 36) {\n        throw new Error(\"Base must be between 2 and 36\");\n    }\n    return Number(decimalNumber).toString(base);\n}\nN进制 → 10进制\nfunction baseNToDecimal(baseNNumber, base) {\n    if (base 《 2 || base > 36) {\n        throw new Error(\"Base must be between 2 and 36\");\n    }\n    return parseInt(baseNNumber, base);\n}\n# 隐式转换\n[] + {};\n([]).toString() + ({}).toString() =》 \"\" + \"[object Object]\" =》 \"[object Object]\"\n{} + []; // 0\n\n# 函数\nfunction func(a, b, c) {\n  console.log(arguments.length); // 实参有 2 个：1 跟 2\n  console.log(func.length); // 形参有3个：a, b, c\n}\nfunc(1, 2);\n\n# 上下文\n## AO（activation object）活跃对象，函数上下文\nvar声明：变量提升到全局\n## GO（global object）全局上下文\n1. 寻找变量\n2. 寻找函数声明\n3. 执行\n\nif代码块中的 var 变量会提升，但函数声明并不会整体提升，而只会提升函数名到当前作用域的顶端\n\nfunction test() {\n\treturn a;\n  a = 1;\n  function a() {}\n  var a = 2;\n}\nconsole.log(test());\n// 答案: function a() {}\n\n# 作用域\n作用域就是`变量`与`函数`的可访问范围，由当前环境与上层环境的一系列变量对象组成\n1. 全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。\n2. 函数作用域：在固定的代码片段才能被访问\n3. 块级作用域：使用 `{}` 包裹的代码块，如 `if` 、 `for` 、 `while` 、 `try/catch`\n作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突\n作用域链\n访问一个变量，先在函数作用域内部取值，如果没有查到，就向上级作用域中查找，直到查到全局作用域为止，\n这样一个查找过程形成的链条叫做作用域链\n\n[[scope]]：\n- **函数创建时**，生成的一个 JS 内部的隐式属性\n- 函数存储【作用域链】的容器\n    - 作用域链：\n        - **AO - 函数的执行期上下文**\n        - **GO - 全局的执行期上下文**\n- 函数执行完成以后，AO 会被销毁，再执行会重新创建一个新的 AO\n- 全局执行的前一刻 GO -》 函数声明已经定义\n\n## **总结**\n1. 只要函数被定义，就生成作用域（scope）和相应的作用域链（scope chain），并把 GO 放进去\n2. 只要函数被执行的那一刻（准确的说应该是执行前的预编译阶段），就生成AO，然后把自身的AO放进作用域链，并自身排首位，把之前的作用域们（其他AO和GO）依次往下挪\n3. **函数执行完毕，销毁自身AO；此时自身作用域回归被定义时的状态**\n\n闭包就是能够读取其他函数内部变量的函数\n## **闭包的特性**\n- 函数内再**嵌套函数**\n- 内部函数可以**访问外层的参数和变量**\n- 参数和变量**不会被垃圾回收机制回收**\n\n当内部函数被返回到外部并保存时，一定会产生闭包。闭包会导致原来的作用域链不释放。过度的闭包可能会导致内存泄漏（因为常驻内存），或加载过慢。\nfunction fn1() {\n  var arr = new Array(9999999999999)\n  function fn2() {\n    console.log(arr)\n  }\n  return fn2\n}\nvar f = fn1()\nf() // 没有释放，arr就一直在内存中占着，导致内存泄漏\n// 记得释放\nf = null\n\n## **闭包的用途**\n- **保存**（缓存数据，延长作用域链）（onclick = 一个立即执行函数，这个立即执行函数返回一个函数，形成闭包）【形成一个不销毁的栈内存，把一些值保存起来，比如索引（**选项卡**）】\n    - 即：闭包中想要提供给外界调用访问的变量，相当于把一些值保存起来了\n- **保护**（避免全局污染）：**形成私有作用域**，保护里面私有变量不受外面干扰，不与别人冲突\n    - 希望函数内部的值不能被外部直接修改，但是可以通过return出去的方法让外部访问和间接修改\n        - **jquery**（利用闭包保护机制，自执行函数私有作用域,里边有个类叫jquery，通过window.$=window.jquery把它暴露给全局)\n    - 即：闭包中不希望外界访问的私有变量和参数，相当于保护私有变\n\n\n# 构造函数\n- 每次 new 出来的都是崭新出厂的全新对象，是互不相同的\n- new 之后 this 才存在，this 指向实例化的对象；否则指向GO =》window\n\nvar obj = new Object()；new 做了什么\n- **创建一个新对象**：\n    - 创建一个新的空对象，并将其作为函数的上下文（`this`）对象。\n- **设置原型链**：\n    - 将新对象的原型（`__proto__`）设置为构造函数的 `prototype` 属性。这样，新对象就可以访问构造函数原型上的属性和方法。\n- **执行构造函数**：\n    - 使用新对象作为 `this` 执行构造函数代码。构造函数中的代码可以对新对象进行初始化操作，例如添加属性和方法。\n- **返回新对象**：\n    - 如果构造函数显式地返回一个对象，那么 `new` 表达式会返回这个对象。\n    - 如果构造函数没有显式地返回对象，则 `new` 表达式会返回步骤 1 中创建的新对象。\n\nfunction selfNew(Obj, ...args) {\n  // 创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__（原型）\n  const newobj = Object.create(Obj.prototype)\n  // 使用新对象作为 this 执行构造函数\n  const result = Obj.apply(newobj, args);\n  // 如果构造函数显式返回了一个对象，则返回该对象，否则返回新创建的对象\n  return (result && typeof result === 'object') ? result : newobj;\n}\n\n## call/apply 更改 this 指向\nfunction test() {\n\tconsole.log(1);\n}\ntest(); //  test.call() 调用函数时，系统隐式的加了 .call\n\n原型 prototype\nprototype 是函数的属性，其值是个对象\n## **prototype 是构造函数中的，构造出的每个实例对象的公共祖先**\n## **所有被该构造函数构造出来的对象，都可以继承原型上的属性和方法**\nconstructor 指向构造函数本身\nHandphone.prototype.constructor =》Handphone\nconstructor 可以被修改； Handphone.prototype.constructor = XXX\n__proto__ 属性是实例化以后的结果， handphone1.__proto__  =》 Handphone.prototype\n\n沿着原型__proto__往上不断找属性的这条链条叫做原型链\n- 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果这个对象本身没有这个属性时，它就会去他的`__proto__隐式原型`上去找（即它的构造函数的 prototype）。\n- 如果还找不到，就去原型的原型（`即构造函数的prototype的__proto__`）上去找，....一直找到最顶层（`Object.prototype`）为止。\n- 如果还没有找到，则返回 undefined。\n\n对象构造函数继承\n// 定义基类构造函数\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n// 在 Person 的原型上定义方法\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n};\n\n// 定义子类构造函数\nfunction Student(name, age, major) {\n  Person.call(this, name, age); // 调用父类构造函数\n  this.major = major;\n}\n// 设置原型链\nStudent.prototype = Object.create(Person.prototype);\n\n// 修正 constructor 引用\nStudent.prototype.constructor = Student;\n\n// 在 Student 的原型上定义方法\nStudent.prototype.study = function() {\n  console.log(`${this.name} is studying ${this.major}.`);\n};\n\n链式操作 - return this\n\n# 对象属性遍历\nhasOwnProperty 返回自身非原型的属性\nfor...in 会把原型上的属性也遍历\nfor(var key in car) {\n  if(car.hasOwnProperty(key)) {\n\t\tconsole.log(key + ': ' + car[key])\n  }\n}\n判断属性是否在对象内 console.log('color' in car);in 不会排除对象原型上属性\n\n# 函数内部 this 指向\n- 普通函数 this 指向 window\n- 构造函数通过 new 调用 this 指向实例化对象\n\n闭包、箭头函数、setTimeout 中 this\nvar x = {\n  name: 'bw2',\n  getName1: function() {\n    console.log(this)\n  },\n  getName2: function() {\n    setTimeout(() =》 {\n      console.log(this)\n    },0)\n  },\n  getName31: () =》 {\n    console.log(this)\n  },\n  getName32: function() {\n    return function() {\n      console.log(this)\n    }\n  }\n}\n\n# 错误类型\nSyntaxError 语法错误\nReferenceError 引用错误\nRangeError 范围错误\nTypeError 类型错误\nURIError URI 错误\nEvalError eval 函数执行错误\nError 构造函数\nvar err = new Error('代码错误');\n\ntry 中的错误，不影响外部代码和 finally 中代码的执行\ntry {\n\tconsole.log('正常执行1');\n  console.log(a);\n  console.log('正常执行2');\n} catch(e) {\n\tconsole.log('e->', e);\n  console.log('e.name->', e.name);\n  console.log('e.message->', e.message);\n} finally {\n\tconsole.log('正常执行3');\n}\nconsole.log('正常执行4');\n\nthrow 手动抛错 throw '出错啦'\n\n# 垃圾回收\n- 找出**不再使用的变量**\n- **释放**其占用**内存**\n- **固定**的时间间隔**运行**\n\n## **标记清除 mark and sweep**\n- 标记进入环境\n- 离开环境时，排除全局变量和形成闭包的变量，然后清除\n\n## **引用计数 reference counting**\n- 循环引用时，无法清除变量可能引发内存溢出\n\n解除闭包内存\nfunction test1() {\n\tvar a = 1;\n  return function() {\n  \ta++;\n    console.log(a);\n  }\n}\nvar test = test1();\ntest();\ntest();\ntest();\ntest = null;\n")]),n("h3",[t._v("=====DOM======")]),n("pre",[t._v("文档对象模型（Document Object Model）\n用来**表示或操作** HTML 和 XML; 属于 **宿主对象**\nDOM 结构树\n判断dom元素类型\nObject.prototype.toString.call(document) // '[object HTMLDocument]'\nObject.prototype.toString.call(document.createElement('div')) // '[object HTMLDivElement]'\n获取元素 document\n获取父节点: Node.parentNode\n获取子节点: Node.childNodes, 不止包含元素节点;获取的是子代子节点而不是全部的后代子节点\n节点的增删改\ncreateElement\ncreateTextNode\nappendChild\ninsertBefore\nremoveChild\n\nDOM 对象 = 元素节点\n\n节点：\n元素节点、文本节点、属性节点、注释节点、document、DocumentFragment\n\nDOM对象\nvar div = document.getElementsByTagName('div')[0];\n\n-》 元素 -》 元素节点\nnodeName nodeValue nodeType attributes hasChildNodes\n\n元素 \t\t-》 \t\t构造函数实例化\t\t\t -》 \t\tdiv节点\ndiv\t\t\t\tnew HTMLDivElement()\t\t\tremoveChild(div)\n\t\t\t\t\t\t-》 div DOM对象\t\t\t\t\t\t删除了节点，但DOM对象还存在内存\n            \t\t存储在内存中\n\n p.remove(); 元素销毁，删除自身和自身所有子节点\n\n## **data-***\n- 设置自定义属性\n- HTML5内容\n- IE9以下没有\n### **dataset**\n- 管理自定义属性 console.log(p.dataset);\n\n# 元素视图的各个尺寸、滚动距离与偏移量\n- `offsetParent` —— 返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 `table`, `td`, `th`, `body` 元素。\n- `offsetLeft/offsetTop` —— 是相对于 `offsetParent` 的左上角边缘的坐标。\n- **`offsetWidth/offsetHeight` —— 元素的“外部” width/height，边框（border）尺寸计算在内。**\n\n- `clientLeft/clientTop` —— 从元素左上角外角到左上角内角的距离。\n对于从左到右显示内容的操作系统来说，它们始终是左侧/顶部 border 的宽度。\n而对于从右到左显示内容的操作系统来说，垂直滚动条在左边，所以 `clientLeft` 也包括滚动条的宽度。\n- **`clientWidth/clientHeight` —— 内容的 width/height，包括 padding，但不包括滚动条（scrollbar）。**\n\n- **`scrollWidth/scrollHeight` —— 内容的 width/height，就像 `clientWidth/clientHeight` 一样，但还包括元素的滚动出的不可见的部分。**\n- `scrollLeft/scrollTop` —— 从元素的左上角开始，滚动出元素的上半部分的 width/height。\n\n浏览器可视区域的尺寸（窗口的宽高）\n- `window.innerWidth`\n- `window.innerHeight`\n\n# 事件\n绑定事件：绑定事件的处理函数\n事件 + 事件的反馈 = 前端交互\n事件句柄：div.onclick = function() {}\n事件源：事件作用在谁身上，谁就是事件源\n\n事件流有三个阶段\n- 事件捕获阶段\n- 处于目标阶段 - 代码按先后顺序执行（新版chrome先捕获后冒泡）\n- 事件冒泡阶段\n\nJS 事件委托（事件代理）是一种利用事件冒泡机制来优化事件处理的技术。\n在 JS 的事件流中，事件会经历捕获阶段、目标阶段和冒泡阶段。\n当一个元素上的事件被触发时，该事件会从最具体的目标元素（即被点击的元素）开始向上冒泡，依次传递到它的父元素、祖父元素等，直到到达文档的根节点。\n事件委托就是利用这个冒泡机制，将事件处理程序绑定到目标元素的父元素或更外层的祖先元素上，当子元素上的事件触发时，会冒泡到外层的祖先元素，从而在外层元素的事件处理程序中进行处理\n- 减少内存占用和提高性能\n- 动态生成的子元素事件绑定\n\n事件对象\nevent.target 和 event.currentTarget 的区别\n- target\t             当前触发事件的元素\n- **currentTarget**\t   绑定事件处理函数的元素\n\n# **onmouseenter、onmouseleave**\n只绑定在当前元素本身，不存在冒泡行为\nmouseover，mouseout，mousemove\n当鼠标移入某元素时触发，移入和移出其子元素时也会触发。\n\n自定义事件 CustomEvent\n\nWeb Components 组件化\nshadowDOM\n通过Shadow DOM，可以创建具有特定结构和样式的元素，然后在页面上像使用普通元素一样使用这些自定义元素\n    ")]),n("h3",[t._v("=====ES6+======")]),n("pre",[t._v("# let，const\n不能在同一作用域中重复声明\n没有声明提升，声明之前不可用，会产生一个暂时性死区\n只在当前作用域下生效\nlet 本质上是就是为 js 增加了一个块级作用域\nconst 值不可被修改，不可重复声明，有块级作用域，const 存储引用类型值不保证不可被更改\n\n# 函数默认值会在()内形成一个单独的作用域\nfunction foo(x = 3) {\n  let x = 2;\n  console.log(x);\n}\nfoo();\n// Identifier 'x' has already been declared\n// 函数默认值可以等效为 let x = 3 ，由于此刻就声明了x，\n// 所以函数内部再次声明，报错\n\n# 解耦赋值：对象，数组\n\n# 箭头函数\n- **没有自身 this**，this 由外层作用域决定\n- **不能作为构造函数**使用，底层原理与普通函数不同\n- **无法**通过 apply、call、bind 来**显式改变箭头函数 this 指向**\n- **没有 arguments 对象**，用 rest 运算符替代\n- yield 命令不能生效，在 generator 函数中\n\n# 对象属性描述符\ndefineProperty\nvar obj = {};\nObject.defineProperty(obj, 'a', {\n\tvalue: 2,\n  configurable: true,\n  writable: true,\n  enumerable: true\n});\ngetter/setter\nobj.a; //属性获取 [[Get]] 默认操作\nobj.a = 3; // 赋值操作[[Put]]\nget, set 应该成对出现\nvar obj = {\n\tget a() {\n  \treturn this._a; // 返回私有变量_a\n  },\n  set a(val) {\n  \tthis._a = val * 2;\n  }\n}\n\n# Object.assign\n- 浅拷贝\nvar clone = Object.create(\n  Object.getPrototypeOf(obj), \n  Object.getOwnPropertyDescriptors(obj)\n)\nassign 拷贝是无法拿到 set 方法的\n同名属性替换\nvar tar = {a: {b: 1, c: 2}}\nvar source = {a: {b: 'hhhh'}}\nconsole.log(Object.assign(tar, source)) // {a: {b: 'hhhh'}}\n\n# **super**\n- 指向的是对象的原型对象\n- 对象的简写的方法上才能使用\n\n# Symbol\n应用场景1：使用 Symbol 来作为对象属性名\nconst gender = Symbol('gender')\nconst obj = {\n  name: 'Sunshine_Lin',\n  [gender]: '男'\n}\nSymbol作为属性的属性不会被枚举出来，这也是 JSON.stringfy(obj) 时，Symbol 属性会被排除在外的原因\n使用 Symbol 来替代常量\n使用 Symbol 定义类的私有属性\nclass Login {\n  constructor(username, password) {\n    const PASSWORD = Symbol()\n    this.username = username\n    this[PASSWORD] = password\n  }\n  checkPassword(pwd) { return this[PASSWORD] === pwd }\n}\nconst login = new Login('123456', 'hahah')\nconsole.log(login.PASSWORD) // 报错\n\n# iterator 迭代器\n对数据结构的读取的一种方式，有序的，连续的，基于拉取的一种消耗数据的组织方式\n- [] 数据\n- arguments、nodeList、Map、Set、WeakMap、WeakSet 类数组\n- TypeArray 二进制数据的缓存区，有点像数组\n\nfunction myIterator(arr) {\n  let index = 0;\n  return {\n    next() {\n      return index 《 arr.length \n          ? { value: arr[index++], done: false }\n          : { value: undefined, done: true }\n    }\n  }\n}\nfor...of 遍历含有iterator的对象\nfor await of 批量异步队列 同步执行\n\nfunction fn (time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`${time}毫秒后我成功啦！！！`)\n    }, time)\n  })\n}\nasync function asyncFn () {\n  const taskArr = [fn(3000), fn(1000), fn(1000), fn(2000), fn(500)]\n  for await (let x of taskArr) {\n    console.log(x)\n  }\n}\n# Array.of()\n- 代替 new Array()\nconsole.log(Array.of());\nconsole.log(Array.of(1, 2));\nArray.from(arrayLike 类数组)\n\n# ES Module\n- `export { add, minus }` 导出一个模块\n- `import { add, minus } from 'xxx'`\n\n- `export default {}` 导出一个对象\n- `import obj from 'xxx'`\n\n# 运算符\n?. 取一个可能不存在的值\nobj?.dog?.name // undefined\n\n?? undefined 和 null 才算假值\n0 || 'Lance' // 假值取右边 Lance\n\n或等于(||=)   a ||= b 等同于 a || (a = b);\n且等于(&&=)   a &&= b 等同于 a && (a = b);\n\nPromise.any： 当有成功的时候，返回最快那个成功\n- 接收一个 Promise 数组，数组中如有非 Promise 项，则此项当做成功\n- **如果有一个 Promise 成功**，则返回这个成功结果\n- 如果所有 Promise 都失败，则报错\nPromise.any([fn(2000, true), fn(3000), fn(1000, true)]).then(res => {\n  console.log(res) // 1秒后 输出  1000毫秒后我成功啦\n}, err => {\n  console.log(err)\n})\n\n# Set\n- 成员唯一（基本类型去重，复杂类型不去重）\n- 类数组结构\n# Map\n键名可以为任何值（包括函数、对象或任何原始值）\n会把复杂类型 toString 后设置为键名\nvar m = new Map([['name', 'zhangsan'], ['age', 10]]);\n\n- Set 是**有序列表**，类似于数组，但是没有重复值\n- Map 是存储许多键值对的**有序列表**，**key 和 value 支持所有数据类型**\n- 都是有序列表\n- set 值不重复；map 键不重复\nMap 与 Object 区别\n- Object 的键只能是 字符串 or Symbol；Map 可以是任意类型\n- Map 可以通过 size 获取元素个数，Object 得遍历\n- Map 是有序的；Object 是无序的\n- **Map 可迭代**；Object 只能遍历，或通过 Object.entries/values/keys 迭代\n\nWeakMap、WeakSet\n- 没有迭代接口\n- **成员只能是对象**\n\n# Proxy\n- `Object.defineProperty(obj, prop, descriptor)` 是直接处理 obj，然后当操作 obj 时，会在 set、get 方法中进行拦截\n    - **对 obj 本身操作**\n    - 给 obj 上新增没有的属性\n\n- Proxy(target, handler) 是通过处理 obj 以后，是**返回了一个代理对象**，你是通过操作这个代理对象，来对数据做操作的\n    - 创建一个 obj 的代理，中间隔了一层交流\n    - 相比 defineProperty 少了个 prop 参数，因为是对已有的 obj 操作、处理\n\n- defineProperty 给对象增加属性用\n- proxy 代理对象，通过重写 handler 对象，间接达到修改 target 的目的\n\nlet target = {\n  a: 1,\n  b: 2\n}\nlet proxy = new Proxy(target, {\n  get(target, prop) {\n    console.log('This is property value ' + target[prop]);\n    return target[prop];\n  },\n  set(target, prop, value) {\n    console.log(1111)\n    target[prop] = value;\n  }\n});\n\nconsole.log(\"proxy.a\", proxy.a); // 走了代理 This is ...\nconsole.log(\"target.a\", target.a); // 直接访问，没走代理。没显示 This is ...\nproxy.b = 3;\nconsole.log(\"target.b\", target.b); // 3\nconsole.log(\"proxy.b\", proxy.b); // 3\nconsole.log(proxy); // Proxy {a: 1, b: 2}\n\n- Object.defineProperty 没法直接处理数组\n- Proxy 可以\n\nlet proxy = new Proxy(target, {\n  get(target, prop) {\n    return 'GET: ' + prop + ' = ' + target[prop];\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    console.log('SET: ' + prop + ' = ' + value);\n  },\n  has(target, prop) {\n    return Reflect.has(target, prop);\n  },\n  deleteProperty(target, prop) {\n  \tdelete target[prop];\n    console.log(1);\n  }\n});\n\nfunction deepClone(org, tar) {\n    let target = tar || {},\n        toStr = Object.prototype.toString,\n        arrType = '[object Array]';\n\n    for (var key in org) {\n      if (org.hasOwnProperty(key)) {\n        let value = org[key];\n        if (typeof value === 'object' && value !== null) {\n          if (toStr.call(value) === arrType) {\n            target[key] = [];\n          } else {\n            target[key] = {};\n          }\n          deepClone(value, target[key]);\n        } else {\n          target[key] = value;\n        }\n      }\n    }\n    return target;\n  }\n}\n\n# class\n### **static**\n- 可以修饰属性和方法\n- 不会被继承，只能通过类来调用\n- 只在 Class 类中生效\nPerson.say()\n\nclass A {}\nclass B extends A {\n  constructor() {\n    super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。\n  }\n}\n当做对象使用\nclass A {\n  c() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.c()); // 2\n  }\n}\nlet b = new B();\n上面代码中，子类 B 当中的 `super.c()`，就是将 `super` 当作一个对象使用。\n这时，`super` 在普通方法之中，指向 `A.prototype`，所以 `super.c()` 就相当于 `A.prototype.c()`。\n\n**通过 super 调用父类的方法时，super 会绑定子类的 this。**\nclass A {\n  constructor {\n    this.x = 1;\n  }\n  s() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.s();\n  }\n}\n\nlet b = new B();\nb.m(); // 2\n\n# 模块化\n为什么用到 IIFE\n立即执行函数执行完后作用域销毁，自身的 AO，GO 都销毁，\n只剩下 return 返回值和返回值持有的函数中的变量的引用（e.g. 闭包），这样做到了变量的私有化\n\n缺点\n- 相互依赖关系一旦复杂，不好捋顺\n- 模块一旦变多，又出现全局变量可能覆盖的问题\n    - 进一步解决：namespace 命名空间\n\n## **模块化发展**\n无模块化 \n→ CommonJS规范（nodejs） : exports = module.exports\n→ AMD规范 \n→ CMD规范 \n→ ES6模块化\n\nCommonJs和ES6区别\nCommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用\n\n运行时加载(全量): CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n编译时加载(按需): ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”\n\nimport\n- 静态导入\n    - 初始化加载\n        - `import xxx from './xxx';` ，`script` 依赖 `type=\"module\"`\n- 动态导入 import() 不是在调用方法，只是动态导入的一种规定的语法\n    - 按需加载\n        - `import('./xxx');` 不依赖 `type=\"module\"`\n            - `import('./xxx').then(module => console.log(module));`\n")]),n("h1",[t._v("专题系列")]),n("pre",[t._v("# WeakMap使用场景\nconst oBtn1 = document.querySelector('#btn1');\nconst oBtn2 = document.querySelector('#btn2');\n\nconst oBtnMap = new WeakMap();\noBtnMap.set(oBtn1, handleBtn1Click);\noBtnMap.set(oBtn2, handleBtn2Click);\n\noBtn1.addEventListener('click', oBtnMap.get(oBtn1), false);\noBtn2.addEventListener('click', oBtnMap.get(oBtn2), false);\n\noBtn1.remove();\noBtn2.remove();\n\n# this指向\n- this 是 JavaScript 的关键字\n- 是 当前环境 执行期上下文对象 的 一个属性\n- this 明确指向的时机：**执行期**\n- this 在不同环境、不同作用域下，表现不同\n\n    ")])])}],gn={name:"JS",components:{},data(){return{}},mounted(){},methods:{}},bn=gn,mn=Object(c["a"])(bn,fn,_n,!1,null,"8bc732ae",null),An=mn.exports,xn=function(){var t=this;t._self._c;return t._m(0)},Mn=[function(){var t=this,n=t._self._c;return n("section",[n("div",[n("h4",[t._v("浏览器事件循环")]),n("pre",[t._v("## 进程\n- CPU正在进行的一个任务的运行过程的调度单位\n- 浏览器是一个多进程的应用程序\n- 进程是计算机调度的基本单位\n- 进程包含线程，线程在进程中运行\n    - **没有进程就没有线程**\n    - **为什么分进程：进程之间耦合低，chrome一个tab就是一个单独进程，单个tab卡死不会影响其他tab页面的工作**\n\n- 任务管理器（mac活动监视器）查看chrome的进程情况\n\n- 每一个tab都会开启一个进程\n- 浏览器有一个主进程（用户界面：指的是整个浏览器的界面，地址栏、标签栏、页面内容...）\n- 每一个 tab 各自有独立的：\n    - 渲染进程（浏览器内核Renderer，渲染引擎）\n    - 网络进程（网络请求）\n    - GPU进程（动画与3D绘制 e.g. css3动画开启GPU加速就用的这个进程）\n    - 插件进程（vue devtool 等 chrome 插件）\n- 每个进程里包含多个线程运行\n\n### 比如渲染进程\n- 包含\n    1. GPU 渲染线程（负责渲染页面）\n      - 解析 HTML，CSS\n      - 构建 DOM、CSSOM / Render 树\n      - 初始布局与绘制\n      - 回流与重绘    \n    2. JS 引擎线程\n      - 一个主线程与多个辅助线程\n      - 一个浏览器只有一个 JS 引擎（浏览器只有**一个JS主线程**，也就是所谓的JS是单线程的）\n      - 解析JS脚本\n      - 运行JS代码\n- 运行互斥\n    - GPU渲染与JS引擎线程，**运行互斥** why? 因为不能一边渲染内容，一边JS在修改DOM\n    - JS执行的时候，渲染线程挂起\n    - JS引擎任务空闲，GPU渲染更新\n\n### 事件触发线程：事件循环（Event Loop）线程（事件环是个单独线程管理的）\n- 事件线程：用户交互事件、setTimeout、Ajax\n#### 宏任务、微任务\n- 宏任务\n    - 宿主提供的异步方法和任务\n        - script 的执行（JS整体代码，比如 `script...script` 这段脚本整体，也是个宏任务）\n        - setTimeout、setImmediate、setInterval\n        - UI渲染、UI交互（Ajax、mouseover, click 各种事件回调）、I/O\n- 微任务\n    - 语言标准（ECMA262）提供的API\n        - Promise、process.nextTick（NodeJS）、MutationObserver\n\n循环逻辑：\n1. 先在JS引擎线程执行栈中**执行同步代码**（遇到宏任务，会执行它们，并把宏任务们的回调放进宏任务队列）\n2. 然后**清空所有微任务**\n3. **执行GUI渲染逻辑**\n4. 取一个**宏任务回调**出来执行（先进先出）【其实处理的都是宏任务的回调函数 e.g. ajax回调，setTimeout回调，例如代码执行时，遇到 setTimeout ，其实是**立马执行**了 setTimeout，但把**回调放进了宏任务队列**】\n5. 再执行同步代码\n6. 清空微任务\n7. ... 循环\n\n事件监听\n- 如果 JS 主动触发 click 回调，则相当于把回调同步的依次执行； btn.ckick()\n- 如果用户点击按钮触发 click 回调，则先把所有回调依次放进宏任务队列，再每次取出一个cb出来执行\n\n任务优先级\n1. Promise（微任务）\n2. MutationObserver（微任务）\n3. setImmediate（宏任务）\n4. setTimeout（宏任务）\n\n## requestAnimationFrame、setInterval\n- requestAnimationFrame 请求动画帧\n    - 告诉浏览器，在**下次重绘之前调用**回调函数更新动画\n        - 第一次主动触发，回调函数中还得递归调用\n    - 回调函数接受到一个参数 timestamp 时间戳\n- setInterval 间隔 xx ms 执行回调\n\n## MutationObserver、nextTick\n- MutationObserver\n    - **监听DOM改变，然后执行回调（回调是个微任务）**\n        - **Vue.$nextTick 就是利用这一点，在页面更新后，执行一些事情**\n    - mutation：变化 的意思\n    - `const observer = new MutationObserver(回调)`\n    - `observer.observe()`\n    - 回调中可以拿到两个参数：\n        - mutationList\t变化列表\n            - mutation.target 被改变的目标节点\n            - mutation.addedNodes 目标节点下新增的节点\n        - observer\t观察者实例对象\n- process.nextTick\n    - 作为微任务，是优先于 promise.then 执行的\n\n## 为何说 JS 是单线程的？\nJavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。\n比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成这门语言的核心特征，将来也不会改变。\n注意：所谓单线程，是指在**JS引擎中负责解释和执行JavaScript代码**的线程只有一个。\n\n### **简单性**\n- 单线程模型使得JavaScript的编写和调试变得相对简单。开发者不需要处理多线程编程中的复杂问题，如竞争条件、死锁和线程同步等。\n### 与DOM的交互\nJavaScript在浏览器中的主要任务之一是与DOM进行交互。如果允许多个线程同时操作DOM，可能会导致不可预测的行为和数据不一致的问题。单线程保证了DOM操作的原子性和一致性。\n### 单线程的实现机制\n虽然JavaScript是单线程的，但通过异步编程模型和事件循环机制，它能够处理并发任务。这种机制包括以下部分：\n\n1. **调用栈（Call Stack）**：\n    - 调用栈是一个数据结构，用于追踪当前执行的代码位置。当一个函数被调用时，它会被压入栈顶，当函数执行完毕时，它会从栈顶弹出。\n2. **消息队列（Message Queue）**：\n    - 消息队列是一个任务队列，存储着待处理的异步任务和回调函数。当调用栈为空时，事件循环会从消息队列中取出第一个任务并执行。\n3. **事件循环（Event Loop）**：\n    - 事件循环是一个无限循环，它不断地检查调用栈是否为空。如果为空，它会从消息队列中取出一个任务并将其压入调用栈执行。这个过程持续进行，从而实现异步任务的处理。\n4. **总结**\n    - **单线程：指JavaScript在任何时刻只有一个主线程在执行代码。**\n    - **事件循环**：通过事件循环机制，JavaScript能够处理异步任务，实现非阻塞的并发执行。\n    - **简单性和安全性**：单线程模型简化了开发，并避免了多线程编程中的复杂问题，特别是在DOM操作方面。\n")])]),n("div",[n("h4",[t._v("浏览器渲染进程")]),n("pre",[t._v("- GPU 渲染线程（渲染页面）\n    - 解析 HTML、CSS 构建 DOM、CSSOM（渲染树）\n    - 初始布局与绘制\n    - 回流与重绘\n- JS 引擎线程\n    - 一个主线程与多个辅助线程（Web Workers、Service Workers）\n    - 一个浏览器只有一个JS引擎（浏览器只有一个JS主线程，也就是所谓的JS是单线程的）\n    - 解析JS脚本，运行JS代码\n      ")])]),n("div",[n("pre",[t._v("css放在 head 中的好处：\n- **提高加载性能**：在页面内容渲染之前应用样式，减少页面重绘和重排。\n- **改善用户体验**：避免用户在页面加载时看到未样式化的内容，防止“闪烁”效果。   \n\n为何要将 JS 放在 HTML 底部\n1. S 放在底部可以保证让**浏览器优先渲染完现有的 HTML 内容**，让用户先看到内容，体验好。\n2. 另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。**JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。**\n3. **渲染过程中，如果遇到`script`就停止渲染**，执行 JS 代码。因为**浏览器渲染和 JS 执行共用一个线程**，**而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突**。待`script`内容执行完之后，浏览器继续渲染。\n    ")])]),n("pre",[t._v('JS 延迟加载的方法有哪些\n1. async：给script标签加async属性，则加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）\n2. defer：给script标签加defer属性，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成\n3. 动态创建script标签：等到DOMContentLoaded 事件触发时，生成一个script标签，渲染到页面上上\n4. setTimeout 定时器延迟代码执行\n\n- 懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数\n- 预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映\nimg.src = imgSrc;\nimg.onload = function() { // 图片加载完后再添加到页面中去\n    oDiv.appendChild(img);\n}\n\n浏览器多标签页之间的通信\n1. websocket\n    1. 全双工（full-duplex）通信自然可以实现多个标签页之间的通信。\n2. setInterval + cookie 存值\n    1. 在页面 A 设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。\n3. **使用 localStorage**\n    1. localStorage 是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信（ps：sessionStorage 是会话级的存储空间，每个标签页都是单独的）。 直接在 window 对象上添加监听即可：\nwindow.addEventListener("storage", (e) =》 console.log(e))\n    ')])])}],On={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Tn=On,wn=Object(c["a"])(Tn,xn,Mn,!1,null,"785a7e8c",null),yn=wn.exports,Sn=function(){var t=this;t._self._c;return t._m(0)},En=[function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("浏览器请求网页的过程")]),n("p",[t._v(" 具体定位某个资源的位置的时候叫：URL（统一资源定位符）（Uniform Resource Locator） ")]),n("img",{attrs:{width:"600px",src:e("97e5"),alt:""}}),n("img",{attrs:{width:"600px",src:"https://evelance.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4af8c5f0-a397-4979-b87c-d983938af4e9%2FUntitled.png?table=block&id=befa0cb0-40e2-43ab-bac3-660dd542ad07&spaceId=c9e7ae34-64f6-4cc4-9c74-4ce3b1d1ee92&width=1540&userId=&cache=v2\n"}}),n("pre",[t._v("# DNS：Domain Name Server 域名服务器\n- 作用：转换 域名与对应ip 的服务器，保存了一张它们的对应的表\n客户端询问 DNS本地服务器 这个域名的 IP =》根服务器 =》 .com服务器 =》xxx.com域服务器\n\n# IP：PORT\n- IPv4：4组，十进制\n- IPv6：8组，十六进制\n- 形式：192.168.0.1（长度32位（4个字节），十进制表示） （IPv4）\n\n# TCP\n- TCP: Transmission Control Protocol 传输控制协议\n- 特点：面向连接（收发数据前，必须建立可靠的连接）\n- 建立连接基础：三次握手\n- 应用场景：数据必须准确无误的收发\n    - HTTP请求、FTP文件传输、邮件收发\n- 优点：速度慢、稳定、重传机制、拥塞控制机制、断开连接\n- 缺点：效率低、占用资源、容易被攻击（三次握手 → DOS、 DDOS攻击）\n\n- TCP/IP协议组：提供点对点的连接机制，制定了数据封装、定址、传输、路由、数据接收的标准。\n\n- 只要是传数据，不管收发，都得建立**可靠的连接**\n\n## TCP 和 UDP 的区别\n1. TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接。\n2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 尽最大努力交付，即不保证可靠交付。 并且因为 TCP 可靠，面向连接，不会丢失数据因此适合大数据量的交换。\n3. TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。\n4. TCP只能是 1 对 1 的，UDP 支持 1 对 1, 1 对多。\n5. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。\n6. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。\n\n## **HTTP 和 HTTPS 区别**\n\n1. HTTP 是不安全的（监听和中间人攻击等手段，获取网站账户信息和敏感信息）\n    1. HTTPS 可防止被攻击\n2. HTTP 协议的传输内容都是明文，直接在 TCP 连接上运行，客户端和服务器都无法验证对方身份\n3. HTTPS 协议的传输内容都被 SSL/TLS 加密，且运行在 SSL/TLS 上， SSL/TLS 运行在 TCP 连接上，所以数据传输是安全的\n\n### GET/POST 区别\n\n1. POST**更安全**\n    - 不作为url一部分，不会被缓存，不在浏览器记录中，不保存在服务器日志中\n2. POST能发送**更大数据**\n3. POST能发送**更多数据类型**，而GET只能是ASCII码字符\n4. POST比GET**慢**\n    1. 过程慢\n    2. get能进行数据缓存，post不行（e.g. 例如下载图片，get的能缓存）\n    3. post不能进行管道化传输 （一旦传输过程中出现断开，需要重新开始一次队列任务）\n\n# 浏览器缓存\n## Cache-Control字段\n- no-cache 让浏览器忽略缓存，而不是让浏览器不缓存。（浏览器依旧缓存）\n    - 可以在客户端存储资源，**每次都必须去服务端做新鲜度校验**，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的**协商缓存**。\n- no-store 这个才是不让浏览器缓存\n- max-age 从请求开始算，到过期时间之间的秒数\n- public 谁都能缓存，代理服务器也行\n- private 代理服务器不能缓存\n\n## Expires字段\nExpires: Thu, 10 Nov 2017 08:45:11 GMT 在未过期之前不需要再次请求\n\n## 浏览器缓存策略：强缓存 与 协商缓存\n- expires 或 cache-control 没过期，走强制缓存\n- if-none-match 和 if-modified-since 与 ETag 和 last-modified 匹配，走协商缓存 304\n\n## 关闭tcp\n为什么挥手需要四次？\n- 关闭连接时，客户端向服务端发送 `FIN` 时，**仅仅表示客户端不再发送数据**了**但是还能接收**数据。\n- 服务器收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文（**告知客户端“我知道你想断开连接的请求了”。这样客户端便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。**），\n而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。\n客户端收到关闭通知，告诉服务端我关了\n\n服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，从而比三次握手导致多了一次。\n\n## 同源策略\nAccess-Control-Allow-Origin\n目的：\n- 减少服务器压力\n- 加强数据安全\n规避同源策略\n- 网页图片链接可以不同源\n- 加载 cdn link 可以不同源\n\n      ")])]),n("section",[n("h3",[t._v("AJAX")]),n("pre",[t._v("# GET\nvar xhr;\n\n// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器\nif (window.XMLHttpRequest) { // 兼容性\n  xhr = new XMLHttpRequest();\n} else {\n  xhr = new ActiveXObject('Microsoft.XMLHTTP');\n}\n\n// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址\nxhr.open('GET', 'https://api.publicapis.org/entries', true);\n\n// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求\nxhr.send();\n\nconsole.log(xhr.readyState); // 0 1 在发送前和发送后\n\n// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作\nxhr.onreadystatechange = function() {\n  console.log(xhr.readyState); // 2 3 4 在 onreadystatechange 中\n  // 通过 xhr 的 readyState 判断此次请求的响应是否接收完成\n  // 4代表done\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    // 通过 xhr 的 responseText 获取到响应的响应体\n    console.log(JSON.parse(xhr.responseText));\n  }\n}\n# POST\nvar xhr;\n\nif (window.XMLHttpRequest) { // 兼容性\n  xhr = new XMLHttpRequest();\n} else {\n  xhr = new ActiveXObject('Microsoft.XMLHTTP');\n}\n\nxhr.open('POST', 'https://api.publicapis.org/entries', true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n// post请求要写 👆(setRequestHeader写open和send之间) \n// post参数是字符串形式 👇🏻\nxhr.send('status=1&flag=1');\n\nconsole.log(xhr.readyState); // 0 1 在发送前和发送后\n\nxhr.onreadystatechange = function() {\n  console.log(xhr.readyState); // 2 3 4 在 onreadystatechange 中\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    console.log(JSON.parse(xhr.responseText));\n  }\n}\n\n# 6 种跨域获取数据\n1.代理服务器\n同源策略只针对浏览器（客户端），服务器之间没有跨域限制。客户端先向同源的服务器发送请求，同源服务器再向不同源的服务器请求数据，最后同源服务器将获取到的数据返回给客户端。\n    const http = require('http');\n    const url = require('url');\n\n    // 创建代理服务器\n    const proxyServer = http.createServer((req, res) => {\n        // 解析目标服务器的 URL\n        const targetUrl = 'http://target-domain.com' + req.url;\n        const options = {\n            hostname: url.parse(targetUrl).hostname,\n            port: 80,\n            path: url.parse(targetUrl).path,\n            method: req.method,\n            headers: req.headers\n        };\n\n        // 向目标服务器发送请求\n        const proxyReq = http.request(options, (proxyRes) => {\n            // 将目标服务器的响应返回给客户端\n            res.writeHead(proxyRes.statusCode, proxyRes.headers);\n            proxyRes.pipe(res);\n        });\n\n        req.pipe(proxyReq);\n    });\n\n    proxyServer.listen(3000);\n\n## 2.CORS 跨域\n    const http = require('http');\n    const url = require('url');\n\n    http.createServer((req, res) =》 {\n        const origin = req.headers.origin;\n        // 允许指定源访问\n        res.setHeader('Access-Control-Allow-Origin', 'http://allowed-domain.com');\n        // 允许的请求方法\n        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n        // 允许的请求头\n        res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\n        const data = { response: 'Data from server' };\n        res.end(JSON.stringify(data));\n    }).listen(8081);\n\n## iframe跨域\n\n## jsonp不支持POST请求，只支持GET\nscript src=\"http://example.com/api?callback=myCallback\" /script\n      ")])]),n("section",[n("h3",[t._v("专题系统")]),n("pre",[t._v('# **为什么需要加密？**\n因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。\n劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。\n所以我们才需要对信息进行加密。\n\n最容易理解的就是对称加密\n简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多\n如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。\n\n非对称加密\n简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。\n\n数字签名 CA证书\n\n# http2 与 http1.1 区别\n- HTTP/1.1有两个主要的缺点：安全不足和性能不高。\n- HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；\n- QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。\n\n# 前端网络储存\ncookie与session\n\n### 使用方式\ncooki机制：\n\n- 生命周期\n    - 默认情况下，cookie**保存在内存**中，浏览器关闭就没了\n    - **设置过期**时间后，cookie**保存在硬盘**上，关闭浏览器仍然存在，直到过期时间结束才消失。\n- 数据类型\n    - cookie以**文本**形式保存在客户端，每次请求时都带上它。\n\nsession机制：\n\n- 每次请求，服务器会检查是否有sessionid\n    - 有，服务器根据id返回对应session对象\n    - 无，服务器创建新的session对象，并把sessionid在本次响应中返回给客户端。\n- 通常使用cookie方式存储sessionid到客户端\n    - **用户禁用cookie时，如何传递sessionid**\n    - 服务端渲染：服务端可以使用URL重写，就是把session_id附带在每个网址后面\n\n- 前后端分离：\n    - 后端把 sessionid 返回给前端\n    - 前端判断浏览器是否禁用cookie `navigator.cookieEnabled` 如果禁用把 sessionid 存进 `localStorage` ，登录后传递 cookie\n\n### 存储方式\n\n- cookie\n    - 只能保存**字符串类型**，以文本的方式\n    - 根据同源策略，cookie 是区分端口的，但是浏览器实现来说，“cookie 区分域，而不区分端口，也就是说，同一个 ip 下的多个端口下的 cookie 是共享的！\n- session\n    - 能支持**任何类型**的对象\n\n### 存储大小\n\n- cookie单个不超过**4kb**\n- session没限制\n\n### 安全性\n\n- cookie（不安全）：Cookie欺骗，Cookie截获；\n- session（相对安全）的原因：\n    - sessionID存在cookie中，首先得攻破cookie\n    - sessionID得有人登录，或启动session_start才会有，所以攻破cookie也不一定能得到sessionID\n    - 第二次启动session_start后，前一次的sessionID就失效，session过期后，sessionID也随之失效\n    - sessionID是加密的\n\n# localStorage 和 sessionStorage 区别\n### 生命周期\n\n- sessionStorage：\n    - 有“浏览器窗口”的概念，在同源的窗口中始终存在。只要这个浏览器**标签或窗口没有关闭**，**刷新或进入同源另一个页面(不是同源也行)，数据依然存在**。\n    但是sessionStorage在关闭了浏览器窗口后就会被销毁。\n    同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。（隔离性）\n- localStorage：\n    - **生命周期永久**，除非主动删除**（js删除，清除浏览器缓存）**\n\n### 存储大小\n- 一般都是：5MB\n\n### 存储位置\n- 都保存在客户端，不与服务器进行交互通信\n\n### 存储类型\n- 只能存储**字符串类型**，对于复杂的对象可以使用ECMAScript提供的**JSON对象的stringify和parse**来处理\n\n### 使用场景\n- localStorage：购物车\n- sessionStorage：**编辑页刷新页面**，写的内容不丢失。\n\n### web storage 和 cookie 的区别\n**作用不同**：web storage是用于**本地大容量存储**数据(存储量5MB);而cookie是用于**存用户登录状态**；\n**使用方式**：web storage有setItem、getItem、removeItem、clear等方法，cookie需要我们自己来封装setCookie、getCookie、removeCookie。\n\n## 前端请求axios\n- 默认 headers 的 `Content-Type` ：\n    - get: 无\n    - put、post、patch 都为 `application/json`\n- data、params\n    - get 请求用：`params`\n    - post 请求用：`data`\n- post 请求常见的数据格式（content-type）\n    1. `Content-Type: application/json` ： 请求体中的数据会以 json 字符串的形式发送到后端\n        1. 后端得配置 `Access-Control-Allow-Headers`\n    2. `Content-Type: application/x-www-form-urlencoded`：请求体中的数据会以普通表单形式（键值对）发送到后端 username=user1&password=pass123；\n    3. `Content-Type: multipart/form-data`： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件\n      ')])])])}],Rn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Dn=Rn,Vn=Object(c["a"])(Dn,Sn,En,!1,null,"1cdd8970",null),In=Vn.exports,Nn=function(){var t=this,n=t._self._c;return n("div",[t._v("t")])},Pn=[],Cn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Ln=Cn,jn=Object(c["a"])(Ln,Nn,Pn,!1,null,"027bc347",null),Bn=jn.exports,Un=function(){var t=this;t._self._c;return t._m(0)},Fn=[function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h4",[t._v("Virtual DOM")]),n("pre",[t._v("Virtual DOM 的概念有很多解释，分别是：一个对象，两个前提，三个步骤\n一个对象 指的是 Virtual DOM 是一个基本的 JavaScript 对象，也是整个 Virtual DOM 树的基本\n两个前提 分别是:\n直接操作 DOM 的低效和 JavaScript 的高效相对比，为 Virtual DOM 的产生提供了大前提\n三个步骤 指的是 Virtual DOM 的三个重要步骤\n- 生成 Virtual DOM 树\n- 对比两棵树的差异\n- 更新视图。\n\n# 虚拟 DOM 更新 + diff 算法\n1.生成 Virtual DOM 树\n抽象出一个 DOM 节点却只需要三部分：节点类型，节点属性、子节点; 给节点实现渲染方法，就可以实现虚拟节点到真实 DOM 的转化。\n\n2.对比两棵树的差异（diff）\n只比较同级的节点\n新旧两棵树进行一次深度优先的遍历，每个节点都会有一个唯一的标记；\n每遍历到一个节点就把该节点和新的树的同一个位置的节点进行对比，如果有差异的话就记录到一个对象里面\n常见的差异包括四种，分别是：\n- 替换节点\n- 增加/删除子节点\n- 修改节点属性\n- 改变文本内容\n\n      ")])])])}],kn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Wn=kn,Gn=Object(c["a"])(Wn,Un,Fn,!1,null,"6632ffde",null),Hn=Gn.exports,Yn=function(){var t=this,n=t._self._c;return n("div",[t._v("t")])},qn=[],zn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Xn=zn,Jn=Object(c["a"])(Xn,Yn,qn,!1,null,"2bd41924",null),Kn=Jn.exports,$n=function(){var t=this,n=t._self._c;return n("div",[t._v("t")])},Zn=[],Qn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},te=Qn,ne=Object(c["a"])(te,$n,Zn,!1,null,"6e073e11",null),ee=ne.exports,re=function(){var t=this,n=t._self._c;return n("div",[t._v("t")])},oe=[],ie={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},ae=ie,se=Object(c["a"])(ae,re,oe,!1,null,"7789eb79",null),ce=se.exports,le=function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("观察者模式")]),n("img",{staticStyle:{width:"600px"},attrs:{src:"https://evelance.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa8956dcf-ca76-4292-926f-e00c0f962883%2FUntitled.png?table=block&id=7a8d0b3c-b382-4bb2-8954-17a6944e4bf0&spaceId=c9e7ae34-64f6-4cc4-9c74-4ce3b1d1ee92&width=1250&userId=&cache=v2",alt:""}}),n("pre",[t._v("  ## 观察者模式\n  定义是在对象之间定义一个**一对多的依赖**，当一个对象自身状态改变的时候，会自动通知给关心该状态的观察者；\n  解决了主体对象与观察者之间功能的耦合，即一个对象状态改变给其他对象通知的问题；\n  这种对象与对象，有点像 商家-顾客 的关系，顾客对商家的某个商品感兴趣，就被商家记住，等有新品发布，便会直接通知顾客\n")]),n("button",{on:{click:t.handleObserver}},[t._v("观察者接受主题发消息")]),n("button",{on:{click:t.handleEmit}},[t._v("发布订阅模式 发消息")])]),t._m(0),t._m(1),n("section",[n("h3",[t._v("单例模式")]),n("p",[t._v(" 一个类只有一个实例，访问的实例永远都是同一个； 全局变量也是一种简单的单例模式； 其实就是对同一个对象引用的操作 ")]),n("button",{on:{click:t.handleSingleMode}},[t._v("测试单例")]),n("pre",[t._v("// Singleton.js 导出去是同一个实例的引用,也可以当做单例使用\nclass Singleton {\n  constructor() {\n    this.someMethod = () => {\n      console.log('Doing something...');\n    };\n  }\n}\nconst instance = new Singleton();\nexport default instance;\n\nimport singletonInstance from './Singleton.js';\nconst instance1 = singletonInstance;\nconst instance2 = singletonInstance;\nconsole.log(instance1 === instance2); // 输出：true\n\n      ")])])])},he=[function(){var t=this,n=t._self._c;return n("section",[n("h3",[t._v("发布订阅")]),n("img",{staticStyle:{width:"600px"},attrs:{src:"https://evelance.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9faab839-61db-4e57-8593-bececd6409da%2FUntitled.png?table=block&id=ecc4a952-cca9-4e28-82f9-1f4d05422777&spaceId=c9e7ae34-64f6-4cc4-9c74-4ce3b1d1ee92&width=1340&userId=&cache=v2",alt:""}}),n("pre",[t._v("  ## 发布订阅模式\n  也是定义一对多的依赖关系，对象状态改变后，通知给所有关心这个状态的订阅者。\n  订阅发布模式有订阅的动作，可以不和商家直接产生联系，只要能订阅上关心的状态即可，通常利用第三方媒介来做，而发布者也会利用三方媒介来通知订阅者。\n  有点像 商家-APP-顾客 的关系，某个产品断货，顾客可以在APP上订阅上货通知，待上新，商家通过APP通知订阅的顾客\n  在程序实现中，第三方媒介称之为 EventBus(事件总线/事件调度中心)，可以理解为订阅事件的集合，它提供订阅、发布、取消等功能。\n  订阅者订阅事件，和发布者发布事件，都通过事件总线进行交互。\n")]),n("pre",[t._v("两种模式的异同\n- 观察者模式\n    - 理解\n        - 顾客（观察者）→ 商店（被观察者）\n    - 行为\n        - 观察者观察对象的改变，对象改变后通知观察者自身改变\n        - 被观察者 自身管理 观察者以及后续的通知操作\n- 发布订阅模式\n    - 理解\n        - 顾客（订阅者）→ 公众号（事件总线/调度中心） ← 商店（发布者）\n    - 行为\n        - 顾客通过公众号订阅商店，商店发布消息后通过公众号告知所有顾客\n- 差异\n    - **发布订阅模式其实就是观察者模式的进一步抽象**，把**订阅池和发布功能**抽离成了一个事件总线/调度中心，方便灵活使用\n\n从概念上理解，两者没什么不同，都在解决对象之间解耦，通过事件的方式在某个时间点进行触发，监听这个事件的订阅者可以进行相应的操作。\n\n在实现上有所不同，**观察者模式**中的**发布者自身来维护**订阅者，后续的一些列操作都要通过**发布者完成**；\n订阅发布模式是订阅者和发布者中间会有一个**事件总线**，操作都要**经过事件总线**完成。\n    ")])])},function(){var t=this,n=t._self._c;return n("section",[n("pre",[t._v("面向对象：把具有相同属性和行为的事物抽象成一个事物类别，通过实例化，让这个事物类别构造出一个具体的事物，这个具体的事物就是对象\nclass实例化： 属性和方法集合的抽象\n\n封装：控制类的属性与方法的可访问方式：\n- private\t只有类的内部可访问\n- public\t完全开放访问\n- protected\t可供子类访问\n Symbol 实现方法私有化\n\nconst doAjax = Symbol('doAjax');\nclass HTTP {\n\t[doAjax](options) {\n  \t...\n  }\n}\n多态：方法的重写和重载\n\n继承：\n实例的__p__指向构造函数的原型prototype\nperson1.__proto__ === Person.prototype\n原型链是JavaScript中实现继承的机制。\n当试图访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript引擎会沿着原型链向上查找，直到找到该属性或者到达原型链的末端（Object.prototype的原型是null）。\n      ")])])}];class ue{static getInstance(t){return ue.instance||(ue.instance=new ue(t)),ue.instance}constructor(t){this.options=t}getOptions(){console.log("xxxx",this.options)}}Object(B["a"])(ue,"instance",null);class de{constructor(){this.someMethod=()=>{console.log("Doing something...")}}}new de;class pe{constructor(t){this.name=t}getMsg(t){console.log(`我是观察者${this.name}，收到通知`,t)}}class ve{constructor(){this.observerMap={}}addListener(t,n){Array.isArray(this.observerMap[t])||(this.observerMap[t]=[]),this.observerMap[t].includes(n)||this.observerMap[t].push(n)}removeListener(t,n){const e=this.observerMap[t];if(e&&e.length){const r=e.filter(t=>t!==n);this.observerMap[t]=r}}emitListener(t,n){const e=this.observerMap[t];e&&e.length&&e.forEach(t=>{t.getMsg(n)})}}class fe{constructor(){Object(B["a"])(this,"handlerMap",{})}on(t,n,e){Array.isArray(this.handlerMap[t])||(this.handlerMap[t]=[]),this.handlerMap[t].includes(n)||(n.once=e,this.handlerMap[t].push(n))}off(t,n){this.handlers[t]&&(this.handlers[t]=this.handlers[t].filter(t=>t!==n))}once(t,n){this.on(t,n,!1)}emit(t,...n){const e=this.handlerMap[t];e.length&&e.forEach(e=>{n.length?e.apply(this,n):e.call(this),e.once&&this.off(t,e)})}}var _e={name:"xxx",components:{},data(){return{}},mounted(){},methods:{handleObserver(){const t=new ve,n=new pe(1),e=new pe(2),r=new pe(3);t.addListener("obWater",n),t.addListener("obWater",e),t.addListener("obTV",r),setTimeout(()=>{t.emitListener("obWater","水降价=》来啊，购买啊"),t.emitListener("obTV","tv降价了")},2e3)},handleEmit(){const t=new fe;function n(t){console.log("我是执行 add1任务的",t)}function e(t){console.log("我是执行 add2任务的",t)}function r(t){console.log("我是执行 delete任务的",t)}t.on("add",n),t.on("add",e),t.on("del",r),t.emit("add",11),t.emit("del",222)},handleSingleMode(){let t=ue.getInstance("xxxaa"),n=ue.getInstance();t.getOptions(),n.getOptions(),console.log(t===n)}}},ge=_e,be=Object(c["a"])(ge,le,he,!1,null,null,null),me=be.exports,Ae=function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("循环和递归")]),n("button",{on:{click:t.arrToTree}},[t._v("arrToTree递归")]),n("button",{on:{click:t.arrToTree1}},[t._v("arrToTree循环")]),t._v(" || "),n("button",{on:{click:t.tree2Arr1}},[t._v("tree2Arr递归")]),n("button",{on:{click:t.tree2Arr2}},[t._v("tree2Arr2循环")])])])},xe=[];e("fffc");const Me=[{id:2,pid:0,name:"一级菜单B"},{id:4,pid:1,name:"二级菜单A-A"},{id:9,pid:7,name:"四级菜单A-A-A-A"},{id:5,pid:1,name:"二级菜单A-B"},{id:6,pid:2,name:"二级菜单B-A"},{id:7,pid:4,name:"三级菜单A-A-A"},{id:8,pid:6,name:"三级级菜单B-A-A"},{id:10,pid:3,name:"2级菜单C-A"},{id:3,pid:0,name:"一级菜单C"},{id:1,pid:0,name:"一级菜单A"}];var Oe={name:"xxx",components:{},data(){return{}},mounted(){},methods:{arrToTree(){function t(t){let n=[],e=[];for(let o=0;o<t.length;o++){const r=t[o];0===r.pid?n.push(r):e.push(r)}function r(t,n){for(let e=0;e<t.length;e++){const o=t[e];for(let t=0;t<n.length;t++){const e=n[t];if(e.pid===o.id){let t=[e];Array.isArray(o.children)?o.children.push(e):o.children=t,r(t,n)}}}}return r(n,e),console.log("rootNodes",n),n}t(Me)},arrToTree1(){function t(t){let n=[];for(let e=0;e<t.length;e++){const r=t[e];if(0===r.pid)n.push(r);else{const n=t.find(t=>t.id===r.pid);Array.isArray(n.children)?n.children.push(r):n.children=[r]}}return n}let n=t(Me);console.log("tree",n)},tree2Arr1(){},tree2Arr2(){}}},Te=Oe,we=Object(c["a"])(Te,Ae,xe,!1,null,null,null),ye=we.exports,Se=function(){var t=this,n=t._self._c;return n("div",[t._v("t")])},Ee=[],Re={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},De=Re,Ve=Object(c["a"])(De,Se,Ee,!1,null,"6712a19d",null),Ie=Ve.exports,Ne=function(){var t=this,n=t._self._c;return n("div",[n("p",[n("button",{on:{click:function(n){return t.handledebounce1()}}},[t._v("防抖1,执行函数不传参")]),n("button",{on:{click:function(n){return t.handledebounce2("xx",{oo:1})}}},[t._v(" 防抖2，执行函数传参 ")]),n("button",{on:{click:function(n){return t.handledebounce3()}}},[t._v("防抖3,首次立即执行")])]),n("p",[n("button",{on:{click:function(n){return t.handleThrollte1()}}},[t._v("节流1,执行函数不传参")]),n("button",{on:{click:function(n){return t.handleThrollte2("xx",{oo:1})}}},[t._v(" 节流2，执行函数传参 ")])])])},Pe=[];function Ce(t,n){console.log("dbfunc",t,n)}function Le(t){console.log("throttle",t)}var je={name:"xxx",components:{},data(){return{}},mounted(){},methods:{handledebounce1:Ft(Ce,2e3),handledebounce2:Ft(Ce,2e3),handledebounce3:Ft(Ce,2e3,!0),handleThrollte1:kt(Le,2e3),handleThrollte2:kt(Le,2e3)}},Be=je,Ue=Object(c["a"])(Be,Ne,Pe,!1,null,null,null),Fe=Ue.exports;r["a"].use(u["a"]);const ke=[{path:"/",redirect:"/GLSL"},{path:"/GLSL",name:"GLSL",component:g},{path:"/Coord",name:"Coord",component:O},{path:"/Vector",name:"Vector",component:R},{path:"/Matrix",name:"Matrix",component:C},{path:"/TEST_GL_API",name:"TEST_GL_API",component:Jt},{path:"/study",name:"Study",component:nn,redirect:"/study/html",children:[{path:"/study/html",name:"html",component:cn},{path:"/study/css",name:"css",component:vn},{path:"/study/js",name:"js",component:An},{path:"/study/browser",name:"浏览器",component:yn},{path:"/study/network",name:"network",component:In},{path:"/study/git",name:"Git管理",component:Bn},{path:"/study/vuereact",name:"框架vue-react",component:Hn},{path:"/study/webpack",name:"webpack",component:Kn},{path:"/study/ts",name:"ts",component:ee},{path:"/study/optimize",name:"优化手段",component:ce},{path:"/study/designmode",name:"设计模式",component:me},{path:"/study/aigorithm",name:"算法",component:ye},{path:"/study/bussiness1",name:"业务1",component:Ie},{path:"/study/test",name:"logicCode",component:Fe}]}],We=new u["a"]({mode:"history",base:"/hh-render/",routes:ke});var Ge=We,He=e("2f62");r["a"].use(He["a"]);var Ye=new He["a"].Store({state:{},mutations:{},actions:{},modules:{}});e("8e1f");r["a"].config.productionTip=!1,new r["a"]({router:Ge,store:Ye,render:t=>t(h)}).$mount("#app")},8554:function(t,n,e){t.exports=e.p+"static/img/1.3058969f.jpg"},"859d":function(t,n,e){},"8a76":function(t,n,e){t.exports=e.p+"static/img/coordlr.33299a8b.png"},"8e1f":function(t,n,e){},"97e5":function(t,n,e){t.exports=e.p+"static/img/bs.768201a7.png"},"9c9c":function(t,n,e){},a396:function(t,n,e){"use strict";e("0721")},b1b7:function(t,n,e){"use strict";e("2487")},b75e:function(t,n,e){"use strict";e("b78e")},b77c:function(t,n,e){"use strict";e("52fe")},b78e:function(t,n,e){},bafb:function(t,n,e){t.exports=e.p+"static/img/4.e580020d.jpg"},c83a:function(t,n,e){e("2c66"),e("249d"),e("40e9"),e("907a"),e("986a"),e("1d02"),e("3c5d"),e("6ce5"),e("2834"),e("4ea1"),e("0643"),e("4e3e"),function(n,e){t.exports=e()}(0,(function(){return function(t){var n={};function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t["default"]}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=4)}([function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setMatrixArrayType=o,n.toRadian=a,n.equals=s;var r=n.EPSILON=1e-6;n.ARRAY_TYPE="undefined"!==typeof Float32Array?Float32Array:Array,n.RANDOM=Math.random;function o(t){n.ARRAY_TYPE=t}var i=Math.PI/180;function a(t){return t*i}function s(t,n){return Math.abs(t-n)<=r*Math.max(1,Math.abs(t),Math.abs(n))}},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.fromMat4=s,n.clone=c,n.copy=l,n.fromValues=h,n.set=u,n.identity=d,n.transpose=p,n.invert=v,n.adjoint=f,n.determinant=_,n.multiply=g,n.translate=b,n.rotate=m,n.scale=A,n.fromTranslation=x,n.fromRotation=M,n.fromScaling=O,n.fromMat2d=T,n.fromQuat=w,n.normalFromMat4=y,n.projection=S,n.str=E,n.frob=R,n.add=D,n.subtract=V,n.multiplyScalar=I,n.multiplyScalarAndAdd=N,n.exactEquals=P,n.equals=C;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function s(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t}function c(t){var n=new o.ARRAY_TYPE(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n}function l(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t}function h(t,n,e,r,i,a,s,c,l){var h=new o.ARRAY_TYPE(9);return h[0]=t,h[1]=n,h[2]=e,h[3]=r,h[4]=i,h[5]=a,h[6]=s,h[7]=c,h[8]=l,h}function u(t,n,e,r,o,i,a,s,c,l){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t[4]=i,t[5]=a,t[6]=s,t[7]=c,t[8]=l,t}function d(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function p(t,n){if(t===n){var e=n[1],r=n[2],o=n[5];t[1]=n[3],t[2]=n[6],t[3]=e,t[5]=n[7],t[6]=r,t[7]=o}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t}function v(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],h=n[8],u=h*a-s*l,d=-h*i+s*c,p=l*i-a*c,v=e*u+r*d+o*p;return v?(v=1/v,t[0]=u*v,t[1]=(-h*r+o*l)*v,t[2]=(s*r-o*a)*v,t[3]=d*v,t[4]=(h*e-o*c)*v,t[5]=(-s*e+o*i)*v,t[6]=p*v,t[7]=(-l*e+r*c)*v,t[8]=(a*e-r*i)*v,t):null}function f(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],h=n[8];return t[0]=a*h-s*l,t[1]=o*l-r*h,t[2]=r*s-o*a,t[3]=s*c-i*h,t[4]=e*h-o*c,t[5]=o*i-e*s,t[6]=i*l-a*c,t[7]=r*c-e*l,t[8]=e*a-r*i,t}function _(t){var n=t[0],e=t[1],r=t[2],o=t[3],i=t[4],a=t[5],s=t[6],c=t[7],l=t[8];return n*(l*i-a*c)+e*(-l*o+a*s)+r*(c*o-i*s)}function g(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],h=n[7],u=n[8],d=e[0],p=e[1],v=e[2],f=e[3],_=e[4],g=e[5],b=e[6],m=e[7],A=e[8];return t[0]=d*r+p*a+v*l,t[1]=d*o+p*s+v*h,t[2]=d*i+p*c+v*u,t[3]=f*r+_*a+g*l,t[4]=f*o+_*s+g*h,t[5]=f*i+_*c+g*u,t[6]=b*r+m*a+A*l,t[7]=b*o+m*s+A*h,t[8]=b*i+m*c+A*u,t}function b(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],h=n[7],u=n[8],d=e[0],p=e[1];return t[0]=r,t[1]=o,t[2]=i,t[3]=a,t[4]=s,t[5]=c,t[6]=d*r+p*a+l,t[7]=d*o+p*s+h,t[8]=d*i+p*c+u,t}function m(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],h=n[7],u=n[8],d=Math.sin(e),p=Math.cos(e);return t[0]=p*r+d*a,t[1]=p*o+d*s,t[2]=p*i+d*c,t[3]=p*a-d*r,t[4]=p*s-d*o,t[5]=p*c-d*i,t[6]=l,t[7]=h,t[8]=u,t}function A(t,n,e){var r=e[0],o=e[1];return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=o*n[3],t[4]=o*n[4],t[5]=o*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t}function x(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t}function M(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=0,t[3]=-e,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function O(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function T(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t}function w(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e+e,s=r+r,c=o+o,l=e*a,h=r*a,u=r*s,d=o*a,p=o*s,v=o*c,f=i*a,_=i*s,g=i*c;return t[0]=1-u-v,t[3]=h-g,t[6]=d+_,t[1]=h+g,t[4]=1-l-v,t[7]=p-f,t[2]=d-_,t[5]=p+f,t[8]=1-l-u,t}function y(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],h=n[8],u=n[9],d=n[10],p=n[11],v=n[12],f=n[13],_=n[14],g=n[15],b=e*s-r*a,m=e*c-o*a,A=e*l-i*a,x=r*c-o*s,M=r*l-i*s,O=o*l-i*c,T=h*f-u*v,w=h*_-d*v,y=h*g-p*v,S=u*_-d*f,E=u*g-p*f,R=d*g-p*_,D=b*R-m*E+A*S+x*y-M*w+O*T;return D?(D=1/D,t[0]=(s*R-c*E+l*S)*D,t[1]=(c*y-a*R-l*w)*D,t[2]=(a*E-s*y+l*T)*D,t[3]=(o*E-r*R-i*S)*D,t[4]=(e*R-o*y+i*w)*D,t[5]=(r*y-e*E-i*T)*D,t[6]=(f*O-_*M+g*x)*D,t[7]=(_*A-v*O-g*m)*D,t[8]=(v*M-f*A+g*b)*D,t):null}function S(t,n,e){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/e,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t}function E(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"}function R(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))}function D(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t[4]=n[4]+e[4],t[5]=n[5]+e[5],t[6]=n[6]+e[6],t[7]=n[7]+e[7],t[8]=n[8]+e[8],t}function V(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t[4]=n[4]-e[4],t[5]=n[5]-e[5],t[6]=n[6]-e[6],t[7]=n[7]-e[7],t[8]=n[8]-e[8],t}function I(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*e,t}function N(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t[4]=n[4]+e[4]*r,t[5]=n[5]+e[5]*r,t[6]=n[6]+e[6]*r,t[7]=n[7]+e[7]*r,t[8]=n[8]+e[8]*r,t}function P(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]}function C(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=t[4],c=t[5],l=t[6],h=t[7],u=t[8],d=n[0],p=n[1],v=n[2],f=n[3],_=n[4],g=n[5],b=n[6],m=n[7],A=n[8];return Math.abs(e-d)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(d))&&Math.abs(r-p)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(p))&&Math.abs(i-v)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(v))&&Math.abs(a-f)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(f))&&Math.abs(s-_)<=o.EPSILON*Math.max(1,Math.abs(s),Math.abs(_))&&Math.abs(c-g)<=o.EPSILON*Math.max(1,Math.abs(c),Math.abs(g))&&Math.abs(l-b)<=o.EPSILON*Math.max(1,Math.abs(l),Math.abs(b))&&Math.abs(h-m)<=o.EPSILON*Math.max(1,Math.abs(h),Math.abs(m))&&Math.abs(u-A)<=o.EPSILON*Math.max(1,Math.abs(u),Math.abs(A))}n.mul=g,n.sub=V},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=a,n.clone=s,n.length=c,n.fromValues=l,n.copy=h,n.set=u,n.add=d,n.subtract=p,n.multiply=v,n.divide=f,n.ceil=_,n.floor=g,n.min=b,n.max=m,n.round=A,n.scale=x,n.scaleAndAdd=M,n.distance=O,n.squaredDistance=T,n.squaredLength=w,n.negate=y,n.inverse=S,n.normalize=E,n.dot=R,n.cross=D,n.lerp=V,n.hermite=I,n.bezier=N,n.random=P,n.transformMat4=C,n.transformMat3=L,n.transformQuat=j,n.rotateX=B,n.rotateY=U,n.rotateZ=F,n.angle=k,n.str=W,n.exactEquals=G,n.equals=H;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t}function s(t){var n=new o.ARRAY_TYPE(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n}function c(t){var n=t[0],e=t[1],r=t[2];return Math.sqrt(n*n+e*e+r*r)}function l(t,n,e){var r=new o.ARRAY_TYPE(3);return r[0]=t,r[1]=n,r[2]=e,r}function h(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t}function u(t,n,e,r){return t[0]=n,t[1]=e,t[2]=r,t}function d(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t}function p(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t}function v(t,n,e){return t[0]=n[0]*e[0],t[1]=n[1]*e[1],t[2]=n[2]*e[2],t}function f(t,n,e){return t[0]=n[0]/e[0],t[1]=n[1]/e[1],t[2]=n[2]/e[2],t}function _(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t}function g(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t}function b(t,n,e){return t[0]=Math.min(n[0],e[0]),t[1]=Math.min(n[1],e[1]),t[2]=Math.min(n[2],e[2]),t}function m(t,n,e){return t[0]=Math.max(n[0],e[0]),t[1]=Math.max(n[1],e[1]),t[2]=Math.max(n[2],e[2]),t}function A(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t}function x(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t}function M(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t}function O(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2];return Math.sqrt(e*e+r*r+o*o)}function T(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2];return e*e+r*r+o*o}function w(t){var n=t[0],e=t[1],r=t[2];return n*n+e*e+r*r}function y(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t}function S(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t}function E(t,n){var e=n[0],r=n[1],o=n[2],i=e*e+r*r+o*o;return i>0&&(i=1/Math.sqrt(i),t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i),t}function R(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function D(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[0],s=e[1],c=e[2];return t[0]=o*c-i*s,t[1]=i*a-r*c,t[2]=r*s-o*a,t}function V(t,n,e,r){var o=n[0],i=n[1],a=n[2];return t[0]=o+r*(e[0]-o),t[1]=i+r*(e[1]-i),t[2]=a+r*(e[2]-a),t}function I(t,n,e,r,o,i){var a=i*i,s=a*(2*i-3)+1,c=a*(i-2)+i,l=a*(i-1),h=a*(3-2*i);return t[0]=n[0]*s+e[0]*c+r[0]*l+o[0]*h,t[1]=n[1]*s+e[1]*c+r[1]*l+o[1]*h,t[2]=n[2]*s+e[2]*c+r[2]*l+o[2]*h,t}function N(t,n,e,r,o,i){var a=1-i,s=a*a,c=i*i,l=s*a,h=3*i*s,u=3*c*a,d=c*i;return t[0]=n[0]*l+e[0]*h+r[0]*u+o[0]*d,t[1]=n[1]*l+e[1]*h+r[1]*u+o[1]*d,t[2]=n[2]*l+e[2]*h+r[2]*u+o[2]*d,t}function P(t,n){n=n||1;var e=2*o.RANDOM()*Math.PI,r=2*o.RANDOM()-1,i=Math.sqrt(1-r*r)*n;return t[0]=Math.cos(e)*i,t[1]=Math.sin(e)*i,t[2]=r*n,t}function C(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[3]*r+e[7]*o+e[11]*i+e[15];return a=a||1,t[0]=(e[0]*r+e[4]*o+e[8]*i+e[12])/a,t[1]=(e[1]*r+e[5]*o+e[9]*i+e[13])/a,t[2]=(e[2]*r+e[6]*o+e[10]*i+e[14])/a,t}function L(t,n,e){var r=n[0],o=n[1],i=n[2];return t[0]=r*e[0]+o*e[3]+i*e[6],t[1]=r*e[1]+o*e[4]+i*e[7],t[2]=r*e[2]+o*e[5]+i*e[8],t}function j(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[0],s=e[1],c=e[2],l=e[3],h=l*r+s*i-c*o,u=l*o+c*r-a*i,d=l*i+a*o-s*r,p=-a*r-s*o-c*i;return t[0]=h*l+p*-a+u*-c-d*-s,t[1]=u*l+p*-s+d*-a-h*-c,t[2]=d*l+p*-c+h*-s-u*-a,t}function B(t,n,e,r){var o=[],i=[];return o[0]=n[0]-e[0],o[1]=n[1]-e[1],o[2]=n[2]-e[2],i[0]=o[0],i[1]=o[1]*Math.cos(r)-o[2]*Math.sin(r),i[2]=o[1]*Math.sin(r)+o[2]*Math.cos(r),t[0]=i[0]+e[0],t[1]=i[1]+e[1],t[2]=i[2]+e[2],t}function U(t,n,e,r){var o=[],i=[];return o[0]=n[0]-e[0],o[1]=n[1]-e[1],o[2]=n[2]-e[2],i[0]=o[2]*Math.sin(r)+o[0]*Math.cos(r),i[1]=o[1],i[2]=o[2]*Math.cos(r)-o[0]*Math.sin(r),t[0]=i[0]+e[0],t[1]=i[1]+e[1],t[2]=i[2]+e[2],t}function F(t,n,e,r){var o=[],i=[];return o[0]=n[0]-e[0],o[1]=n[1]-e[1],o[2]=n[2]-e[2],i[0]=o[0]*Math.cos(r)-o[1]*Math.sin(r),i[1]=o[0]*Math.sin(r)+o[1]*Math.cos(r),i[2]=o[2],t[0]=i[0]+e[0],t[1]=i[1]+e[1],t[2]=i[2]+e[2],t}function k(t,n){var e=l(t[0],t[1],t[2]),r=l(n[0],n[1],n[2]);E(e,e),E(r,r);var o=R(e,r);return o>1?0:o<-1?Math.PI:Math.acos(o)}function W(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"}function G(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]}function H(t,n){var e=t[0],r=t[1],i=t[2],a=n[0],s=n[1],c=n[2];return Math.abs(e-a)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(a))&&Math.abs(r-s)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(i-c)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(c))}n.sub=p,n.mul=v,n.div=f,n.dist=O,n.sqrDist=T,n.len=c,n.sqrLen=w,n.forEach=function(){var t=a();return function(n,e,r,o,i,a){var s=void 0,c=void 0;for(e||(e=3),r||(r=0),c=o?Math.min(o*e+r,n.length):n.length,s=r;s<c;s+=e)t[0]=n[s],t[1]=n[s+1],t[2]=n[s+2],i(t,t,a),n[s]=t[0],n[s+1]=t[1],n[s+2]=t[2];return n}}()},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=a,n.clone=s,n.fromValues=c,n.copy=l,n.set=h,n.add=u,n.subtract=d,n.multiply=p,n.divide=v,n.ceil=f,n.floor=_,n.min=g,n.max=b,n.round=m,n.scale=A,n.scaleAndAdd=x,n.distance=M,n.squaredDistance=O,n.length=T,n.squaredLength=w,n.negate=y,n.inverse=S,n.normalize=E,n.dot=R,n.lerp=D,n.random=V,n.transformMat4=I,n.transformQuat=N,n.str=P,n.exactEquals=C,n.equals=L;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}function s(t){var n=new o.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function c(t,n,e,r){var i=new o.ARRAY_TYPE(4);return i[0]=t,i[1]=n,i[2]=e,i[3]=r,i}function l(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function h(t,n,e,r,o){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t}function u(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t}function d(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t}function p(t,n,e){return t[0]=n[0]*e[0],t[1]=n[1]*e[1],t[2]=n[2]*e[2],t[3]=n[3]*e[3],t}function v(t,n,e){return t[0]=n[0]/e[0],t[1]=n[1]/e[1],t[2]=n[2]/e[2],t[3]=n[3]/e[3],t}function f(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t}function _(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t}function g(t,n,e){return t[0]=Math.min(n[0],e[0]),t[1]=Math.min(n[1],e[1]),t[2]=Math.min(n[2],e[2]),t[3]=Math.min(n[3],e[3]),t}function b(t,n,e){return t[0]=Math.max(n[0],e[0]),t[1]=Math.max(n[1],e[1]),t[2]=Math.max(n[2],e[2]),t[3]=Math.max(n[3],e[3]),t}function m(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t}function A(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t}function x(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t}function M(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2],i=n[3]-t[3];return Math.sqrt(e*e+r*r+o*o+i*i)}function O(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2],i=n[3]-t[3];return e*e+r*r+o*o+i*i}function T(t){var n=t[0],e=t[1],r=t[2],o=t[3];return Math.sqrt(n*n+e*e+r*r+o*o)}function w(t){var n=t[0],e=t[1],r=t[2],o=t[3];return n*n+e*e+r*r+o*o}function y(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t}function S(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t}function E(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e*e+r*r+o*o+i*i;return a>0&&(a=1/Math.sqrt(a),t[0]=e*a,t[1]=r*a,t[2]=o*a,t[3]=i*a),t}function R(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]}function D(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=n[3];return t[0]=o+r*(e[0]-o),t[1]=i+r*(e[1]-i),t[2]=a+r*(e[2]-a),t[3]=s+r*(e[3]-s),t}function V(t,n){return n=n||1,t[0]=o.RANDOM(),t[1]=o.RANDOM(),t[2]=o.RANDOM(),t[3]=o.RANDOM(),E(t,t),A(t,t,n),t}function I(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3];return t[0]=e[0]*r+e[4]*o+e[8]*i+e[12]*a,t[1]=e[1]*r+e[5]*o+e[9]*i+e[13]*a,t[2]=e[2]*r+e[6]*o+e[10]*i+e[14]*a,t[3]=e[3]*r+e[7]*o+e[11]*i+e[15]*a,t}function N(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[0],s=e[1],c=e[2],l=e[3],h=l*r+s*i-c*o,u=l*o+c*r-a*i,d=l*i+a*o-s*r,p=-a*r-s*o-c*i;return t[0]=h*l+p*-a+u*-c-d*-s,t[1]=u*l+p*-s+d*-a-h*-c,t[2]=d*l+p*-c+h*-s-u*-a,t[3]=n[3],t}function P(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function C(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function L(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=n[0],c=n[1],l=n[2],h=n[3];return Math.abs(e-s)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(r-c)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(i-l)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(a-h)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(h))}n.sub=d,n.mul=p,n.div=v,n.dist=M,n.sqrDist=O,n.len=T,n.sqrLen=w,n.forEach=function(){var t=a();return function(n,e,r,o,i,a){var s=void 0,c=void 0;for(e||(e=4),r||(r=0),c=o?Math.min(o*e+r,n.length):n.length,s=r;s<c;s+=e)t[0]=n[s],t[1]=n[s+1],t[2]=n[s+2],t[3]=n[s+3],i(t,t,a),n[s]=t[0],n[s+1]=t[1],n[s+2]=t[2],n[s+3]=t[3];return n}}()},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.vec4=n.vec3=n.vec2=n.quat=n.mat4=n.mat3=n.mat2d=n.mat2=n.glMatrix=void 0;var r=e(0),o=x(r),i=e(5),a=x(i),s=e(6),c=x(s),l=e(1),h=x(l),u=e(7),d=x(u),p=e(8),v=x(p),f=e(9),_=x(f),g=e(2),b=x(g),m=e(3),A=x(m);function x(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}n.glMatrix=o,n.mat2=a,n.mat2d=c,n.mat3=h,n.mat4=d,n.quat=v,n.vec2=_,n.vec3=b,n.vec4=A},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.clone=s,n.copy=c,n.identity=l,n.fromValues=h,n.set=u,n.transpose=d,n.invert=p,n.adjoint=v,n.determinant=f,n.multiply=_,n.rotate=g,n.scale=b,n.fromRotation=m,n.fromScaling=A,n.str=x,n.frob=M,n.LDU=O,n.add=T,n.subtract=w,n.exactEquals=y,n.equals=S,n.multiplyScalar=E,n.multiplyScalarAndAdd=R;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function s(t){var n=new o.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function c(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function l(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function h(t,n,e,r){var i=new o.ARRAY_TYPE(4);return i[0]=t,i[1]=n,i[2]=e,i[3]=r,i}function u(t,n,e,r,o){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t}function d(t,n){if(t===n){var e=n[1];t[1]=n[2],t[2]=e}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t}function p(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e*i-o*r;return a?(a=1/a,t[0]=i*a,t[1]=-r*a,t[2]=-o*a,t[3]=e*a,t):null}function v(t,n){var e=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=e,t}function f(t){return t[0]*t[3]-t[2]*t[1]}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],c=e[1],l=e[2],h=e[3];return t[0]=r*s+i*c,t[1]=o*s+a*c,t[2]=r*l+i*h,t[3]=o*l+a*h,t}function g(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c+i*s,t[1]=o*c+a*s,t[2]=r*-s+i*c,t[3]=o*-s+a*c,t}function b(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],c=e[1];return t[0]=r*s,t[1]=o*s,t[2]=i*c,t[3]=a*c,t}function m(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=-e,t[3]=r,t}function A(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t}function x(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function M(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))}function O(t,n,e,r){return t[2]=r[2]/r[0],e[0]=r[0],e[1]=r[1],e[3]=r[3]-t[2]*e[1],[t,n,e]}function T(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t}function w(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t}function y(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function S(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=n[0],c=n[1],l=n[2],h=n[3];return Math.abs(e-s)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(r-c)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(i-l)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(a-h)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(h))}function E(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t}function R(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t}n.mul=_,n.sub=w},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.clone=s,n.copy=c,n.identity=l,n.fromValues=h,n.set=u,n.invert=d,n.determinant=p,n.multiply=v,n.rotate=f,n.scale=_,n.translate=g,n.fromRotation=b,n.fromScaling=m,n.fromTranslation=A,n.str=x,n.frob=M,n.add=O,n.subtract=T,n.multiplyScalar=w,n.multiplyScalarAndAdd=y,n.exactEquals=S,n.equals=E;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function s(t){var n=new o.ARRAY_TYPE(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n}function c(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t}function l(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function h(t,n,e,r,i,a){var s=new o.ARRAY_TYPE(6);return s[0]=t,s[1]=n,s[2]=e,s[3]=r,s[4]=i,s[5]=a,s}function u(t,n,e,r,o,i,a){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t[4]=i,t[5]=a,t}function d(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=e*i-r*o;return c?(c=1/c,t[0]=i*c,t[1]=-r*c,t[2]=-o*c,t[3]=e*c,t[4]=(o*s-i*a)*c,t[5]=(r*a-e*s)*c,t):null}function p(t){return t[0]*t[3]-t[1]*t[2]}function v(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=e[0],h=e[1],u=e[2],d=e[3],p=e[4],v=e[5];return t[0]=r*l+i*h,t[1]=o*l+a*h,t[2]=r*u+i*d,t[3]=o*u+a*d,t[4]=r*p+i*v+s,t[5]=o*p+a*v+c,t}function f(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=Math.sin(e),h=Math.cos(e);return t[0]=r*h+i*l,t[1]=o*h+a*l,t[2]=r*-l+i*h,t[3]=o*-l+a*h,t[4]=s,t[5]=c,t}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=e[0],h=e[1];return t[0]=r*l,t[1]=o*l,t[2]=i*h,t[3]=a*h,t[4]=s,t[5]=c,t}function g(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=e[0],h=e[1];return t[0]=r,t[1]=o,t[2]=i,t[3]=a,t[4]=r*l+i*h+s,t[5]=o*l+a*h+c,t}function b(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=-e,t[3]=r,t[4]=0,t[5]=0,t}function m(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t}function A(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t}function x(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"}function M(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)}function O(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t[4]=n[4]+e[4],t[5]=n[5]+e[5],t}function T(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t[4]=n[4]-e[4],t[5]=n[5]-e[5],t}function w(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t[4]=n[4]*e,t[5]=n[5]*e,t}function y(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t[4]=n[4]+e[4]*r,t[5]=n[5]+e[5]*r,t}function S(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]}function E(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=t[4],c=t[5],l=n[0],h=n[1],u=n[2],d=n[3],p=n[4],v=n[5];return Math.abs(e-l)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(l))&&Math.abs(r-h)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(i-u)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(a-d)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(d))&&Math.abs(s-p)<=o.EPSILON*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(c-v)<=o.EPSILON*Math.max(1,Math.abs(c),Math.abs(v))}n.mul=v,n.sub=T},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.clone=s,n.copy=c,n.fromValues=l,n.set=h,n.identity=u,n.transpose=d,n.invert=p,n.adjoint=v,n.determinant=f,n.multiply=_,n.translate=g,n.scale=b,n.rotate=m,n.rotateX=A,n.rotateY=x,n.rotateZ=M,n.fromTranslation=O,n.fromScaling=T,n.fromRotation=w,n.fromXRotation=y,n.fromYRotation=S,n.fromZRotation=E,n.fromRotationTranslation=R,n.getTranslation=D,n.getScaling=V,n.getRotation=I,n.fromRotationTranslationScale=N,n.fromRotationTranslationScaleOrigin=P,n.fromQuat=C,n.frustum=L,n.perspective=j,n.perspectiveFromFieldOfView=B,n.ortho=U,n.lookAt=F,n.targetTo=k,n.str=W,n.frob=G,n.add=H,n.subtract=Y,n.multiplyScalar=q,n.multiplyScalarAndAdd=z,n.exactEquals=X,n.equals=J;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function s(t){var n=new o.ARRAY_TYPE(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n}function c(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}function l(t,n,e,r,i,a,s,c,l,h,u,d,p,v,f,_){var g=new o.ARRAY_TYPE(16);return g[0]=t,g[1]=n,g[2]=e,g[3]=r,g[4]=i,g[5]=a,g[6]=s,g[7]=c,g[8]=l,g[9]=h,g[10]=u,g[11]=d,g[12]=p,g[13]=v,g[14]=f,g[15]=_,g}function h(t,n,e,r,o,i,a,s,c,l,h,u,d,p,v,f,_){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t[4]=i,t[5]=a,t[6]=s,t[7]=c,t[8]=l,t[9]=h,t[10]=u,t[11]=d,t[12]=p,t[13]=v,t[14]=f,t[15]=_,t}function u(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function d(t,n){if(t===n){var e=n[1],r=n[2],o=n[3],i=n[6],a=n[7],s=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=e,t[6]=n[9],t[7]=n[13],t[8]=r,t[9]=i,t[11]=n[14],t[12]=o,t[13]=a,t[14]=s}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t}function p(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],h=n[8],u=n[9],d=n[10],p=n[11],v=n[12],f=n[13],_=n[14],g=n[15],b=e*s-r*a,m=e*c-o*a,A=e*l-i*a,x=r*c-o*s,M=r*l-i*s,O=o*l-i*c,T=h*f-u*v,w=h*_-d*v,y=h*g-p*v,S=u*_-d*f,E=u*g-p*f,R=d*g-p*_,D=b*R-m*E+A*S+x*y-M*w+O*T;return D?(D=1/D,t[0]=(s*R-c*E+l*S)*D,t[1]=(o*E-r*R-i*S)*D,t[2]=(f*O-_*M+g*x)*D,t[3]=(d*M-u*O-p*x)*D,t[4]=(c*y-a*R-l*w)*D,t[5]=(e*R-o*y+i*w)*D,t[6]=(_*A-v*O-g*m)*D,t[7]=(h*O-d*A+p*m)*D,t[8]=(a*E-s*y+l*T)*D,t[9]=(r*y-e*E-i*T)*D,t[10]=(v*M-f*A+g*b)*D,t[11]=(u*A-h*M-p*b)*D,t[12]=(s*w-a*S-c*T)*D,t[13]=(e*S-r*w+o*T)*D,t[14]=(f*m-v*x-_*b)*D,t[15]=(h*x-u*m+d*b)*D,t):null}function v(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],h=n[8],u=n[9],d=n[10],p=n[11],v=n[12],f=n[13],_=n[14],g=n[15];return t[0]=s*(d*g-p*_)-u*(c*g-l*_)+f*(c*p-l*d),t[1]=-(r*(d*g-p*_)-u*(o*g-i*_)+f*(o*p-i*d)),t[2]=r*(c*g-l*_)-s*(o*g-i*_)+f*(o*l-i*c),t[3]=-(r*(c*p-l*d)-s*(o*p-i*d)+u*(o*l-i*c)),t[4]=-(a*(d*g-p*_)-h*(c*g-l*_)+v*(c*p-l*d)),t[5]=e*(d*g-p*_)-h*(o*g-i*_)+v*(o*p-i*d),t[6]=-(e*(c*g-l*_)-a*(o*g-i*_)+v*(o*l-i*c)),t[7]=e*(c*p-l*d)-a*(o*p-i*d)+h*(o*l-i*c),t[8]=a*(u*g-p*f)-h*(s*g-l*f)+v*(s*p-l*u),t[9]=-(e*(u*g-p*f)-h*(r*g-i*f)+v*(r*p-i*u)),t[10]=e*(s*g-l*f)-a*(r*g-i*f)+v*(r*l-i*s),t[11]=-(e*(s*p-l*u)-a*(r*p-i*u)+h*(r*l-i*s)),t[12]=-(a*(u*_-d*f)-h*(s*_-c*f)+v*(s*d-c*u)),t[13]=e*(u*_-d*f)-h*(r*_-o*f)+v*(r*d-o*u),t[14]=-(e*(s*_-c*f)-a*(r*_-o*f)+v*(r*c-o*s)),t[15]=e*(s*d-c*u)-a*(r*d-o*u)+h*(r*c-o*s),t}function f(t){var n=t[0],e=t[1],r=t[2],o=t[3],i=t[4],a=t[5],s=t[6],c=t[7],l=t[8],h=t[9],u=t[10],d=t[11],p=t[12],v=t[13],f=t[14],_=t[15],g=n*a-e*i,b=n*s-r*i,m=n*c-o*i,A=e*s-r*a,x=e*c-o*a,M=r*c-o*s,O=l*v-h*p,T=l*f-u*p,w=l*_-d*p,y=h*f-u*v,S=h*_-d*v,E=u*_-d*f;return g*E-b*S+m*y+A*w-x*T+M*O}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],h=n[7],u=n[8],d=n[9],p=n[10],v=n[11],f=n[12],_=n[13],g=n[14],b=n[15],m=e[0],A=e[1],x=e[2],M=e[3];return t[0]=m*r+A*s+x*u+M*f,t[1]=m*o+A*c+x*d+M*_,t[2]=m*i+A*l+x*p+M*g,t[3]=m*a+A*h+x*v+M*b,m=e[4],A=e[5],x=e[6],M=e[7],t[4]=m*r+A*s+x*u+M*f,t[5]=m*o+A*c+x*d+M*_,t[6]=m*i+A*l+x*p+M*g,t[7]=m*a+A*h+x*v+M*b,m=e[8],A=e[9],x=e[10],M=e[11],t[8]=m*r+A*s+x*u+M*f,t[9]=m*o+A*c+x*d+M*_,t[10]=m*i+A*l+x*p+M*g,t[11]=m*a+A*h+x*v+M*b,m=e[12],A=e[13],x=e[14],M=e[15],t[12]=m*r+A*s+x*u+M*f,t[13]=m*o+A*c+x*d+M*_,t[14]=m*i+A*l+x*p+M*g,t[15]=m*a+A*h+x*v+M*b,t}function g(t,n,e){var r=e[0],o=e[1],i=e[2],a=void 0,s=void 0,c=void 0,l=void 0,h=void 0,u=void 0,d=void 0,p=void 0,v=void 0,f=void 0,_=void 0,g=void 0;return n===t?(t[12]=n[0]*r+n[4]*o+n[8]*i+n[12],t[13]=n[1]*r+n[5]*o+n[9]*i+n[13],t[14]=n[2]*r+n[6]*o+n[10]*i+n[14],t[15]=n[3]*r+n[7]*o+n[11]*i+n[15]):(a=n[0],s=n[1],c=n[2],l=n[3],h=n[4],u=n[5],d=n[6],p=n[7],v=n[8],f=n[9],_=n[10],g=n[11],t[0]=a,t[1]=s,t[2]=c,t[3]=l,t[4]=h,t[5]=u,t[6]=d,t[7]=p,t[8]=v,t[9]=f,t[10]=_,t[11]=g,t[12]=a*r+h*o+v*i+n[12],t[13]=s*r+u*o+f*i+n[13],t[14]=c*r+d*o+_*i+n[14],t[15]=l*r+p*o+g*i+n[15]),t}function b(t,n,e){var r=e[0],o=e[1],i=e[2];return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*o,t[5]=n[5]*o,t[6]=n[6]*o,t[7]=n[7]*o,t[8]=n[8]*i,t[9]=n[9]*i,t[10]=n[10]*i,t[11]=n[11]*i,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}function m(t,n,e,r){var i=r[0],a=r[1],s=r[2],c=Math.sqrt(i*i+a*a+s*s),l=void 0,h=void 0,u=void 0,d=void 0,p=void 0,v=void 0,f=void 0,_=void 0,g=void 0,b=void 0,m=void 0,A=void 0,x=void 0,M=void 0,O=void 0,T=void 0,w=void 0,y=void 0,S=void 0,E=void 0,R=void 0,D=void 0,V=void 0,I=void 0;return Math.abs(c)<o.EPSILON?null:(c=1/c,i*=c,a*=c,s*=c,l=Math.sin(e),h=Math.cos(e),u=1-h,d=n[0],p=n[1],v=n[2],f=n[3],_=n[4],g=n[5],b=n[6],m=n[7],A=n[8],x=n[9],M=n[10],O=n[11],T=i*i*u+h,w=a*i*u+s*l,y=s*i*u-a*l,S=i*a*u-s*l,E=a*a*u+h,R=s*a*u+i*l,D=i*s*u+a*l,V=a*s*u-i*l,I=s*s*u+h,t[0]=d*T+_*w+A*y,t[1]=p*T+g*w+x*y,t[2]=v*T+b*w+M*y,t[3]=f*T+m*w+O*y,t[4]=d*S+_*E+A*R,t[5]=p*S+g*E+x*R,t[6]=v*S+b*E+M*R,t[7]=f*S+m*E+O*R,t[8]=d*D+_*V+A*I,t[9]=p*D+g*V+x*I,t[10]=v*D+b*V+M*I,t[11]=f*D+m*V+O*I,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t)}function A(t,n,e){var r=Math.sin(e),o=Math.cos(e),i=n[4],a=n[5],s=n[6],c=n[7],l=n[8],h=n[9],u=n[10],d=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=i*o+l*r,t[5]=a*o+h*r,t[6]=s*o+u*r,t[7]=c*o+d*r,t[8]=l*o-i*r,t[9]=h*o-a*r,t[10]=u*o-s*r,t[11]=d*o-c*r,t}function x(t,n,e){var r=Math.sin(e),o=Math.cos(e),i=n[0],a=n[1],s=n[2],c=n[3],l=n[8],h=n[9],u=n[10],d=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=i*o-l*r,t[1]=a*o-h*r,t[2]=s*o-u*r,t[3]=c*o-d*r,t[8]=i*r+l*o,t[9]=a*r+h*o,t[10]=s*r+u*o,t[11]=c*r+d*o,t}function M(t,n,e){var r=Math.sin(e),o=Math.cos(e),i=n[0],a=n[1],s=n[2],c=n[3],l=n[4],h=n[5],u=n[6],d=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=i*o+l*r,t[1]=a*o+h*r,t[2]=s*o+u*r,t[3]=c*o+d*r,t[4]=l*o-i*r,t[5]=h*o-a*r,t[6]=u*o-s*r,t[7]=d*o-c*r,t}function O(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function T(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function w(t,n,e){var r=e[0],i=e[1],a=e[2],s=Math.sqrt(r*r+i*i+a*a),c=void 0,l=void 0,h=void 0;return Math.abs(s)<o.EPSILON?null:(s=1/s,r*=s,i*=s,a*=s,c=Math.sin(n),l=Math.cos(n),h=1-l,t[0]=r*r*h+l,t[1]=i*r*h+a*c,t[2]=a*r*h-i*c,t[3]=0,t[4]=r*i*h-a*c,t[5]=i*i*h+l,t[6]=a*i*h+r*c,t[7]=0,t[8]=r*a*h+i*c,t[9]=i*a*h-r*c,t[10]=a*a*h+l,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function y(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=e,t[7]=0,t[8]=0,t[9]=-e,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function S(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=0,t[2]=-e,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=e,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function E(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=0,t[3]=0,t[4]=-e,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function R(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=r+r,c=o+o,l=i+i,h=r*s,u=r*c,d=r*l,p=o*c,v=o*l,f=i*l,_=a*s,g=a*c,b=a*l;return t[0]=1-(p+f),t[1]=u+b,t[2]=d-g,t[3]=0,t[4]=u-b,t[5]=1-(h+f),t[6]=v+_,t[7]=0,t[8]=d+g,t[9]=v-_,t[10]=1-(h+p),t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function D(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function V(t,n){var e=n[0],r=n[1],o=n[2],i=n[4],a=n[5],s=n[6],c=n[8],l=n[9],h=n[10];return t[0]=Math.sqrt(e*e+r*r+o*o),t[1]=Math.sqrt(i*i+a*a+s*s),t[2]=Math.sqrt(c*c+l*l+h*h),t}function I(t,n){var e=n[0]+n[5]+n[10],r=0;return e>0?(r=2*Math.sqrt(e+1),t[3]=.25*r,t[0]=(n[6]-n[9])/r,t[1]=(n[8]-n[2])/r,t[2]=(n[1]-n[4])/r):n[0]>n[5]&n[0]>n[10]?(r=2*Math.sqrt(1+n[0]-n[5]-n[10]),t[3]=(n[6]-n[9])/r,t[0]=.25*r,t[1]=(n[1]+n[4])/r,t[2]=(n[8]+n[2])/r):n[5]>n[10]?(r=2*Math.sqrt(1+n[5]-n[0]-n[10]),t[3]=(n[8]-n[2])/r,t[0]=(n[1]+n[4])/r,t[1]=.25*r,t[2]=(n[6]+n[9])/r):(r=2*Math.sqrt(1+n[10]-n[0]-n[5]),t[3]=(n[1]-n[4])/r,t[0]=(n[8]+n[2])/r,t[1]=(n[6]+n[9])/r,t[2]=.25*r),t}function N(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=n[3],c=o+o,l=i+i,h=a+a,u=o*c,d=o*l,p=o*h,v=i*l,f=i*h,_=a*h,g=s*c,b=s*l,m=s*h,A=r[0],x=r[1],M=r[2];return t[0]=(1-(v+_))*A,t[1]=(d+m)*A,t[2]=(p-b)*A,t[3]=0,t[4]=(d-m)*x,t[5]=(1-(u+_))*x,t[6]=(f+g)*x,t[7]=0,t[8]=(p+b)*M,t[9]=(f-g)*M,t[10]=(1-(u+v))*M,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function P(t,n,e,r,o){var i=n[0],a=n[1],s=n[2],c=n[3],l=i+i,h=a+a,u=s+s,d=i*l,p=i*h,v=i*u,f=a*h,_=a*u,g=s*u,b=c*l,m=c*h,A=c*u,x=r[0],M=r[1],O=r[2],T=o[0],w=o[1],y=o[2];return t[0]=(1-(f+g))*x,t[1]=(p+A)*x,t[2]=(v-m)*x,t[3]=0,t[4]=(p-A)*M,t[5]=(1-(d+g))*M,t[6]=(_+b)*M,t[7]=0,t[8]=(v+m)*O,t[9]=(_-b)*O,t[10]=(1-(d+f))*O,t[11]=0,t[12]=e[0]+T-(t[0]*T+t[4]*w+t[8]*y),t[13]=e[1]+w-(t[1]*T+t[5]*w+t[9]*y),t[14]=e[2]+y-(t[2]*T+t[6]*w+t[10]*y),t[15]=1,t}function C(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e+e,s=r+r,c=o+o,l=e*a,h=r*a,u=r*s,d=o*a,p=o*s,v=o*c,f=i*a,_=i*s,g=i*c;return t[0]=1-u-v,t[1]=h+g,t[2]=d-_,t[3]=0,t[4]=h-g,t[5]=1-l-v,t[6]=p+f,t[7]=0,t[8]=d+_,t[9]=p-f,t[10]=1-l-u,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function L(t,n,e,r,o,i,a){var s=1/(e-n),c=1/(o-r),l=1/(i-a);return t[0]=2*i*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*i*c,t[6]=0,t[7]=0,t[8]=(e+n)*s,t[9]=(o+r)*c,t[10]=(a+i)*l,t[11]=-1,t[12]=0,t[13]=0,t[14]=a*i*2*l,t[15]=0,t}function j(t,n,e,r,o){var i=1/Math.tan(n/2),a=1/(r-o);return t[0]=i/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(o+r)*a,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*o*r*a,t[15]=0,t}function B(t,n,e,r){var o=Math.tan(n.upDegrees*Math.PI/180),i=Math.tan(n.downDegrees*Math.PI/180),a=Math.tan(n.leftDegrees*Math.PI/180),s=Math.tan(n.rightDegrees*Math.PI/180),c=2/(a+s),l=2/(o+i);return t[0]=c,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=l,t[6]=0,t[7]=0,t[8]=-(a-s)*c*.5,t[9]=(o-i)*l*.5,t[10]=r/(e-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*e/(e-r),t[15]=0,t}function U(t,n,e,r,o,i,a){var s=1/(n-e),c=1/(r-o),l=1/(i-a);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*l,t[11]=0,t[12]=(n+e)*s,t[13]=(o+r)*c,t[14]=(a+i)*l,t[15]=1,t}function F(t,n,e,r){var i=void 0,a=void 0,s=void 0,c=void 0,l=void 0,h=void 0,u=void 0,d=void 0,p=void 0,v=void 0,f=n[0],_=n[1],g=n[2],b=r[0],m=r[1],A=r[2],x=e[0],M=e[1],O=e[2];return Math.abs(f-x)<o.EPSILON&&Math.abs(_-M)<o.EPSILON&&Math.abs(g-O)<o.EPSILON?mat4.identity(t):(u=f-x,d=_-M,p=g-O,v=1/Math.sqrt(u*u+d*d+p*p),u*=v,d*=v,p*=v,i=m*p-A*d,a=A*u-b*p,s=b*d-m*u,v=Math.sqrt(i*i+a*a+s*s),v?(v=1/v,i*=v,a*=v,s*=v):(i=0,a=0,s=0),c=d*s-p*a,l=p*i-u*s,h=u*a-d*i,v=Math.sqrt(c*c+l*l+h*h),v?(v=1/v,c*=v,l*=v,h*=v):(c=0,l=0,h=0),t[0]=i,t[1]=c,t[2]=u,t[3]=0,t[4]=a,t[5]=l,t[6]=d,t[7]=0,t[8]=s,t[9]=h,t[10]=p,t[11]=0,t[12]=-(i*f+a*_+s*g),t[13]=-(c*f+l*_+h*g),t[14]=-(u*f+d*_+p*g),t[15]=1,t)}function k(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=r[0],c=r[1],l=r[2],h=o-e[0],u=i-e[1],d=a-e[2],p=h*h+u*u+d*d;p>0&&(p=1/Math.sqrt(p),h*=p,u*=p,d*=p);var v=c*d-l*u,f=l*h-s*d,_=s*u-c*h;return t[0]=v,t[1]=f,t[2]=_,t[3]=0,t[4]=u*_-d*f,t[5]=d*v-h*_,t[6]=h*f-u*v,t[7]=0,t[8]=h,t[9]=u,t[10]=d,t[11]=0,t[12]=o,t[13]=i,t[14]=a,t[15]=1,t}function W(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"}function G(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))}function H(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t[4]=n[4]+e[4],t[5]=n[5]+e[5],t[6]=n[6]+e[6],t[7]=n[7]+e[7],t[8]=n[8]+e[8],t[9]=n[9]+e[9],t[10]=n[10]+e[10],t[11]=n[11]+e[11],t[12]=n[12]+e[12],t[13]=n[13]+e[13],t[14]=n[14]+e[14],t[15]=n[15]+e[15],t}function Y(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t[4]=n[4]-e[4],t[5]=n[5]-e[5],t[6]=n[6]-e[6],t[7]=n[7]-e[7],t[8]=n[8]-e[8],t[9]=n[9]-e[9],t[10]=n[10]-e[10],t[11]=n[11]-e[11],t[12]=n[12]-e[12],t[13]=n[13]-e[13],t[14]=n[14]-e[14],t[15]=n[15]-e[15],t}function q(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*e,t[9]=n[9]*e,t[10]=n[10]*e,t[11]=n[11]*e,t[12]=n[12]*e,t[13]=n[13]*e,t[14]=n[14]*e,t[15]=n[15]*e,t}function z(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t[4]=n[4]+e[4]*r,t[5]=n[5]+e[5]*r,t[6]=n[6]+e[6]*r,t[7]=n[7]+e[7]*r,t[8]=n[8]+e[8]*r,t[9]=n[9]+e[9]*r,t[10]=n[10]+e[10]*r,t[11]=n[11]+e[11]*r,t[12]=n[12]+e[12]*r,t[13]=n[13]+e[13]*r,t[14]=n[14]+e[14]*r,t[15]=n[15]+e[15]*r,t}function X(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]}function J(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=t[4],c=t[5],l=t[6],h=t[7],u=t[8],d=t[9],p=t[10],v=t[11],f=t[12],_=t[13],g=t[14],b=t[15],m=n[0],A=n[1],x=n[2],M=n[3],O=n[4],T=n[5],w=n[6],y=n[7],S=n[8],E=n[9],R=n[10],D=n[11],V=n[12],I=n[13],N=n[14],P=n[15];return Math.abs(e-m)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(m))&&Math.abs(r-A)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(A))&&Math.abs(i-x)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(x))&&Math.abs(a-M)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(M))&&Math.abs(s-O)<=o.EPSILON*Math.max(1,Math.abs(s),Math.abs(O))&&Math.abs(c-T)<=o.EPSILON*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(l-w)<=o.EPSILON*Math.max(1,Math.abs(l),Math.abs(w))&&Math.abs(h-y)<=o.EPSILON*Math.max(1,Math.abs(h),Math.abs(y))&&Math.abs(u-S)<=o.EPSILON*Math.max(1,Math.abs(u),Math.abs(S))&&Math.abs(d-E)<=o.EPSILON*Math.max(1,Math.abs(d),Math.abs(E))&&Math.abs(p-R)<=o.EPSILON*Math.max(1,Math.abs(p),Math.abs(R))&&Math.abs(v-D)<=o.EPSILON*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(f-V)<=o.EPSILON*Math.max(1,Math.abs(f),Math.abs(V))&&Math.abs(_-I)<=o.EPSILON*Math.max(1,Math.abs(_),Math.abs(I))&&Math.abs(g-N)<=o.EPSILON*Math.max(1,Math.abs(g),Math.abs(N))&&Math.abs(b-P)<=o.EPSILON*Math.max(1,Math.abs(b),Math.abs(P))}n.mul=_,n.sub=Y},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setAxes=n.sqlerp=n.rotationTo=n.equals=n.exactEquals=n.normalize=n.sqrLen=n.squaredLength=n.len=n.length=n.lerp=n.dot=n.scale=n.mul=n.add=n.set=n.copy=n.fromValues=n.clone=void 0,n.create=d,n.identity=p,n.setAxisAngle=v,n.getAxisAngle=f,n.multiply=_,n.rotateX=g,n.rotateY=b,n.rotateZ=m,n.calculateW=A,n.slerp=x,n.invert=M,n.conjugate=O,n.fromMat3=T,n.fromEuler=w,n.str=y;var r=e(0),o=u(r),i=e(1),a=u(i),s=e(2),c=u(s),l=e(3),h=u(l);function u(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function d(){var t=new o.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function p(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function v(t,n,e){e*=.5;var r=Math.sin(e);return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=Math.cos(e),t}function f(t,n){var e=2*Math.acos(n[3]),r=Math.sin(e/2);return 0!=r?(t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r):(t[0]=1,t[1]=0,t[2]=0),e}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],c=e[1],l=e[2],h=e[3];return t[0]=r*h+a*s+o*l-i*c,t[1]=o*h+a*c+i*s-r*l,t[2]=i*h+a*l+r*c-o*s,t[3]=a*h-r*s-o*c-i*l,t}function g(t,n,e){e*=.5;var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c+a*s,t[1]=o*c+i*s,t[2]=i*c-o*s,t[3]=a*c-r*s,t}function b(t,n,e){e*=.5;var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c-i*s,t[1]=o*c+a*s,t[2]=i*c+r*s,t[3]=a*c-o*s,t}function m(t,n,e){e*=.5;var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c+o*s,t[1]=o*c-r*s,t[2]=i*c+a*s,t[3]=a*c-i*s,t}function A(t,n){var e=n[0],r=n[1],o=n[2];return t[0]=e,t[1]=r,t[2]=o,t[3]=Math.sqrt(Math.abs(1-e*e-r*r-o*o)),t}function x(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=n[3],c=e[0],l=e[1],h=e[2],u=e[3],d=void 0,p=void 0,v=void 0,f=void 0,_=void 0;return p=o*c+i*l+a*h+s*u,p<0&&(p=-p,c=-c,l=-l,h=-h,u=-u),1-p>1e-6?(d=Math.acos(p),v=Math.sin(d),f=Math.sin((1-r)*d)/v,_=Math.sin(r*d)/v):(f=1-r,_=r),t[0]=f*o+_*c,t[1]=f*i+_*l,t[2]=f*a+_*h,t[3]=f*s+_*u,t}function M(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e*e+r*r+o*o+i*i,s=a?1/a:0;return t[0]=-e*s,t[1]=-r*s,t[2]=-o*s,t[3]=i*s,t}function O(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t}function T(t,n){var e=n[0]+n[4]+n[8],r=void 0;if(e>0)r=Math.sqrt(e+1),t[3]=.5*r,r=.5/r,t[0]=(n[5]-n[7])*r,t[1]=(n[6]-n[2])*r,t[2]=(n[1]-n[3])*r;else{var o=0;n[4]>n[0]&&(o=1),n[8]>n[3*o+o]&&(o=2);var i=(o+1)%3,a=(o+2)%3;r=Math.sqrt(n[3*o+o]-n[3*i+i]-n[3*a+a]+1),t[o]=.5*r,r=.5/r,t[3]=(n[3*i+a]-n[3*a+i])*r,t[i]=(n[3*i+o]+n[3*o+i])*r,t[a]=(n[3*a+o]+n[3*o+a])*r}return t}function w(t,n,e,r){var o=.5*Math.PI/180;n*=o,e*=o,r*=o;var i=Math.sin(n),a=Math.cos(n),s=Math.sin(e),c=Math.cos(e),l=Math.sin(r),h=Math.cos(r);return t[0]=i*c*h-a*s*l,t[1]=a*s*h+i*c*l,t[2]=a*c*l-i*s*h,t[3]=a*c*h+i*s*l,t}function y(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}n.clone=h.clone,n.fromValues=h.fromValues,n.copy=h.copy,n.set=h.set,n.add=h.add,n.mul=_,n.scale=h.scale,n.dot=h.dot,n.lerp=h.lerp;var S=n.length=h.length,E=(n.len=S,n.squaredLength=h.squaredLength),R=(n.sqrLen=E,n.normalize=h.normalize);n.exactEquals=h.exactEquals,n.equals=h.equals,n.rotationTo=function(){var t=c.create(),n=c.fromValues(1,0,0),e=c.fromValues(0,1,0);return function(r,o,i){var a=c.dot(o,i);return a<-.999999?(c.cross(t,n,o),c.len(t)<1e-6&&c.cross(t,e,o),c.normalize(t,t),v(r,t,Math.PI),r):a>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(c.cross(t,o,i),r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=1+a,R(r,r))}}(),n.sqlerp=function(){var t=d(),n=d();return function(e,r,o,i,a,s){return x(t,r,a,s),x(n,o,i,s),x(e,t,n,2*s*(1-s)),e}}(),n.setAxes=function(){var t=a.create();return function(n,e,r,o){return t[0]=r[0],t[3]=r[1],t[6]=r[2],t[1]=o[0],t[4]=o[1],t[7]=o[2],t[2]=-e[0],t[5]=-e[1],t[8]=-e[2],R(n,T(n,t))}}()},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.sqrDist=n.dist=n.div=n.mul=n.sub=n.len=void 0,n.create=a,n.clone=s,n.fromValues=c,n.copy=l,n.set=h,n.add=u,n.subtract=d,n.multiply=p,n.divide=v,n.ceil=f,n.floor=_,n.min=g,n.max=b,n.round=m,n.scale=A,n.scaleAndAdd=x,n.distance=M,n.squaredDistance=O,n.length=T,n.squaredLength=w,n.negate=y,n.inverse=S,n.normalize=E,n.dot=R,n.cross=D,n.lerp=V,n.random=I,n.transformMat2=N,n.transformMat2d=P,n.transformMat3=C,n.transformMat4=L,n.str=j,n.exactEquals=B,n.equals=U;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t}function s(t){var n=new o.ARRAY_TYPE(2);return n[0]=t[0],n[1]=t[1],n}function c(t,n){var e=new o.ARRAY_TYPE(2);return e[0]=t,e[1]=n,e}function l(t,n){return t[0]=n[0],t[1]=n[1],t}function h(t,n,e){return t[0]=n,t[1]=e,t}function u(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t}function d(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t}function p(t,n,e){return t[0]=n[0]*e[0],t[1]=n[1]*e[1],t}function v(t,n,e){return t[0]=n[0]/e[0],t[1]=n[1]/e[1],t}function f(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t}function _(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t}function g(t,n,e){return t[0]=Math.min(n[0],e[0]),t[1]=Math.min(n[1],e[1]),t}function b(t,n,e){return t[0]=Math.max(n[0],e[0]),t[1]=Math.max(n[1],e[1]),t}function m(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t}function A(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t}function x(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t}function M(t,n){var e=n[0]-t[0],r=n[1]-t[1];return Math.sqrt(e*e+r*r)}function O(t,n){var e=n[0]-t[0],r=n[1]-t[1];return e*e+r*r}function T(t){var n=t[0],e=t[1];return Math.sqrt(n*n+e*e)}function w(t){var n=t[0],e=t[1];return n*n+e*e}function y(t,n){return t[0]=-n[0],t[1]=-n[1],t}function S(t,n){return t[0]=1/n[0],t[1]=1/n[1],t}function E(t,n){var e=n[0],r=n[1],o=e*e+r*r;return o>0&&(o=1/Math.sqrt(o),t[0]=n[0]*o,t[1]=n[1]*o),t}function R(t,n){return t[0]*n[0]+t[1]*n[1]}function D(t,n,e){var r=n[0]*e[1]-n[1]*e[0];return t[0]=t[1]=0,t[2]=r,t}function V(t,n,e,r){var o=n[0],i=n[1];return t[0]=o+r*(e[0]-o),t[1]=i+r*(e[1]-i),t}function I(t,n){n=n||1;var e=2*o.RANDOM()*Math.PI;return t[0]=Math.cos(e)*n,t[1]=Math.sin(e)*n,t}function N(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[2]*o,t[1]=e[1]*r+e[3]*o,t}function P(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[2]*o+e[4],t[1]=e[1]*r+e[3]*o+e[5],t}function C(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[3]*o+e[6],t[1]=e[1]*r+e[4]*o+e[7],t}function L(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[4]*o+e[12],t[1]=e[1]*r+e[5]*o+e[13],t}function j(t){return"vec2("+t[0]+", "+t[1]+")"}function B(t,n){return t[0]===n[0]&&t[1]===n[1]}function U(t,n){var e=t[0],r=t[1],i=n[0],a=n[1];return Math.abs(e-i)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(r-a)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(a))}n.len=T,n.sub=d,n.mul=p,n.div=v,n.dist=M,n.sqrDist=O,n.sqrLen=w,n.forEach=function(){var t=a();return function(n,e,r,o,i,a){var s=void 0,c=void 0;for(e||(e=2),r||(r=0),c=o?Math.min(o*e+r,n.length):n.length,s=r;s<c;s+=e)t[0]=n[s],t[1]=n[s+1],i(t,t,a),n[s]=t[0],n[s+1]=t[1];return n}}()}])}))},cff6:function(t,n,e){t.exports=e.p+"static/img/coord2.d710514a.png"},d733:function(t,n,e){"use strict";e("3d36")},de67:function(t,n,e){t.exports=e.p+"static/img/matrix2.c2c586e0.png"},e891:function(t,n,e){"use strict";e("9c9c")}});
(function(t){function n(n){for(var r,a,s=n[0],c=n[1],l=n[2],h=0,u=[];h<s.length;h++)a=s[h],Object.prototype.hasOwnProperty.call(o,a)&&o[a]&&u.push(o[a][0]),o[a]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(t[r]=c[r]);d&&d(n);while(u.length)u.shift()();return i.push.apply(i,l||[]),e()}function e(){for(var t,n=0;n<i.length;n++){for(var e=i[n],r=!0,s=1;s<e.length;s++){var c=e[s];0!==o[c]&&(r=!1)}r&&(i.splice(n--,1),t=a(a.s=e[0]))}return t}var r={},o={app:0},i=[];function a(n){if(r[n])return r[n].exports;var e=r[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,a),e.l=!0,e.exports}a.m=t,a.c=r,a.d=function(t,n,e){a.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:e})},a.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},a.t=function(t,n){if(1&n&&(t=a(t)),8&n)return t;if(4&n&&"object"===typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(a.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var r in t)a.d(e,r,function(n){return t[n]}.bind(null,r));return e},a.n=function(t){var n=t&&t.__esModule?function(){return t["default"]}:function(){return t};return a.d(n,"a",n),n},a.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},a.p="/hh-render/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=n,s=s.slice();for(var l=0;l<s.length;l++)n(s[l]);var d=c;i.push([0,"chunk-vendors"]),e()})({0:function(t,n,e){t.exports=e("56d7")},"0b6d":function(t,n,e){t.exports=e.p+"static/img/matrix1.bb4340c6.png"},"0f9f":function(t,n,e){"use strict";e("859d")},"11d9":function(t,n,e){t.exports=e.p+"static/img/3.5c73f25e.jpg"},"1a33":function(t,n,e){"use strict";e("838c")},"1aa6":function(t,n,e){t.exports=e.p+"static/img/matrix.57e09dd0.png"},"1be7":function(t,n,e){},2487:function(t,n,e){},"2b08":function(t,n,e){},3260:function(t,n,e){t.exports=e.p+"static/img/vector1.73452b9b.png"},"34a5":function(t,n,e){t.exports=e.p+"static/img/coord1.5b2ba5f4.png"},"3b73":function(t,n,e){"use strict";e("cdd0")},"3d36":function(t,n,e){},"405a":function(t,n,e){t.exports=e.p+"static/img/2.5debf06e.jpg"},"52fe":function(t,n,e){},"56d7":function(t,n,e){"use strict";e.r(n);e("0fae");var r=e("9e2f"),o=e.n(r),i=e("2b0e"),a=function(){var t=this,n=t._self._c;return n("div",{attrs:{id:"app"}},[n("section",{attrs:{id:"nav"}},t._l(t.routeList,(function(e){return n("router-link",{key:e.path,attrs:{to:e.path}},[t._v(t._s(e.name))])})),1),n("section",{attrs:{id:"content"}},[n("router-view")],1)])},s=[],c=(e("0643"),e("2382"),{name:"App",components:{},data(){return{routeList:[]}},mounted(){this.init()},methods:{init(){const{options:t}=this.$router;let n=t.routes.filter(t=>"/"!==t.path);this.routeList=n}}}),l=c,d=(e("1a33"),e("2877")),h=Object(d["a"])(l,a,s,!1,null,null,null),u=h.exports,p=e("8c4f"),v=function(){var t=this;t._self._c;return t._m(0)},f=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"home"},[n("p",[t._v("GLSL ES 3.00")]),t._v(" 中文手册 https://github.com/adodo0829/GLSL-Card 游戏引擎 https://github.com/ThisisGame/cpp-game-engine-book "),n("pre",[n("h3",[t._v("基本结构")]),t._v("\n预处理器指令：\n#version 300 es：指定着色器语言的版本。\n变量类型：\n\n基本数据类型：float, int, bool, vec2, vec3, vec4, mat2, mat3, mat4, sampler2D 等。\n限定词：in, out, inout（仅在函数参数中使用）。\n主函数：\n\nvoid main()：着色器程序的入口点。\n\n"),n("h3",[t._v("输入和输出")]),t._v("\nin：用于顶点着色器的输入和片段着色器的输出。\nout：用于顶点着色器的输出和片段着色器的输入。\n\n"),n("h3",[t._v("Uniforms")]),t._v("\nUniform变量：\n用于在应用程序和着色器之间传递数据。\n声明方式：uniform type name;\n\nuniform 用来修饰统一变量。\nGPU是并行的，Shader是执行在GPU上的程序。\n当我们需要绘制3个顶点，GPU将3个顶点数据，分摊到3个GPU逻辑单元并行处理，每个逻辑单元处理的不同的顶点坐标数据，称之为属性变量。\n每个逻辑单元也会需要一些相同的数据，这些相同的数据，称之为统一变量。\nuniform mat4 u_mvp;\n\n"),n("p",[t._v("es2.0语法")]),t._v("\nattribute 表示这个变量，每执行一次Shader，都需要被赋值\nattribute vec3 a_pos;\nattribute vec4 a_color;\n输出变量由varying关键字修饰，用于从顶点着色器，传递数据到片段着色器\nvarying vec4 v_color;\n\n"),n("h3",[t._v("布局限定词")]),t._v("\n位置：\nlayout(location = N)：指定变量在属性数组中的位置。\n接口块：\n使用in和out关键字定义块，用于组织和传递复杂的数据结构。\n\n"),n("h3",[t._v("构造函数")]),t._v("\n支持多种构造函数，例如：vec4(float x, float y, float z, float w)。\n\n"),n("h3",[t._v("控制流")]),t._v("\n条件语句：if, else。\n循环语句：for, while。\n\n"),n("h3",[t._v("函数")]),t._v("\n支持用户定义函数。\n内置函数：如sin, cos, pow等。\n\n"),n("h3",[t._v("精度限定词")]),t._v("\n精度限定词：\nhighp, mediump, lowp：指定变量或uniform的精度。\n\n"),n("h3",[t._v("纹理采样和处理")]),t._v("\n纹理函数：\ntexture, texture2D, textureCube等。\n\n"),n("h3",[t._v("构造几何形状")]),t._v("\n几何着色器：\n可以定义几何着色器来处理几何图形的顶点。\n\n"),n("h3",[t._v("变换反馈：")]),t._v("\n允许着色器将数据直接输出到缓冲区。\n    ")]),n("div",[t._v("内置函数")]),n("pre",[t._v("\nGLSL ES 3.00支持的内置函数非常丰富，涵盖了数学运算、几何函数、矩阵操作、纹理查询等多个方面。\n以下是一些主要的内置函数类别及其部分代表函数：\n\n### 1. 角度和三角函数\n- `radians(d)`：将角度转换为弧度。\n- `degrees(r)`：将弧度转换为角度。\n- `sin(x)`：正弦函数。\n- `cos(x)`：余弦函数。\n- `tan(x)`：正切函数。\n- `asin(x)`：反正弦函数。\n- `acos(x)`：反余弦函数。\n- `atan(x)`：反正切函数。\n- `atan(x, y)`：双参数反正切函数。\n\n### 2. 指数函数\n- `pow(x, y)`：幂函数。\n- `exp(x)`：指数函数。\n- `log(x)`：自然对数。\n- `exp2(x)`：以2为底的指数函数。\n- `log2(x)`：以2为底的对数。\n\n### 3. 通用函数\n- `abs(x)`：绝对值。\n- `sign(x)`：符号函数。\n- `floor(x)`：向下取整。\n- `ceil(x)`：向上取整。\n- `fract(x)`：取小数部分。\n- `mod(x, y)`：取模。\n- `min(x, y)`：最小值。\n- `max(x, y)`：最大值。\n- `clamp(x, minVal, maxVal)`：将x限制在[minVal, maxVal]之间。\n- `mix(x, y, a)`：线性插值。\n- `step(edge, x)`：阶梯函数。\n- `smoothstep(edge0, edge1, x)`：平滑阶梯函数。\n\n### 4. 浮点数打包和解包函数\n- `packHalf2x16(v)`：将两个16位半精度浮点数打包成一个32位无符号整数。\n- `unpackHalf2x16(v)`：将一个32位无符号整数解包成两个16位半精度浮点数。\n\n### 5. 几何函数\n- `length(v)`：向量v的长度。\n- `distance(p0, p1)`：两点之间的距离。\n- `dot(x, y)`：向量x和y的点积。\n- `cross(x, y)`：向量x和y的叉积。\n- `normalize(v)`：向量v的单位向量。\n- `faceforward(N, I, Nref)`：根据法线N和参考向量Nref调整向量I的方向。\n- `reflect(I, N)`：向量I关于法线N的反射。\n- `refract(I, N, eta)`：向量I在法线N上的折射，其中eta是折射率。\n\n### 6. 矩阵函数\n- 矩阵的构造函数，如`mat2`, `mat3`, `mat4`。\n- `matrixCompMult(x, y)`：矩阵逐元素乘法。\n- `outerProduct(a, b)`：计算两个向量的外积。\n- `transpose(m)`：矩阵转置。\n- `inverse(m)`：矩阵求逆。\n\n### 7. 向量关系函数\n- `lessThan(x, y)`：逐元素比较x和y是否小于。\n- `greaterThan(x, y)`：逐元素比较x和y是否大于。\n- `equal(x, y)`：逐元素比较x和y是否相等。\n- `notEqual(x, y)`：逐元素比较x和y是否不相等。\n\n### 8. 纹理查询函数\n- `texture(sampler, P)`：从纹理采样器sampler中获取纹理坐标P处的颜色。\n- `textureLod(sampler, P, lod)`：从纹理采样器sampler中获取指定层次lod处的纹理坐标P处的颜色。\n- `textureProj(sampler, P)`：进行投影纹理采样。\n- `textureGrad(sampler, P, dPdx, dPdy)`：使用显式梯度进行纹理采样。\n    ")]),n("h3",[t._v("顶点着色器")]),n("p",[n("pre",[t._v("void main()\n{\n    gl_Position = vec4(vPos, 1.0);\n}\n\t\t")]),t._v(" 每个Shader都有入口函数 main()，顶点Shader主要工作就是：计算坐标。 得到坐标计算结果后，传给内置变量 gl_Position。 ")]),n("p",[t._v("在线测试 https://thebookofshaders.com/edit.php")]),n("pre",[t._v("  export const vertexString = `\n    #version 300 es\n    // 指定currVertexAndRatio变量在顶点属性数组中的位置是1\n\tlayout(location=1) in vec4 currVertexAndRatio;\t\t\t// 顶点坐标和变形系数\n\tlayout(location=2) in vec4 prevVertexAndRatio;\n\tlayout(location=3) in vec4 nextVertexAndRatio;\n\tlayout(location=4) in vec4 uvAndEdgeOffsetRatio;\t\t// UV\n\tlayout(location=5) in vec4 vertexAndEdgeOffsetValueAndNotFollowViewport;\t// 顶点形变  边形变值  是否不跟随视口\n\tlayout(location=6) in vec4 UVRect;\t\t\t\t\t\t// UVRect\n\tlayout(location=7) in vec4 backgroundColor;\t\t\t\t// 背景色\n\tlayout(location=8) in vec4 translationAndRotation;\t\t// 形变\n\tlayout(location=9) in vec4 isTextAndBorderWidthAndDashedAndScale;\t\t// 是否渲染文字 以及 文字边框粗细 以及物体边框虚线 缩放\n\tlayout(location=10) in vec4 textBorderColor;\t\t\t// 文字边框颜色\n\tlayout(location=11) in vec4 opacityAndDisplayAndVpScaleAndVpTrans;\t\t\t// 透明度 是否显示 是否跟随视口缩放 是否跟随视口平移\n    \n    // out是从顶点着色器传递到片段着色器（用于处理像素颜色）的数据\n\tout vec2 vTexCoord;\t\t\t\t// UV\n\tout vec4 vBgColor;\n\tout float vIsText;\n\tout float vTextBorderWidth;\n\tout vec4 vTextBorderColor;\n\tout float vHasTexture;\n\tout vec4 vPos;\n\tout float vNotBorder;\n\tout float vBorderDashed;\n\tout float vOpacity;\n\tout float vDisplay;\n\n  // 应用程序和着色器之间传递传递参数\n\tuniform vec2 uConversionVec2;\t//坐标转换\n\tuniform vec2 uViewportTranslation;\t//视口平移\n\tuniform vec2 uViewportScale;\t\t//视口缩放\n\tuniform float uViewportRotation;\t//视口旋转\n\tuniform vec4 uOpacity;\t\t\t\t//全局透明度\n\n\tmat4 getScaleMatrix(vec2 scale) {\n\t\treturn mat4(\n\t\t\tscale.x, 0.0, 0.0, 0.0,\n\t\t\t0.0, scale.y, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getRotationMatrix(float radian) {\n\t\tfloat cost = cos(radian);\n\t\tfloat sint = sin(radian);\n\t\treturn mat4(\n\t\t\tcost, -sint, 0.0, 0.0,\n\t\t\tsint, cost, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getTranslationMatrix(vec2 translation) {\n\t\treturn mat4(\n\t\t\t1.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\ttranslation.x, translation.y, 0.0, 1.0\n\t\t);\n\t}\n\n    // 找到两个向量夹角平分线上的一个特定点，这个点距离每个向量的端点都是 offset 距离\n\tvec2 getIntersectionVertex(\n\t\tin vec2 v1,\n\t\tin vec2 v2,\n\t\tin float offset\n\t) {\n\t\tvec4 vv1 = vec4(v1, 0.0, 1.0);\n\t\tvec4 vv2 = vec4(v2, 0.0, 1.0);\n\t\t// 向量夹角\n\t\tvec2 mid = normalize(normalize(v1) + normalize(v2));\n\t\tfloat theta = acos(dot(v1, v2) / (length(v1) * length(v2)));\n\t\t// 右手法则，判断夹角正负\n\t\tvec3 c = cross(vv1.xyz, vv2.xyz);\n\t\tfloat l = offset / sin(theta * 0.5);\n\t\treturn mid * l * (- sign(c.z));\n\t}\n\n    // 将一个点按照给定的比率和值进行偏移，用于创建动画、调整对象位置\n\tvec2 getVertex(\n\t\tin vec2 origin,\n\t\tin vec2 offsetRatio,\n\t\tin vec2 offsetValue\n\t) {\n\t\tvec2 offset = offsetRatio * offsetValue;\n\t\treturn origin + offset;\n\t}\n   \n\tvec2 getFollowViewport() {\n\t\tfloat outViewportStatus = vertexAndEdgeOffsetValueAndNotFollowViewport.w;  // 跟随视口状态\t\n\t\tvec3 f = vec3(outViewportStatus - 1.0, outViewportStatus - 2.0, outViewportStatus - 3.0);\n\t\tf = step(vec3(0.5, 0.5, 0.5), abs(f));\n\t\treturn vec2(f.x * f.z, f.y * f.z);\n\t}\n\n\t// 获取缩放矢量\n\tvec2 getScaleVec(float scale, vec2 followViewport, vec2 notFollowViewport) {\n\t\tvec2 scaleVec = vec2(scale, scale);\n\t\tvec2 isVpScale = vec2(1.0, 1.0) - opacityAndDisplayAndVpScaleAndVpTrans.zz;\n\t\tvec2 dscaleVec = vec2(1.0, 1.0) / uViewportScale * scaleVec * isVpScale + scaleVec * (1.0-isVpScale);\n\t\treturn dscaleVec * followViewport + scaleVec * notFollowViewport;\n\t}\n\n\tvoid main(void) {\n\t\tvec2 pv = getVertex(prevVertexAndRatio.xy, prevVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 cv = getVertex(currVertexAndRatio.xy, currVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 nv = getVertex(nextVertexAndRatio.xy, nextVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 pe = pv - cv;\n\t\tvec2 ne = nv - cv;\n\n\t\t// 判断是否需要乘视口矩阵\n\t\tvec2 followViewport = getFollowViewport();\n\t\tvec2 notFollowViewport = vec2(1.0, 1.0) - followViewport;\n\n\t\t// 各种矩阵\n\t\tmat4 rotationMatrix = getRotationMatrix(translationAndRotation.z);\n\t\t// 缩放矩阵，如果设置了脱离视口，则需要计算一个反向缩放矩阵\n\t\tmat4 scaleMatrix = getScaleMatrix(getScaleVec(isTextAndBorderWidthAndDashedAndScale.w, followViewport, notFollowViewport));\n\t\tmat4 transMat = getTranslationMatrix(translationAndRotation.xy);\n\t\tmat4 converMat = getScaleMatrix(uConversionVec2.xy);\n\t\t// 视口矩阵\n\t\tmat4 vpScaleMatrix = getScaleMatrix(uViewportScale);\n\t\tmat4 vpTranslationMatrix = getTranslationMatrix(uViewportTranslation);\n\t\tmat4 vpRotationMatrix = getRotationMatrix(uViewportRotation);\n\t\tmat4 vpMat = vpTranslationMatrix * vpScaleMatrix * converMat * vpRotationMatrix;\n\n\t\t// 求相邻两边交点向量\n\t\tvec2 intersection = getIntersectionVertex(pe, ne, vertexAndEdgeOffsetValueAndNotFollowViewport.z * uvAndEdgeOffsetRatio.z);\n\n\t\tvec4 posOrigin = transMat * scaleMatrix * rotationMatrix * vec4(cv, 0.0, 1.0);\n\t\tvec4 posBorder = rotationMatrix * vec4(intersection, 0.0, 0.0);\n\t\tposBorder = converMat * vec4(vec2(vpRotationMatrix * posBorder) * followViewport + posBorder.xy * notFollowViewport, 0, 0);\n\t\tposOrigin = vec4(vec2(vpMat * posOrigin) * followViewport + vec2(converMat * posOrigin) * notFollowViewport, 0.0, 1.0);\n\n\t\tgl_Position = posOrigin + posBorder;\n\n\t\t// out\n\t\t// 如果材质宽度为0 则标志为无材质\n\t\tvHasTexture = step(0.0, UVRect.z);\n\t\tvTexCoord = uvAndEdgeOffsetRatio.xy * UVRect.zw + UVRect.xy;\n\t\tvBgColor = backgroundColor;\n\t\tvIsText = isTextAndBorderWidthAndDashedAndScale.x;\n\t\tvTextBorderWidth = isTextAndBorderWidthAndDashedAndScale.y;\n\t\tvTextBorderColor = textBorderColor;\n\t\tvNotBorder = step(vertexAndEdgeOffsetValueAndNotFollowViewport.z, 0.0);\n\n\t\tvPos = rotationMatrix * vec4(cv, 0.0, 1.0); // 用于边框渲染计算\n\t\tvPos = vec4(vec2(vpRotationMatrix * vPos) * followViewport + vPos.xy * notFollowViewport, 0.0, 1.0);\n\n\t\tvBorderDashed = isTextAndBorderWidthAndDashedAndScale.z;\n\t\tvOpacity = opacityAndDisplayAndVpScaleAndVpTrans.x * uOpacity.x;\n\t\tvDisplay = opacityAndDisplayAndVpScaleAndVpTrans.y;\n\t}\n`;\n")]),n("h3",[t._v("片段着色器")]),n("pre",[t._v("片段着色器(像素着色器)的功能就是：输出颜色；\nvarying vec4 v_color;\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n\n片段着色器(像素着色器)也是并行的，不过执行的次数不是顶点个数，而是屏幕像素个数。\n假如绘制一个960x540的长方形，每一个像素点的颜色，都是通过执行一次片段着色器来得到，那么GPU需要执行960x540次\n\n顶点数越多，顶点着色器执行次数越多。\n屏幕分辨率越高，片段着色器执行次数越多。\n这里可以推出手游常见的两种优化方式：减少顶点、降低分辨率\n\n绘制一个200x200 左右大小的正方形\n正方形四个顶点，顶点着色器只需要执行4次，而面对200x200个像素，片段着色器，需要执行200x200次。\n只有正方形四个顶点的那四个像素，才能直接从顶点着色器拿到颜色数据，那中间的像素颜色数据从哪里来？\n\n插值\n中间的像素颜色，都是插值得到的。\n\n左上角顶点颜色是红色，右上角顶点颜色是蓝色，可以看到中间颜色是由红色、蓝色插值混合而成。\n\n注意：所有从顶点着色器输出到片段着色器的数据，都会插值\n\nexport const fragmentString = `\n  #version 300 es\n\tprecision mediump float;\n\tuniform sampler2D uSampler;\n\t// uniform vec2 uConversionVec2;\t// 坐标转换\n\tin vec2 vTexCoord; // 从顶点着色器传入的纹理坐标\n\tin vec4 vBgColor; // 从顶点着色器传入的背景颜色\n\tin float vIsText;\n\tin float vTextBorderWidth;\n\tin vec4 vTextBorderColor;\n\tin float vHasTexture;\n\tin vec4 vPos;\n\tin float vNotBorder;\n\tin float vBorderDashed;\n\tin float vOpacity;\n\tin float vDisplay;\n\tout vec4 fragColor; // 片段着色器的输出颜色，将被用于最终的像素颜色\n\n    // 确定一个片段是否应该被渲染为虚线边框的一部分\n\tfloat inBorderDashed() {\n\t\t// 是否绘制虚线\n\t\tfloat hasDashed = 1.0 - step(vBorderDashed, 0.0);\n\t\tvec2 fw = fwidth(vPos.xy);\n\t\tfloat k = fw.y * (1.0/fw.x);\n\t\t// 如果k在 0.95 和 1.05 之间\n\t\tfloat c1 = step(0.95, k) * step(k, 1.05);\n\t\t// 如果 c1 == 0.1 则 c2 = 0.0 否则 c2 = 1.0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 如果 c1 条件成立 则 gl_FragCoord.x 否则 ...\n\t\tfloat d = gl_FragCoord.x * c1 + (step(1.0, k) * gl_FragCoord.y + step(k, 1.0) * gl_FragCoord.x) * c2;\n\t\treturn step(mod(floor( d * (1.0/vBorderDashed) ), 2.0), 0.0) * hasDashed;\n\t}\n\n\tvec4 drawText(vec4 texture) {\n\t\t// 文字边框是否大于0\n\t\tfloat c1 = step(0.1, vTextBorderWidth);\n\t\t// 文字边框是否小于等于0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 第一个插值阶梯\n\t\tfloat start = max(0.0, 0.5 - vTextBorderWidth * 0.1);\n\t\t// 边框插值系数\n\t\tfloat r1 = smoothstep(start, start + 0.2, texture.r) * c1;\n\t\t// 文字插值系数\n\t\tfloat r2 = smoothstep(0.5, 0.85, texture.r);\n\n\t\treturn vec4(mix(vTextBorderColor.rgb, vBgColor.rgb, r2), r2+(1.0-r2)*r1);\n\t}\n\n\tvec4 drawNormal(vec4 texture, vec4 bgColor) {\n\t\tfloat a1 = texture.a * vHasTexture;\n\t\tfloat a2 = bgColor.a;\n\t\treturn vec4(mix(bgColor.rgb, texture.rgb, a1), a1+(1.0-a1)*a2);\n\t}\n\n\tvoid main(void) {\n        // 丢弃不显示的片段\n\t\tif(vDisplay == 0.0 || vOpacity == 0.0) {\n\t\t\tdiscard;\n\t\t\treturn;\n\t\t}\n\n\t\t// ib == 0.0 则正常渲染， ib == 1.0 则渲染反色\n\t\tfloat ib = inBorderDashed();\n\t\tvec4 bgColor = vec4(vBgColor.rgb * (1.0 - ib) + (vec3(1.0, 1.0, 1.0) - vBgColor.rgb) * ib, vBgColor.a);\n\n\t\t// 材质\n\t\tvec4 tColor = texture(uSampler, vTexCoord);\n\t\t// 绘制字体\n\t\tvec4 textColor = drawText(tColor);\n\t\t// 绘制普通对象\n\t\tvec4 normalColor = drawNormal(tColor, bgColor);\n\n\t\tvec4 color = vIsText * textColor + (1.0 - vIsText) * normalColor;\n\t\tcolor.a *= vOpacity;\n\t\tfragColor = color;\n\t}\n`;\n")]),n("div",[n("h3",[t._v("贴图显示逻辑")]),n("pre",[t._v("顶点色能做到的效果有限，所以有另一套机制:UV坐标。\nUV坐标指的是顶点对应在图片的哪个位置，仍旧拿上面的效果举例，4个顶点(左下、右下、右上、左上)分别和图片的4个角对应，那么UV坐标就是下面这样:\n\nstatic const glm::vec3 Positions[6] =\n{\n    //第一个三角形\n    { -1.0f, -1.0f, 0.0f},//左下\n    {  1.0f, -1.0f, 0.0f},//右下\n    {  1.0f,  1.0f, 0.0f},//右上\n    //第二个三角形\n    {  1.0f,  1.0f, 0.0f},//右上\n    { -1.0f,  1.0f, 0.0f},//左上\n    { -1.0f, -1.0f, 0.0f} //左下\n};\nstatic const glm::vec2 UVs[6] = \n{\n    //第一个三角形\n    {  0.0f,  0.0f},//左下\n    {  1.0f,  0.0f},//右下\n    {  1.0f,  1.0f},//右上\n    //第二个三角形\n    {  1.0f,  1.0f},//右上\n    {  0.0f,  1.0f},//左上\n    {  0.0f,  0.0f} //左下\n}\n\nUV坐标范围是[0,1]；顶点坐标和图片对应起来的操作，一般叫做UV映射\n\t")])]),n("section",[n("pre",[t._v("CPU与GPU的通信方式：\n\nCPU和GPU是一种CS模式，即客户端-服务器模式。\n客户端不能直接访问服务器资源，客户端想对服务器资源进行操作，只能通过网络协议交互，由服务器进行操作。\nCPU就是客户端，GPU就是服务器。\n\n上传图片数据到显卡分为几步\n1   glGenTextures\t通知显卡创建纹理对象，返回句柄;\n2\tglBindTexture\t将纹理绑定到特定纹理目标;\n3\tglTexImage2D\t将图片rgb数据上传到GPU;\n\n上面的API都是阻塞式的。\n所以在游戏中，需要减小图片尺寸减少上传时间，需要打包图集减少上传次数\n\n")])]),n("pre",[t._v("引擎主循环每执行一次，都需要上传顶点数据到GPU\n在实际项目中是不可行的，游戏同屏顶点数普遍超过10w，每一帧都上传10w顶点数据到GPU，想想都可怕。\n\n针对性的优化有2点：\n1.减少上传数据量---- 顶点索引\n2.在GPU上缓存数据---- 缓冲区对象\n\n\n顶点坐标数据是一个数组，那么顶点索引就是这个数组的index; 将顶点坐标去重，然后新建数组存储下标\n一个顶点，包含了顶点坐标、顶点颜色、UV坐标这三个数据\n使用顶点索引(kVertexIndexVector)进行绘制，需要引入新的API - glDrawElements\n\nglDrawElements 通过顶点索引进行绘制，大幅度减少了上传到GPU的数据，但是仍然是每一帧都上传一次。\n是否可以将数据缓存在GPU，这样只需要上传一次即可？ OpenGL引入了Buffer Object，即缓冲区对象;\n顶点数据上传到GPU之后，就缓存起来，后续渲染直接从显存获取,\n\n使用缓冲区对象进行绘制分为以下步骤：\n创建VBO(顶点缓冲区对象) 和 EBO(索引缓冲区对象)，并上传数据\n将Shader变量和缓冲区对象进行关联\n使用EBO绘制\n")]),n("p",[t._v(" openGL3.0 ")]),n("pre",[t._v("从 #version 110 升级为 #version 330\n增加了顶点数组对象(Vertex Array Object，简称VAO)\n使用关键字in 替代 attribute\n使用关键字out 替代varying\n采样函数从texture2D变为texture\n片段着色器的输出，可以使用关键字out指定自定义变量。\n\n顶点着色器\n#version 330 core\nuniform mat4 u_mvp;\nlayout(location = 0) in  vec3 a_pos;\nlayout(location = 1) in  vec4 a_color;\nout vec4 v_color;\nvoid main()\n{\n    gl_Position = u_mvp * vec4(a_pos, 1.0);\n    v_color = a_color;\n};\n\n片段着色器\n#version 330 core\nin vec4 v_color;\nlayout(location = 0) out vec4 o_fragColor;\nvoid main()\n{\n    o_fragColor = v_color;\n}\n\n顶点数组对象(Vertex Array Object，简称VAO)可以减少OpenGL API的调用次数。\nVAO就像一个容器，在GPU端记录了一次绘制的顶点的状态。\n\n每次绘制时，需要绑定VBO、EBO，这就调用了2次API\n//指定当前使用的VBO\nglBindBuffer(GL_ARRAY_BUFFER, kVBO);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, kEBO);\n\n// 生成一个VAO\nglGenVertexArrays(1,kVAO);\nglBindVertexArray(kVAO);\n{\n    //指定当前使用的VBO\n    glBindBuffer(GL_ARRAY_BUFFER, kVBO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, kEBO);\n}\nglBindBuffer(GL_ARRAY_BUFFER, 0);\n\n在绘制的时候只要绑定VAO\nglBindVertexArray(kVAO);\n{\n    glDrawElements(GL_TRIANGLES,36,GL_UNSIGNED_SHORT,0);//使用顶点索引进行绘制，最后的0表示数据偏移量。\n}\nglBindVertexArray(0);\n\n将非动态的内容，都可以设置到VAO里面\n\n"),n("h3",[t._v("Mesh")]),t._v("\n"),n("p",[t._v("模型就是指Mesh")]),t._v("\nmesh包含一些列顶点数据，静态模型\n\n相机的作用就是提供View、Projection这两个矩阵，MeshRenderer拿到这两个矩阵和模型世界坐标相乘得到mvp，传入GPU。\n多相机渲染，就是要遍历多个相机，用当前 index 相机的View、Projection矩阵，提供给MeshRenderer拿去做计算\n\n所谓材质，就是一系列属性的集合。\n模型材质，是渲染这个模型所需要的一系列属性的集合，例如指定贴图、颜色。\n物理材质，就是物体用于物理计算所需要的一系列属性的集合，例如摩擦系数、弹性系数\n\n")]),n("pre",[t._v("代码主逻辑：\nOpenGL初始化，创建视口。\n初始化着色器。\n关联着色器变量和顶点数据\n执行主循环\n\n主循环：\n坐标系转换\n上传mvp矩阵\n调用 glDrawArrays 上传顶点数据并进行绘制(这就是一个DrawCall完成)\n")])])}],_={name:"Home",components:{}},m=_,b=(e("b77c"),Object(d["a"])(m,v,f,!1,null,"35c56331",null)),g=b.exports,x=function(){var t=this;t._self._c;return t._m(0)},A=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"wrapper"},[n("h3",[t._v("坐标系")]),n("img",{attrs:{width:"400px",src:e("34a5"),alt:""}}),n("p",[t._v("xyz")]),n("pre",[t._v("坐标系是描述物体或点的位置和方向的一种数学工具。它由坐标轴和原点组成，通常用于二维或三维空间中。\n\n坐标轴是一条直线，其上有等距离的点，用来表示某个方向上的距离。在二维坐标系中，通常有两条垂直的坐标轴，即水平轴和垂直轴；在三维坐标系中，则需要增加一条竖直的轴。这些轴通常用 x、y 和 z 表示，并通过原点相交。\n\n位置可以用一组数字（称为坐标）来描述。在二维坐标系中，每个点都有一个唯一的坐标，由它在水平轴和垂直轴上的位置确定。在三维坐标系中，每个点由它在三个轴上的位置确定。\n\n坐标系不仅可以用来描述物体或点在空间中的位置和方向，还可以用于计算距离、角度、速度、加速度等物理量。它在数学、物理、工程、计算机科学等领域都有广泛应用。\n\n## 二维笛卡尔坐标系\n\n笛卡尔坐标系由两条互相垂直的直线，即 x 轴和 y 轴组成\n\n在平面直角坐标系中，每个点都可以通过一对有序实数(x, y)来表示。其中，x 坐标表示点到 y 轴的水平距离；y 坐标表示点到 x 轴的竖直距离。通常情况下，x 轴向右为正方向，y 轴向上为正方向。\n\n参考系不一样，最终造成二者的坐标表示内容也是不一样的，其实这点可以类推我们在图形学中讲到的物体坐标系。每个物体都有自己单独的坐标系，这样就会造成标准不统一，难以在统一的条件下进行控制多个物体。\n\n## 三维笛卡尔坐标系\n\nx、y、z 分别表示点到 yz 平面、xz 平面和 xy 平面的距离。通常情况下，x 轴向右为正方向，y 轴向上为正方向，z 轴向前为正方向。三维笛卡尔坐标系广泛应用于各种领域，如数学、物理、工程、计算机图形学等。\n在计算机图形学中，三维坐标系被用来描述三维物体的位置、大小和形状等属性，是实现三维渲染、动画和虚拟现实等技术的基础。\n\n### 基向量\n\n在线性代数中，三个轴（在一维和二维情况下分别为一个或两个）构成了我们所说的该坐标系的基础。基向量是一组线性独立的向量，它们以线性组合表示给定向量空间（坐标系）中的每个向量。更改基向量或更改坐标系是数学和图形管道中的常见操作。\n\n基向量是一个矩阵或向量空间中的一组线性无关向量，可以通过它们来表示该空间中的任何向量。基向量集通常被称为基。\n在二维空间中，通常使用两个向量作为基向量。在三维空间中，则通常使用三个向量作为基向量。这些基向量被选为互相垂直且长度为 1，因此它们可以用来描述空间中的任何向量。\n更一般地说，在 n 维向量空间中，需要 n 个线性无关的基向量才能表示该空间中的所有向量。这些基向量通常被写成列向量的形式，并排列成一个矩阵，这个矩阵就被称为基矩阵。\n\n## 左手坐标系与右手坐标系\n\n"),n("img",{attrs:{width:"400px",src:e("8a76"),alt:""}}),t._v("\n\n坐标系标准\n\n当 x 轴指向右侧，y 轴指向上方时，如果 z 轴指向远离你，则为左手坐标系。如果它指向你的方向，则为右手坐标系。\n\n- 左手：远离你\n- 右手：朝你\n\n坐标系的惯用手性在从多边形面的边计算的法线方向中也起着重要作用。\n例如，如果方向为右手，则其折点按逆时针顺序指定的面将朝前。\n\n## 物体坐标系（模型坐标系、身体坐标系、个体坐标系）\n\n物体坐标系是三维空间中的一个坐标系，用于描述物体在三维空间中的位置和方向。通常情况下，物体坐标系的原点被定义为物体的质心或几何中心，并且其轴线会根据物体的形状而确定。\n\n物体坐标系是和特定物体相关联的坐标系。每个物体都有它们独立的坐标系。\n\n结合实现的例子给大家举例子，比如此刻你要去北京天安门玩耍，高德导航会告诉你“向左转，向右转”。此时是以你个人为中心，也就等同于我们所讲的物体坐标系下的运动。\n\n有时候你行走的方向相反了，或者你偏移了很大角度，高德地图一般会提示你“您的方向偏移，请向南出发”此时他的意思就是在世界坐标系下进行的提醒，此刻你的目的地和你本身都是放在世界坐标系下去衡量的。\n\n**在计算机图形学中，物体坐标系通常被用来描述三维模型的位置、旋转和缩放状态。当需要对三维模型进行变换时，可以通过对其物体坐标系进行变换来实现**\n例如，通过对物体坐标系进行平移变换，可以将模型沿着某个轴线上移动一定距离；通过对物体坐标系进行旋转变换，可以将模型绕某个轴线旋转一定角度。\n\n## 世界坐标系（全局坐标系、宇宙坐标系）\n\n世界坐标系有很多名字，它类同于笛卡尔坐标系，只是它具有了物理属性，赋予了它在实际中的例子。\n上面我们提到其实每个物体都有自己的坐标系，但是实际我们在日常应用中，我们需要将各个坐标系进行统一化，在一个相同的约束下进行计算。所以世界坐标系就产生了，每个物体相对于世界坐标系都有自己的坐标。\n我们经常在小学学习地理的时候，老师告诉我们更具地球经纬度就可以获取到你的位置，所以人类根据这个基本原理，设定了 WGS 84 坐标系。学地理或者学 GIS 的同学一定对这个概念很清楚。实际上相对于地球来说，世界坐标系在球体的质心。\n\n世界坐标系是一个特殊的坐标系，它建立了描述其他坐标系所需要的参考框架。\n从另一方面说，能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系来描述世界坐标系。在世界坐标系里面的任何一个东西，我们都能用世界坐标表示。\n\n## 惯性坐标系\n\n惯性坐标系实际上是世界坐标系与物体坐标系的中间模块，为了方便二者转换，引入了一种新的坐标系，称作惯性坐标系。惯性坐标系的原点和物体坐标系的原点重合，惯性坐标系的轴平行于世界标系的轴\n\n- 为什么引入惯性坐标系\n  因为从物体标系转换到惯性标系只需旋转；\n  从惯性标系转换到界坐标系只需要平移。\n\n## 嵌套坐标系\n\n所谓的“嵌套坐标系”实际上是世界坐标系和物体坐标系的综合，\n比如举个例子，你仍然要去北京天安门游玩，在去的路上你相对地球来说，你的位置不断发生位移，这就属于在世界坐标系的坐标变换，\n\n在去天安门游玩的路上，你在路上吸了口烟，吐了口吐沫。这两个动作实际上是相对于你本身而言的，也就是物体坐标系。在实际程序开发中，我们应用嵌套坐标系的例子很多，比如我们在做人物奔跑、漫游、行走、坐下等连续式动画的时候\n\n## 相机坐标系\n"),n("img",{attrs:{width:"400px",src:e("cff6"),alt:""}}),t._v("\n\n相机坐标系可以想象成你本人的观察视角。\n\n摄像机坐标系能被看作是一种特殊的“物体”坐标系，该“物体”坐标系就定义在摄像机的屏幕可视区域。\n摄像机坐标系中，摄像机在原点，x 轴向右，z 轴向前(朝向屏幕内或摄像机方向)，y 轴向上(不是世界的上方而是摄像机本身的上方)。\n\n## 投影坐标系（裁减坐标系）\n\n投影坐标系，也称为裁减坐标系，是计算机图形学中一个重要的概念。\n在三维图形学中，我们通常使用三维对象描述场景。然而，在实际应用中，我们需要在二维屏幕上显示这些场景。因此，必须将三维场景中的点映射到二维投影平面上。这个过程就需要用到投影坐标系。\n\n投影坐标系一般分为正交投影和透视投影。\n\n## 屏幕坐标系\n\n屏幕坐标系是计算机图形学中用于表示屏幕上的像素位置的坐标系。\n它通常是一个以左上角为原点（0,0）的二维直角坐标系，其中水平方向向右为正方向，垂直方向向下为正方向。\n在屏幕坐标系中，每个像素都可以由其 x 和 y 坐标确定。\n例如，屏幕上的某个像素可能具有坐标 (100, 200)，这意味着它距离屏幕左侧 100 个像素，距离屏幕顶部 200 个像素。\n\n## 坐标系转换\n\n其实坐标系转换是同一个事物在不同坐标系下的表现形式。两个不同坐标的转换过程被称为“坐标系转换”。\n\nhttps://www.bilibili.com/video/BV1HU4y1e7JS/?vd_source=01ae3fc576acbf5bd3e59f3307bb594f\n\n    ")])])}],w={name:"Home",components:{}},M=w,O=(e("b75e"),Object(d["a"])(M,x,A,!1,null,"444e43a2",null)),y=O.exports,T=function(){var t=this;t._self._c;return t._m(0)},S=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"wrapper"},[n("h2",[t._v("点&向量")]),n("img",{attrs:{width:"400px",src:e("3260"),alt:""}}),n("h3",[t._v("点")]),t._v(" 点是最基础的几何形状了吧。点是三维空间中的一个位置 vec3 a= vec3(0.5,0.5,1); // 函数用来表示一个在 z 轴上面的点 "),n("h3",[t._v("向量")]),n("pre",[t._v("物理层面：大小，方向的箭头，起点 》终点\n计算机层面：坐标系中的点坐标 x，y\n\n二维空间中， 原点 -> 终点\n[1\n2]\n\n三维空间\n[1\n2\n3]\n\n### 向量加法\n\n各坐标轴的分量相加，平移\n数乘，缩放\n\n## 2.向量坐标\n\n坐标轴看着标量\n\n基向量：坐标系中单位长度为 1\na = bW + vV\n二维向量 a 都可以看做基向量 v，w 的线性组合\nv 和 w 全部的向量组合为 张成的空间\n")]),n("h3",[t._v("向量desc")]),n("pre",[t._v("\n向量又称为矢量，具体定义我们不再过多介绍。但向量可以在 CG 中可以用数字数组表示。这个数字数组可以假定任何所需的长度，有时也称为数学中的元组\n\n元组是数学中的一个概念，它指的是有序数对或者有序 n 元组。元组的形式可以表示为 (a1, a2, ..., an)，其中每个元素 ai 可以是任意数值类型，也可以是其他数据类型。在数学中，元组通常用于描述多个变量之间的关系或者属性。例如，一个二维平面上的点可以表示为一个含有两个元素的元组 (x, y)\n\n在计算机图形学中，向量可以表示空间中的位置或方向。CG 中提供了很多方法来操控这些向量，变换这些向量的方法我们称为线性变换: 线性变换是指一种将一个向量空间中的向量映射到另一个向量空间中的操作。线性变换在向量空间中有着广泛的应用，包括矩阵乘法、旋转、缩放、投影等等\n\n### 行向量与列向量\n\n行向量: directX 就是行向量\n行向量是一个 1 × n 的矩阵，其中 n 是元素的数量。例如：\nA=[a₁,a₂,...,aₙ]\n\n列向量: opengl 就是列向量\n列向量是一个 n × 1 的矩阵，其中 n 是元素的数量。例如：\nb=[\n1,\n2,\n3\n]\n\n```js\n/**\n * 向量通常指一个有长度有方向的量。向量使所有的移动和空间行为更容易理解和在代码中实现。\n * 向量可以相加，缩放，旋转，指向某物体。\n * 在javascript中，一个方向和长度(即向量)在二维空间中可以用横坐标x和纵坐标y表示。\n */\n\nconst EPSILON = 0.00000001;\nconst areEqual = (one, other, epsilon = EPSILON) => Math.abs(one - other) < epsilon;\n\n// 向量由一系列数值构成，每维数值都是向量的一个分量\n// 1.方向\n// 2.长度\n// const length = Math.sqrt(x * x + y * y);\n\n// ** 角是以弧度( radian )为单位，不是角度( degree ) **\n// 1弧度是弧长和半径相等的弧，圆的周长：2*Math.PI*R(R为半径)，圆的弧度：2*Math.PI\n//弧度转角度\nconst toDegrees = (radians) => (radians * 180) / Math.PI;\n//角度转弧度\nconst toRadians = (degrees) => (degrees * Math.PI) / 180;\n\n// ======= 向量的运算 =======\nclass Vector {\n  constructor(...vectors) {\n    this.vectors = vectors; // [1, 2]\n  }\n\n  // 向量加：返回一个新向量\n  // 1.向量相加\n  // 将向量看成一个运动，从原点出发，向v方向移动长度∣v∣后，再向w方向移动长度∣w∣后，就等于直接向 v+w方向移动长度∣v+w∣\n  add({ vectors }) {\n    return new Vector(...vectors.map((v, index) => this.vectors[index] + v));\n  }\n  // 向量减：返回一个新向量\n  subtract({ vectors }) {\n    return new Vector(...vectors.map((v, index) => this.vectors[index] - v));\n  }\n  // 对一个向量进行缩放，缩放比例可为任意数值 α ∈ R。缩放时，对所有向量分量都乘以缩放因子 α。\n  // 当 α > 1 时，向量会变得更长；\n  // 当 0 ≤ α ≤ 1 时，向量会变得更短。\n  // 如果 α 是负数，缩放后的向量将会指向原向量的反方向。\n  // 乘法\n  scaleBy(number) {\n    return new Vector(...this.vectors.map((v) => v * number));\n  }\n  // 向量长度可由勾股定理导出\n  length() {\n    return Math.hypot(...this.vectors);\n  }\n  // 点积\n  // 点积可以计算出两个向量的相似程度。点积方法接收两个向量作为输入，并输出一个数值。\n  // 两个向量的点积等于它们各自对应分量的乘积之和。\n  // a*b = |a|*|b|*con0\n  // 计算投影， 分解， 方向\n  // https://docs.pingcode.com/ask/38308.html\n  dotProduct({ otherVectors }) {\n    return otherVectors.reduce(\n      (acc, ov, index) => acc + ov * this.vectors[index],\n      0\n    );\n  }\n  // 在我们观察几个向量间的方向关系前，需要先实现一种将向量长度归一化为 1 的方法\n  // 归一化向量，该方向的单位向量\n  normalize() {\n    return this.scaleBy(1 / this.length());\n  }\n  // 如果两个归一化后的向量的点积结果等于 1，则意味着这两个向量的方向相同。\n  haveSameDirectionWith(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, 1);\n  }\n  // = -1， 反向\n  haveOppositeDirectionTo(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, -1);\n  }\n  // = 0， 垂直\n  isPerpendicularTo(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, 0);\n  }\n  // 叉积\n  // 叉积仅对三维向量适用，它会产生垂直于两个输入向量的向量\n  // 只适用于 3 维向量， 计算法向量， 计算三维坐标系\n  // |a*b| = |a||b|sin0\n  // 用来判断方向，两个向量的左右关系， 是否在三角形内外\n  crossProduct({ others }) {\n    return new Vector(\n      this.vectors[1] * others[2] - this.vectors[2] * others[1],\n      this.vectors[2] * others[0] - this.vectors[0] * others[2],\n      this.vectors[0] * others[1] - this.vectors[1] * others[0]\n    );\n  }\n\n  // 计算夹角\n  angleBetween(other) {\n    return toDegrees(\n      Math.acos(this.dotProduct(other) / (this.length() * other.length()))\n    );\n  }\n\n  // 当需要将一个向量的方向指向反向时，我们可以对这个向量进行 -1 缩放\n  negate() {\n    return this.scaleBy(-1);\n  }\n\n  // 投影\n  // 在向量other上的投影\n  projectOn(other) {\n    // other的单位向量\n    const otherStandardVect = other.normalize();\n    // other的单位向量和one的点乘值\n    const sv = this.dotProduct(otherStandardVect);\n    return otherStandardVect.scaleBy(sv);\n  }\n\n  // 为了判断两个向量是否相等，可以对它们对应的分量使用 areEqual 函数\n  equalTo({ components }) {\n    return components.every((component, index) =>\n      areEqual(component, this.vectors[index])\n    );\n  }\n\n  // 单位向量与基底\n}\n```\n\n## 法线\n\n法线（Normal）是指垂直于曲面或多边形表面的向量。法线通常被用来计算光照和阴影，以及决定物体表面如何反射光线\n\n## 向量的基\n\n对于任何二维的向量点 C\n[1,\n2]\n\nC = Ai + Bj, i 和 j 为基向量\n基可以变化\n\n## 线性相关\n\n## 向量张成的空间\n\n由基向量组合的所有向量形成的空间\n\n    ")])])}],E={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},D=E,R=(e("d733"),Object(d["a"])(D,T,S,!1,null,"f7343104",null)),V=R.exports,P=function(){var t=this;t._self._c;return t._m(0)},I=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"wrapper"},[n("h2",[t._v("矩阵")]),n("img",{attrs:{width:"600px",src:e("1aa6"),alt:""}}),n("h3",[t._v("矩阵本质")]),n("img",{attrs:{width:"400px",src:e("0b6d"),alt:""}}),n("img",{attrs:{width:"400px",src:e("de67"),alt:""}}),n("pre",[t._v("        矩阵如同线性变换 =》一种空间变换\n\n- 线性变换\n  输入向量 =》 输出向量\n\n从输入向输出移动，理解为一种运动\n\n所有的输入点 经过变换 到达输出点\n\n线性变换：1.原点不变， 2.直线还是线\n- 变换基向量即可\n\nn阶矩阵列 可以理解为 变换基\n\n矩阵 * 向量 =》新向量\n    ")]),n("h3",[t._v("# 矩阵 matrix")]),n("pre",[t._v("\n由 `m*n 个数排成的 m 行 n 列的数表称为 m 行 n 列的矩阵，简称 m*n` 矩阵;\n行数与列数都等于 n 的矩阵称为 n 阶矩阵或 n 阶方阵\n\n线性变换\n\n- 原点不变，直线性不变\n\nVin \\* Mat = Vout\n\n向量乘矩阵： 变换得到一个新向量\nx[] + y[] = v\n\n## 秩\n\n矩阵秩是矩阵理论中的一个重要概念，它描述了矩阵所包含的线性无关向量的个数\n\n矩阵秩的通俗易懂定义是：一个矩阵的秩就是它所包含的线性无关列向量（或行向量）的最大数量。\n可以简单地理解为一个矩阵中不重复的列向量（或行向量）的数量\n\nhttps://www.zhihu.com/question/21605094\n`「秩」是图像经过矩阵变换之后的空间维度 `\n\n秩」是列空间的维度; 首先看下什么是列空间\n\n```js\nconst m = [1, 2\n           2, 1]\n\n// 所以，列空间就是矩阵的列向量 ai + bj 来表示的空间。\n\n```\n\n## 奇异矩阵\n\n奇异矩阵是线性代数的概念，就是该矩阵的秩不是满秩。\n\n首先，看这个矩阵是不是方阵（即行数和列数相等的矩阵，若行数和列数不相等，那就谈不上奇异矩阵和非奇异矩阵）。如是方阵，再看此矩阵的行列式|A|是否等于 0，若等于 0，称矩阵 A 为奇异矩阵；若不等于 0，称矩阵 A 为非奇异矩阵。\n\n## 逆矩阵\n\n逆矩阵是指对于一个给定的方阵 A，如果存在一个方阵 B 使得 A 乘以 B 等于 B 乘以 A 等于单位矩阵 I，则称方阵 B 为 A 的逆矩阵，记作\nA−1\n其中，我们上面讲到单位矩阵指的是对角线上所有元素都为 1，其余元素都为 0 的方阵。\n\n要求一个矩阵 A 的逆矩阵，需要保证以下两个条件都满足：\n\n- 矩阵 A 必须是一个方阵。只有方阵才具有逆矩阵。\n- 矩阵 A 必须是可逆的。即行列式不为 0。\n\n## 转置\n\n考虑一个 RXC 矩阵 M。M 的转置记作 MT，是一个 RXC 矩阵，它的列由 M 的行组成。可以从另一方面理解，MT=M，即沿着矩阵的对角线翻折。如下面这个例子\n\n对于任意矩阵 M，(MT)T=M 。从另一方面来说，将一个矩阵转置后，再转置一次，便会得到原矩阵。\n这条法则对向量也适用,对于任意对角矩阵 D，都有 DT =D，包括单位矩阵 I 也如此。\n\n    ")])])}],N={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},C=N,L=(e("0f9f"),Object(d["a"])(C,P,I,!1,null,"24b2cdae",null)),j=L.exports,B=function(){var t=this,n=t._self._c;return n("div",[n("h2",[t._v("测试图形api")]),n("div",{staticClass:"api-wrapper"},[n("div",[n("span",[t._v("箭头mesh")]),n("input",{directives:[{name:"model",rawName:"v-model",value:t.arrowType,expression:"arrowType"}],attrs:{type:"radio",value:"1"},domProps:{checked:t._q(t.arrowType,"1")},on:{change:function(n){t.arrowType="1"}}}),t._v(" 单向 "),n("input",{directives:[{name:"model",rawName:"v-model",value:t.arrowType,expression:"arrowType"}],attrs:{type:"radio",value:"2"},domProps:{checked:t._q(t.arrowType,"2")},on:{change:function(n){t.arrowType="2"}}}),t._v(" 双向 "),n("button",{on:{click:t.handleDrawArrow}},[t._v("绘制箭头mesh")])]),n("div",[n("span",[t._v("矩形mesh")]),n("button",{on:{click:t.handleDrawRect}},[t._v("绘制矩形mesh")])]),n("div",[t._v("清除 "),n("button",{on:{click:t.handleClear}},[t._v("清除上下文")])]),n("div",[n("h3",[t._v("视口操作")]),n("div",[t._v(" 偏移： x："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOffsetX,expression:"vpOffsetX"}],domProps:{value:t.vpOffsetX},on:{input:function(n){n.target.composing||(t.vpOffsetX=n.target.value)}}}),t._v(" y："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOffsetY,expression:"vpOffsetY"}],domProps:{value:t.vpOffsetY},on:{input:function(n){n.target.composing||(t.vpOffsetY=n.target.value)}}})]),n("div",[t._v(" 缩放原点： x："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOx,expression:"vpOx"}],domProps:{value:t.vpOx},on:{input:function(n){n.target.composing||(t.vpOx=n.target.value)}}}),t._v(" y："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOy,expression:"vpOy"}],domProps:{value:t.vpOy},on:{input:function(n){n.target.composing||(t.vpOy=n.target.value)}}})]),n("div",[t._v(" 缩放比率(0.05-2)："),n("input",{directives:[{name:"model",rawName:"v-model",value:t.vpScaleRatio,expression:"vpScaleRatio"}],domProps:{value:t.vpScaleRatio},on:{input:function(n){n.target.composing||(t.vpScaleRatio=n.target.value)}}}),n("button",{on:{click:t.handleSetVp}},[t._v("设置视口")])])])]),n("canvas",{attrs:{id:"canvas",width:"600px",height:"600px"}})])},F=[],k=(e("a573"),e("ade3"));e("d9e2"),e("14d9"),e("2c66"),e("249d"),e("40e9"),e("907a"),e("986a"),e("1d02"),e("3c5d"),e("6ce5"),e("2834"),e("4ea1"),e("4e3e");const U="#version 300 es\n\tlayout(location=1) in vec4 currVertexAndRatio;\t\t\t // 指定currVertexAndRatio变量在顶点属性数组中的位置是1 // 顶点坐标和变形系数\n\tlayout(location=2) in vec4 prevVertexAndRatio;\n\tlayout(location=3) in vec4 nextVertexAndRatio;\n\tlayout(location=4) in vec4 uvAndEdgeOffsetRatio;\t\t// UV\n\tlayout(location=5) in vec4 vertexAndEdgeOffsetValueAndNotFollowViewport;\t// 顶点形变  边形变值  是否不跟随视口\n\tlayout(location=6) in vec4 UVRect;\t\t\t\t\t\t// UVRect\n\tlayout(location=7) in vec4 backgroundColor;\t\t\t\t// 背景色\n\tlayout(location=8) in vec4 translationAndRotation;\t\t// 形变\n\tlayout(location=9) in vec4 isTextAndBorderWidthAndDashedAndScale;\t\t// 是否渲染文字 以及 文字边框粗细 以及物体边框虚线 缩放\n\tlayout(location=10) in vec4 textBorderColor;\t\t\t// 文字边框颜色\n\tlayout(location=11) in vec4 opacityAndDisplayAndVpScaleAndVpTrans;\t\t\t// 透明度 是否显示 是否跟随视口缩放 是否跟随视口平移\n    \n\tout vec2 vTexCoord;\t\t\t\t// UV  // out是从顶点着色器传递到片段着色器（用于处理像素颜色）的数据\n\tout vec4 vBgColor;\n\tout float vIsText;\n\tout float vTextBorderWidth;\n\tout vec4 vTextBorderColor;\n\tout float vHasTexture;\n\tout vec4 vPos;\n\tout float vNotBorder;\n\tout float vBorderDashed;\n\tout float vOpacity;\n\tout float vDisplay;\n\n    // 应用程序和着色器之间传递传递参数\n\tuniform vec2 uConversionVec2;\t//坐标转换\n\tuniform vec2 uViewportTranslation;\t//视口平移\n\tuniform vec2 uViewportScale;\t\t//视口缩放\n\tuniform float uViewportRotation;\t//视口旋转\n\tuniform vec4 uOpacity;\t\t\t\t//全局透明度\n\n\tmat4 getScaleMatrix(vec2 scale) {\n\t\treturn mat4(\n\t\t\tscale.x, 0.0, 0.0, 0.0,\n\t\t\t0.0, scale.y, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getRotationMatrix(float radian) {\n\t\tfloat cost = cos(radian);\n\t\tfloat sint = sin(radian);\n\t\treturn mat4(\n\t\t\tcost, -sint, 0.0, 0.0,\n\t\t\tsint, cost, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getTranslationMatrix(vec2 translation) {\n\t\treturn mat4(\n\t\t\t1.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\ttranslation.x, translation.y, 0.0, 1.0\n\t\t);\n\t}\n\n    // 找到两个向量夹角平分线上的一个特定点，这个点距离每个向量的端点都是 offset 距离\n\tvec2 getIntersectionVertex(\n\t\tin vec2 v1,\n\t\tin vec2 v2,\n\t\tin float offset\n\t) {\n\t\tvec4 vv1 = vec4(v1, 0.0, 1.0);\n\t\tvec4 vv2 = vec4(v2, 0.0, 1.0);\n\t\t// 向量夹角\n\t\tvec2 mid = normalize(normalize(v1) + normalize(v2));\n\t\tfloat theta = acos(dot(v1, v2) / (length(v1) * length(v2)));\n\t\t// 右手法则，判断夹角正负\n\t\tvec3 c = cross(vv1.xyz, vv2.xyz);\n\t\tfloat l = offset / sin(theta * 0.5);\n\t\treturn mid * l * (- sign(c.z));\n\t}\n\n    // 将一个点按照给定的比率和值进行偏移，用于创建动画、调整对象位置\n\tvec2 getVertex(\n\t\tin vec2 origin,\n\t\tin vec2 offsetRatio,\n\t\tin vec2 offsetValue\n\t) {\n\t\tvec2 offset = offsetRatio * offsetValue;\n\t\treturn origin + offset;\n\t}\n   \n\tvec2 getFollowViewport() {\n\t\tfloat outViewportStatus = vertexAndEdgeOffsetValueAndNotFollowViewport.w;  // 跟随视口状态\t\n\t\tvec3 f = vec3(outViewportStatus - 1.0, outViewportStatus - 2.0, outViewportStatus - 3.0);\n\t\tf = step(vec3(0.5, 0.5, 0.5), abs(f));\n\t\treturn vec2(f.x * f.z, f.y * f.z);\n\t}\n\n\t// 获取缩放矢量\n\tvec2 getScaleVec(float scale, vec2 followViewport, vec2 notFollowViewport) {\n\t\tvec2 scaleVec = vec2(scale, scale);\n\t\tvec2 isVpScale = vec2(1.0, 1.0) - opacityAndDisplayAndVpScaleAndVpTrans.zz;\n\t\tvec2 dscaleVec = vec2(1.0, 1.0) / uViewportScale * scaleVec * isVpScale + scaleVec * (1.0-isVpScale);\n\t\treturn dscaleVec * followViewport + scaleVec * notFollowViewport;\n\t}\n\n\tvoid main(void) {\n\t\tvec2 pv = getVertex(prevVertexAndRatio.xy, prevVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 cv = getVertex(currVertexAndRatio.xy, currVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 nv = getVertex(nextVertexAndRatio.xy, nextVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 pe = pv - cv;\n\t\tvec2 ne = nv - cv;\n\n\t\t// 判断是否需要乘视口矩阵\n\t\tvec2 followViewport = getFollowViewport();\n\t\tvec2 notFollowViewport = vec2(1.0, 1.0) - followViewport;\n\n\t\t// 各种矩阵\n\t\tmat4 rotationMatrix = getRotationMatrix(translationAndRotation.z);\n\t\t// 缩放矩阵，如果设置了脱离视口，则需要计算一个反向缩放矩阵\n\t\tmat4 scaleMatrix = getScaleMatrix(getScaleVec(isTextAndBorderWidthAndDashedAndScale.w, followViewport, notFollowViewport));\n\t\tmat4 transMat = getTranslationMatrix(translationAndRotation.xy);\n\t\tmat4 converMat = getScaleMatrix(uConversionVec2.xy);\n\t\t// 视口矩阵\n\t\tmat4 vpScaleMatrix = getScaleMatrix(uViewportScale);\n\t\tmat4 vpTranslationMatrix = getTranslationMatrix(uViewportTranslation);\n\t\tmat4 vpRotationMatrix = getRotationMatrix(uViewportRotation);\n\t\tmat4 vpMat = vpTranslationMatrix * vpScaleMatrix * converMat * vpRotationMatrix;\n\n\t\t// 求相邻两边交点向量\n\t\tvec2 intersection = getIntersectionVertex(pe, ne, vertexAndEdgeOffsetValueAndNotFollowViewport.z * uvAndEdgeOffsetRatio.z);\n\n\t\tvec4 posOrigin = transMat * scaleMatrix * rotationMatrix * vec4(cv, 0.0, 1.0);\n\t\tvec4 posBorder = rotationMatrix * vec4(intersection, 0.0, 0.0);\n\t\tposBorder = converMat * vec4(vec2(vpRotationMatrix * posBorder) * followViewport + posBorder.xy * notFollowViewport, 0, 0);\n\t\tposOrigin = vec4(vec2(vpMat * posOrigin) * followViewport + vec2(converMat * posOrigin) * notFollowViewport, 0.0, 1.0);\n\n\t\tgl_Position = posOrigin + posBorder;\n\n\t\t// out\n\t\t// 如果材质宽度为0 则标志为无材质\n\t\tvHasTexture = step(0.0, UVRect.z);\n\t\tvTexCoord = uvAndEdgeOffsetRatio.xy * UVRect.zw + UVRect.xy;\n\t\tvBgColor = backgroundColor;\n\t\tvIsText = isTextAndBorderWidthAndDashedAndScale.x;\n\t\tvTextBorderWidth = isTextAndBorderWidthAndDashedAndScale.y;\n\t\tvTextBorderColor = textBorderColor;\n\t\tvNotBorder = step(vertexAndEdgeOffsetValueAndNotFollowViewport.z, 0.0);\n\n\t\tvPos = rotationMatrix * vec4(cv, 0.0, 1.0); // 用于边框渲染计算\n\t\tvPos = vec4(vec2(vpRotationMatrix * vPos) * followViewport + vPos.xy * notFollowViewport, 0.0, 1.0);\n\n\t\tvBorderDashed = isTextAndBorderWidthAndDashedAndScale.z;\n\t\tvOpacity = opacityAndDisplayAndVpScaleAndVpTrans.x * uOpacity.x;\n\t\tvDisplay = opacityAndDisplayAndVpScaleAndVpTrans.y;\n\t}\n",W=" #version 300 es\n\tprecision mediump float;\n\tuniform sampler2D uSampler;\n\t// uniform vec2 uConversionVec2;\t// 坐标转换\n\tin vec2 vTexCoord; // 从顶点着色器传入的纹理坐标\n\tin vec4 vBgColor; // 从顶点着色器传入的背景颜色\n\tin float vIsText;\n\tin float vTextBorderWidth;\n\tin vec4 vTextBorderColor;\n\tin float vHasTexture;\n\tin vec4 vPos;\n\tin float vNotBorder;\n\tin float vBorderDashed;\n\tin float vOpacity;\n\tin float vDisplay;\n\tout vec4 fragColor; // 片段着色器的输出颜色，将被用于最终的像素颜色\n\n    // 确定一个片段是否应该被渲染为虚线边框的一部分\n\tfloat inBorderDashed() {\n\t\t// 是否绘制虚线\n\t\tfloat hasDashed = 1.0 - step(vBorderDashed, 0.0);\n\t\tvec2 fw = fwidth(vPos.xy);\n\t\tfloat k = fw.y * (1.0/fw.x);\n\t\t// 如果k在 0.95 和 1.05 之间\n\t\tfloat c1 = step(0.95, k) * step(k, 1.05);\n\t\t// 如果 c1 == 0.1 则 c2 = 0.0 否则 c2 = 1.0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 如果 c1 条件成立 则 gl_FragCoord.x 否则 ...\n\t\tfloat d = gl_FragCoord.x * c1 + (step(1.0, k) * gl_FragCoord.y + step(k, 1.0) * gl_FragCoord.x) * c2;\n\t\treturn step(mod(floor( d * (1.0/vBorderDashed) ), 2.0), 0.0) * hasDashed;\n\t}\n\n\tvec4 drawText(vec4 texture) {\n\t\t// 文字边框是否大于0\n\t\tfloat c1 = step(0.1, vTextBorderWidth);\n\t\t// 文字边框是否小于等于0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 第一个插值阶梯\n\t\tfloat start = max(0.0, 0.5 - vTextBorderWidth * 0.1);\n\t\t// 边框插值系数\n\t\tfloat r1 = smoothstep(start, start + 0.2, texture.r) * c1;\n\t\t// 文字插值系数\n\t\tfloat r2 = smoothstep(0.5, 0.85, texture.r);\n\n\t\treturn vec4(mix(vTextBorderColor.rgb, vBgColor.rgb, r2), r2+(1.0-r2)*r1);\n\t}\n\n\tvec4 drawNormal(vec4 texture, vec4 bgColor) {\n\t\tfloat a1 = texture.a * vHasTexture;\n\t\tfloat a2 = bgColor.a;\n\t\treturn vec4(mix(bgColor.rgb, texture.rgb, a1), a1+(1.0-a1)*a2);\n\t}\n\n\tvoid main(void) {\n        // 丢弃不显示的片段\n\t\tif(vDisplay == 0.0 || vOpacity == 0.0) {\n\t\t\tdiscard;\n\t\t\treturn;\n\t\t}\n\n\t\t// ib == 0.0 则正常渲染， ib == 1.0 则渲染反色\n\t\tfloat ib = inBorderDashed();\n\t\tvec4 bgColor = vec4(vBgColor.rgb * (1.0 - ib) + (vec3(1.0, 1.0, 1.0) - vBgColor.rgb) * ib, vBgColor.a);\n\n\t\t// 材质\n\t\tvec4 tColor = texture(uSampler, vTexCoord);\n\t\t// 绘制字体\n\t\tvec4 textColor = drawText(tColor);\n\t\t// 绘制普通对象\n\t\tvec4 normalColor = drawNormal(tColor, bgColor);\n\n\t\tvec4 color = vIsText * textColor + (1.0 - vIsText) * normalColor;\n\t\tcolor.a *= vOpacity;\n\t\tfragColor = color;\n\t}\n";var H=e("25a5");function G(t,n){for(var e=t[0],r=t[1],o=!1,i=n.length/2,a=0,s=i-1;a<i;s=a,a++){var c=n[2*a],l=n[2*a+1],d=n[2*s],h=n[2*s+1];if(c===e&&l===r||d===e&&h===r){o=!0;break}if(l<r&&h>=r||l>=r&&h<r){var u=c+(r-l)*(d-c)/(h-l);if(u===e){o=!0;break}u>e&&(o=!o)}}return o}class Y{constructor(){Object(k["a"])(this,"_sobj",void 0),Object(k["a"])(this,"_buffer",void 0),this._sobj=new H(200),this._buffer=new Map}objToItem(t){return Object.assign(t.bounds,{id:t.id})}insert(t){if(!t)return void console.log("Searcher: ","Can not insert.",t);const n=t.bounds;if(!((n.minX-n.maxX)*(n.minY-n.maxY)))return void console.log("Searcher: ","Can not insert, width or height equals 0.");const e=t.id,r=this._buffer.get(e);r&&this.remove(e),this._sobj.insert(this.objToItem(t)),this._buffer.set(t.id,t)}remove(t){let n=this._buffer.get(t);n&&(this._sobj.remove(this.objToItem(n)),this._buffer.delete(n.id))}search(t,n,e=0,r=0){let o=this._sobj.search({minX:t,minY:n,maxX:e+t,maxY:r+n}).map(t=>this._buffer.get(t.id));return 0==e&&0==r&&(o=o.filter(e=>G([t,n],e.vertexes))),o}}class q{constructor(t){Object(k["a"])(this,"_srh",void 0),Object(k["a"])(this,"_sable",!1),Object(k["a"])(this,"_expandRadius",0),this._srh=t}set searchable(t){t!=this._sable&&(this._sable=t,!0===t?this.registToSearcher():this.deregistToSearcher())}get searchable(){return this._sable}set expandRadius(t){this._expandRadius!=t&&(this._expandRadius=t,this._sable&&this.registToSearcher())}get expandRadius(){return this._expandRadius}get id(){return""}getVertexPositions(t=0){return[]}registToSearcher(){const t=this.getVertexPositions(this._expandRadius),n=t.filter((t,n)=>n%2==0),e=t.filter((t,n)=>n%2!=0),r={id:this.id,bounds:{minX:Math.min.apply(null,n),maxX:Math.max.apply(null,n),minY:Math.min.apply(null,e),maxY:Math.max.apply(null,e)},vertexes:t};this._srh.insert(r)}deregistToSearcher(){this._srh.remove(this.id)}}class z{constructor(t=0,n=0){Object(k["a"])(this,"root",void 0),Object(k["a"])(this,"mw",void 0),Object(k["a"])(this,"mh",void 0),this.mw=t,this.mh=n}fit(t){var n,e,r,o=t.length,i=o>0?t[0].w:0,a=o>0?t[0].h:0;for(this.root={x:0,y:0,w:i,h:a},n=0;n<o;n++)r=t[n],(e=this.findNode(this.root,r.w,r.h))?r.fit=this.splitNode(e,r.w,r.h):r.fit=this.growNode(r.w,r.h);return t}findNode(t,n,e){return t.used?this.findNode(t.right,n,e)||this.findNode(t.down,n,e):n<=t.w&&e<=t.h?t:null}splitNode(t,n,e){return t.used=!0,t.down={x:t.x,y:t.y+e,w:t.w,h:t.h-e},t.right={x:t.x+n,y:t.y,w:t.w-n,h:e},t}growNode(t,n){if(!(this.root.w+t>this.mw||this.root.h+n>this.mh)){var e=t<=this.root.w,r=n<=this.root.h,o=r&&this.root.h>=this.root.w+t,i=e&&this.root.w>=this.root.h+n;return o?this.growRight(t,n):i?this.growDown(t,n):r?this.growRight(t,n):e?this.growDown(t,n):null}console.error("Texture too large.")}growRight(t,n){this.root={used:!0,x:0,y:0,w:this.root.w+t,h:this.root.h,down:this.root,right:{x:this.root.w,y:0,w:t,h:this.root.h}};let e=this.findNode(this.root,t,n);return e?this.splitNode(e,t,n):null}growDown(t,n){this.root={used:!0,x:0,y:0,w:this.root.w,h:this.root.h+n,down:{x:0,y:this.root.h,w:this.root.w,h:n},right:this.root};let e=this.findNode(this.root,t,n);return e?this.splitNode(e,t,n):null}}var X=e("f0e6");class J{constructor(){Object(k["a"])(this,"eventList",{})}dispatchEvent(t,...n){let e=this.eventList[t];e&&e.forEach(t=>{t[0].apply(t[1],n)})}addEventListener(t,n,e){let r=this.eventList[t];r||(r=[],this.eventList[t]=r),r.push([n,e])}removeEventListener(t,n,e){var r=this.eventList[t];if(r)for(var o=r.length,i=o-1;i>=0;i--)r[i][0]==n&&r[i][1]==e&&r.splice(i,1);r&&0==r.length&&(this.eventList[t]=null,delete this.eventList[t])}}const $={MAX_WIDTH:Math.pow(2,11),MAX_HEIGHT:Math.pow(2,11)},K={fontSize:Math.pow(2,7),fontFamily:"Sans-serif",fontWeight:"normal"},Z=Math.pow(2,1);class Q{constructor(t){Object(k["a"])(this,"gl",void 0),Object(k["a"])(this,"packer",void 0),Object(k["a"])(this,"blocks",[]),Object(k["a"])(this,"fontMaps",new Map),Object(k["a"])(this,"texture",void 0),this.gl=t;const n=t,e=$.MAX_WIDTH,r=$.MAX_HEIGHT;this.packer=new z(e,r),this.texture=n.createTexture(),n.bindTexture(n.TEXTURE_2D,this.texture),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,1),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR),n.texStorage2D(n.TEXTURE_2D,1,n.RGBA8,e,r)}getOriginTexture(){return this.texture}createTexture(t,n,e){t||(t=new Uint8Array(n*e*4),t.fill(0));const r=new nt;return r.index=this.blocks.length,this.blocks.push({w:n+Z,h:e+Z,data:{source:t,texture:r}}),this.updateToGL(),r}getFontTexture(t){const n=t.substr(0,1);return""==n?null:(this.fontMaps.has(n)||(this.embedFont(n),this.updateToGL()),this.fontMaps.get(t))}getFontTextures(){return this.fontMaps}embedFont(t){const n=new X(K.fontSize,K.fontSize/8,K.fontSize/3,null,K.fontFamily,K.fontWeight),e=n.size;for(let r=0;r<t.length;r++){let o=t[r];const i=this.fontMaps.get(o);if(i&&i instanceof nt)continue;const a=n.draw(o,e);let s=new nt;s.index=this.blocks.length,this.blocks.push({w:e+Z,h:e+Z,data:{source:a,texture:s}}),this.fontMaps.set(o,s)}}updateToGL(){this.gl,this.blocks;this.packer.fit(this.blocks);const t=this.blocks.map((t,n)=>t.data.texture).filter(t=>0==t.isReady);t.forEach(t=>this.updateTextureToGL(t))}updateTextureToGL(t){const n=t.index,e=this.blocks[n],r=this.gl,o=Z,i=.5*o,a=e.fit.x+i,s=e.fit.y+i,c=e.w-o,l=e.h-o;t.update(a,s,c,l),r.texSubImage2D(r.TEXTURE_2D,0,a,s,c,l,r.RGBA,r.UNSIGNED_BYTE,e.data.source),t.isReady=!0}copyToTexture(t,n=0,e=0){const r=t.index,o=this.blocks[r],i=this.gl,a=Z,s=.5*a,c=o.fit.x+s,l=o.fit.y+s,d=o.w-a,h=o.h-a;i.copyTexSubImage2D(i.TEXTURE_2D,0,c,l,n,e,d,h)}}const tt={UPDATE:"update"};class nt extends J{constructor(){super(),Object(k["a"])(this,"u",0),Object(k["a"])(this,"v",0),Object(k["a"])(this,"width",0),Object(k["a"])(this,"height",0),Object(k["a"])(this,"index",0),Object(k["a"])(this,"isReady",!1)}update(t,n,e,r,o=-1){const i=$.MAX_WIDTH,a=$.MAX_HEIGHT;this.u=t/i,this.v=n/a,this.width=e/i,this.height=r/a,o>=0&&(this.index=o),this.dispatchEvent(tt.UPDATE,this)}}var et=e("c83a");et["vec2"];const rt=et["vec3"];const ot={NONE:0,DISPLAY:1};function it(t){return new Promise((n,e)=>{const r=new Image;r.onload=()=>n(r),r.src=t})}function at(t){return Promise.all(t.map(t=>it(t)))}class st{static createId(){return this.num++,this.num.toString()}}function ct(t,n,e,r){const o=rt.normalize(rt.create(),t),i=rt.normalize(rt.create(),n);let a=rt.add(rt.create(),o,i);a=rt.normalize(a,a);let s=Math.acos(rt.dot(t,n)/(rt.length(t)*rt.length(n))),c=rt.cross(rt.create(),o,i),l=Math.sign(c[2]),d=r/Math.sin(.5*s);return a.map((t,n)=>t*d*l+e[n])}function lt(t,n,e){return t.map((t,r)=>t+n[r]*e[r])}function dt(t,n,e){return Math.min(n,Math.max(t,e))}Object(k["a"])(st,"num",0);const ht=et["mat4"],ut=(et["vec2"],et["vec3"]),pt=window.devicePixelRatio,vt={TRANSLATION_CHANGE:"translationChange",SCALE_CHANGE:"scaleChange",SIZE_CHANGE:"sizeChange",ROTATION_CHANGE:"rotationChange"};class ft extends J{constructor(t){super(),Object(k["a"])(this,"_engine",void 0),Object(k["a"])(this,"_gl",void 0),Object(k["a"])(this,"_cvec2",new Float32Array(2)),Object(k["a"])(this,"_vpScaleVec2",new Float32Array(2)),Object(k["a"])(this,"_vpTranslationVec2",new Float32Array(2)),Object(k["a"])(this,"_vpRotation",0),Object(k["a"])(this,"_bgColor",[0,0,0,1]),Object(k["a"])(this,"_vpWidth",void 0),Object(k["a"])(this,"_vpHeight",void 0),Object(k["a"])(this,"tempMat4",ht.create()),Object(k["a"])(this,"tempVec3",ut.create()),Object(k["a"])(this,"scaleMin",.05),Object(k["a"])(this,"scaleMax",2),Object(k["a"])(this,"cvMatIsModified",!0),Object(k["a"])(this,"vpScaleIsModified",!0),Object(k["a"])(this,"vpTranslationIsModified",!0),Object(k["a"])(this,"vpRotationIsModified",!0),this._gl=t.gl,this._engine=t;const n=this._gl.canvas;this.setViewportSize(n.width,n.height),this.reset()}setBackgroundColor(t){this._bgColor=t,this._gl.clearColor.apply(this._gl,t.map(t=>t/255))}getBackgroundColor(){return this._bgColor}setViewportSize(t,n,e=!0){this._vpWidth=t,this._vpHeight=n;const r=this._gl,o=t*pt,i=n*pt;if(r.viewport(0,0,o,i),this._cvec2.set([1/t*2,1/n*2]),this.cvMatIsModified=!0,e){const e=r.canvas;e.width=o,e.height=i,e.style.width=t+"px",e.style.height=n+"px"}this.dispatchEvent(vt.SIZE_CHANGE)}getViewportSize(){return[this._vpWidth,this._vpHeight]}scaleOrigin(t,n,e,r=!0){t=dt(this.scaleMin,this.scaleMax,t);const o=this._vpScaleVec2,i=this._engine.sizeRatio,a=(this.scale-t)*i,s=t/this.scale;o[0]*=s,o[1]*=s;const c=Math.cos(this._vpRotation),l=Math.sin(this._vpRotation);let d=n*c+e*l,h=e*c-n*l;this.translate(d*a,h*a,r),this.vpScaleIsModified=!0,r&&this.dispatchEvent(vt.SCALE_CHANGE)}translate(t,n,e=!0){const r=this._vpWidth,o=this._vpHeight;this._vpTranslationVec2[0]+=t/r*2,this._vpTranslationVec2[1]+=n/o*2,this.vpTranslationIsModified=!0,e&&this.dispatchEvent(vt.TRANSLATION_CHANGE)}rotate(t,n=!0){this._vpWidth,this._vpHeight;this._vpRotation+=t,this.vpRotationIsModified=!0,n&&this.dispatchEvent(vt.ROTATION_CHANGE)}reset(t=!0){this._gl,this._vpWidth,this._vpHeight;this._vpTranslationVec2.set([-1,-1]),this._vpScaleVec2.set([1,1]),this._vpRotation=0,this.vpTranslationIsModified=!0,this.vpScaleIsModified=!0,this.vpRotationIsModified=!0,t&&(this.dispatchEvent(vt.SCALE_CHANGE),this.dispatchEvent(vt.TRANSLATION_CHANGE),this.dispatchEvent(vt.ROTATION_CHANGE))}resetTranslationAndScale(t,n,e=1,r=0,o=0,i=!0){const a=this._engine.sizeRatio;this.reset(!1),this.translate(t*a,n*a,!1),this.scaleOrigin(e,r,o,!1),i&&(this.dispatchEvent(vt.SCALE_CHANGE),this.dispatchEvent(vt.TRANSLATION_CHANGE),this.dispatchEvent(vt.ROTATION_CHANGE))}get scale(){return this._vpScaleVec2[0]}get translation(){const t=this._vpTranslationVec2,n=this._engine.sizeRatio,e=this.scale*n;return[(t[0]+1)*this._vpWidth*.5/e,(t[1]+1)*this._vpHeight*.5/e]}set scaleRange(t){this.scaleMin=t[0],this.scaleMax=t[1]}get scaleRange(){return[this.scaleMin,this.scaleMax]}changeCoordinateFromScreen(t,n){const e=this.tempVec3,r=this.tempMat4,o=this._engine;ht.identity(r),e.set([this._vpTranslationVec2[0],this._vpTranslationVec2[1],0]),ht.translate(r,r,e),e.set([this._vpScaleVec2[0]*o.sizeRatio,this._vpScaleVec2[1]*o.sizeRatio,1]),ht.scale(r,r,e),e.set([this._cvec2[0],this._cvec2[1],1]),ht.scale(r,r,e),ht.rotateZ(r,r,-this._vpRotation),ht.invert(r,r);const i=this._vpWidth/2,a=this._vpHeight/2;return e.set([t/i-1,-n/a+1,0]),ut.transformMat4(e,e,r),e.subarray(0,2)}get cvec2(){return this._cvec2}get vpScaleVec2(){return this._vpScaleVec2}get vpTranslationVec2(){return this._vpTranslationVec2}get vpRotation(){return this._vpRotation}}et["glMatrix"].setMatrixArrayType(Float32Array);class _t{constructor(t){if(Object(k["a"])(this,"_gl",void 0),Object(k["a"])(this,"_prg",void 0),Object(k["a"])(this,"_searcher",void 0),Object(k["a"])(this,"_tf",void 0),Object(k["a"])(this,"_vp",void 0),Object(k["a"])(this,"_unitList",void 0),Object(k["a"])(this,"_vpScaleLocal",void 0),Object(k["a"])(this,"_vpTranslationLocal",void 0),Object(k["a"])(this,"_vecLocal",void 0),Object(k["a"])(this,"_vpRotationLocal",void 0),Object(k["a"])(this,"_sizeRatio",1),Object(k["a"])(this,"isDebug",!0),Object(k["a"])(this,"canRending",!0),this._gl=t.getContext("webgl2",{alpha:!1,premultiplyAlpha:!1,antialias:!0}),!this._gl)throw Error("not support WebGL2");this._unitList=[],this._searcher=new Y,this._tf=new Q(this._gl),this._vp=new ft(this),this.initPrg(),window["unitlist"]=this._unitList}get gl(){return this._gl}get prg(){return this._prg}get searcher(){return this._searcher}get textureFactroy(){return this._tf}get viewport(){return this._vp}get sizeRatio(){return this._sizeRatio}set sizeRatio(t){this._sizeRatio=t,this._vp.vpScaleIsModified=!0}initPrg(){let t=this.gl;const n=this.loadShader(t,t.VERTEX_SHADER,U),e=this.loadShader(t,t.FRAGMENT_SHADER,W);this._prg=t.createProgram(),t.attachShader(this._prg,n),t.attachShader(this._prg,e),t.linkProgram(this._prg),t.getProgramParameter(this._prg,t.LINK_STATUS)||alert("Could not initialise shaders"),t.useProgram(this._prg),t.enable(t.BLEND),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_DST_COLOR),this._vpScaleLocal=t.getUniformLocation(this._prg,"uViewportScale"),this._vpTranslationLocal=t.getUniformLocation(this._prg,"uViewportTranslation"),this._vpRotationLocal=t.getUniformLocation(this._prg,"uViewportRotation"),this._vecLocal=t.getUniformLocation(this._prg,"uConversionVec2")}loadShader(t,n,e){const r=t.createShader(n);return t.shaderSource(r,e),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)?r:(alert("An error occurred compiling the shaders: "+t.getShaderInfoLog(r)),t.deleteShader(r),null)}render(){this.canRending&&(this.draw(),window.requestAnimationFrame(()=>this.render()))}draw(t=null,n=!1){const e=this.gl,r=this.updateViewport(),o=this.updateConversionVec();let i=!1,a=[];const s=this._unitList;a=t&&t.length>0?t.map(t=>s[t]):s,a.forEach(t=>{t.forEach(t=>{t.updateToGL()&&(i=!0)})}),(n||r||o||i)&&(e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),a.forEach(t=>{t.filter(t=>t.display==ot.DISPLAY).forEach(t=>{t.updateUniform(),t.draw()})}))}updateViewport(){const t=this.gl;let n=!1;return this._vp.vpScaleIsModified&&(t.uniform2fv(this._vpScaleLocal,this._vp.vpScaleVec2.map(t=>t*this._sizeRatio)),this._vp.vpScaleIsModified=!1,n=!0),this._vp.vpTranslationIsModified&&(t.uniform2fv(this._vpTranslationLocal,this._vp.vpTranslationVec2),this._vp.vpTranslationIsModified=!1,n=!0),this._vp.vpRotationIsModified&&(t.uniform1f(this._vpRotationLocal,this._vp.vpRotation),this._vp.vpRotationIsModified=!1,n=!0),n}updateConversionVec(){if(this._vp.cvMatIsModified){const t=this.gl;return t.uniform2fv(this._vecLocal,this._vp.cvec2),this._vp.cvMatIsModified=!1,!0}return!1}registVAO(t,n=0){return this._unitList[n]||(this._unitList[n]=[]),this._unitList[n].push(t),t}unRegistVAO(t,n=0){if(n>=this._unitList.length)return;const e=this._unitList[n].indexOf(t);e<0||this._unitList[n].splice(e,1)}}const mt={TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class bt{constructor(t,n,e,r,o){Object(k["a"])(this,"_vertexes",void 0),Object(k["a"])(this,"_offsetRatios",void 0),Object(k["a"])(this,"_uv",void 0),Object(k["a"])(this,"_indeces",void 0),Object(k["a"])(this,"_primitiveMode",void 0),this._vertexes=n,this._offsetRatios=e,this._uv=r,this._indeces=o,this._primitiveMode=t}get currVertexes(){return this._vertexes}get prevVertexes(){let t=this._vertexes;return t.slice(-2).concat(t.slice(0,t.length-2))}get nextVertexes(){let t=this._vertexes;return t.slice(2).concat(t.slice(0,2))}get currOffsetRatios(){return this._offsetRatios}get prevOffsetRatios(){let t=this._offsetRatios;return t.slice(-2).concat(t.slice(0,t.length-2))}get nextOffsetRatios(){let t=this._offsetRatios;return t.slice(2).concat(t.slice(0,2))}get originMeshConfig(){let t=new Array(this._vertexes.length);return t.fill(0),{currVertexes:this.currVertexes,prevVertexes:this.prevVertexes,nextVertexes:this.nextVertexes,currOffsetRatios:this.currOffsetRatios,prevOffsetRatios:this.prevOffsetRatios,nextOffsetRatios:this.nextOffsetRatios,edgeOffsetRatios:t,indeces:this._indeces,uvs:this._uv,primitiveMode:this._primitiveMode}}get borderMeshConfig(){let t=this.currVertexes.length,n=this.currVertexes,e=this.prevVertexes,r=this.nextVertexes,o=this.currOffsetRatios,i=this.prevOffsetRatios,a=this.nextOffsetRatios,s=new Array(2*t),c=new Array;s.fill(0);let l=new Array(t/2);l.fill(0);let d=new Array(t/2);d.fill(1);let h=l.concat(d);t/=2;for(let u=0;u<t;u++)c[2*u]=u,c[2*u+1]=t+u;return c.push(c[0],c[1]),n=n.concat(n),e=e.concat(e),r=r.concat(r),o=o.concat(o),i=i.concat(i),a=a.concat(a),{currVertexes:n,prevVertexes:e,nextVertexes:r,currOffsetRatios:o,prevOffsetRatios:i,nextOffsetRatios:a,edgeOffsetRatios:h,indeces:c,uvs:s,primitiveMode:mt.TRIANGLE_STRIP}}}class gt extends bt{constructor(t=0,n=0){const e=[0,0,0,0,0,0,0,0];let r=[-.5,.5,-.5,-.5,.5,-.5,.5,.5];const o=[0,1,0,0,1,0,1,1],i=[0,1,3,2];r=r.map((e,r)=>r%2==0?e-t:e-n),super(mt.TRIANGLE_STRIP,e,r,o,i)}}class xt extends bt{constructor(t=20,n=20){const e=[-.2,0,.2,0,.2,0,.5,0,0,1,-.5,0,-.2,0].map((e,r)=>r%2==0?e*t:e*n),r=[0,0,0,0,0,1,0,1,0,1,0,1,0,1],o=new Array(e.length),i=[0,1,6,2,5,3,4];super(mt.TRIANGLE_STRIP,e,r,o,i)}}class At extends bt{constructor(t=20,n=20){const e=[0,0,.5,1,.2,1,.2,1,.5,1,0,2,-.5,1,-.2,1,-.2,1,-.5,1].map((e,r)=>r%2==0?e*t:e*n),r=[0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0],o=new Array(e.length),i=[0,1,9,2,8,3,7,4,6,5];super(mt.TRIANGLE_STRIP,e,r,o,i)}}const wt=3e3,Mt=et["mat4"],Ot=et["vec3"],yt={CURR_VERTEX_AND_RATIO:"currVertexAndRatio",NEXT_VERTEX_AND_RATIO:"nextVertexAndRatio",PREV_VERTEX_AND_RATIO:"prevVertexAndRatio",UV_AND_EDGE_OFFSET_RATIO:"uvAndEdgeOffsetRatio"};var Tt=new Map;Tt.set(yt.CURR_VERTEX_AND_RATIO,4),Tt.set(yt.NEXT_VERTEX_AND_RATIO,4),Tt.set(yt.PREV_VERTEX_AND_RATIO,4),Tt.set(yt.UV_AND_EDGE_OFFSET_RATIO,4);const St={VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT:"vertexAndEdgeOffsetValueAndNotFollowViewport",BACKGROUND_COLOR:"backgroundColor",UV_RECT:"UVRect",TRANSLATION_AND_ROTATION:"translationAndRotation",IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE:"isTextAndBorderWidthAndDashedAndScale",TEXT_BORDER_COLOR:"textBorderColor",OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS:"opacityAndDisplayAndVpScaleAndVpTrans"};var Et=new Map;Et.set(St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,4),Et.set(St.BACKGROUND_COLOR,4),Et.set(St.UV_RECT,4),Et.set(St.TRANSLATION_AND_ROTATION,4),Et.set(St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,4),Et.set(St.TEXT_BORDER_COLOR,4),Et.set(St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,4);const Dt=[St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,St.BACKGROUND_COLOR,St.UV_RECT,St.TRANSLATION_AND_ROTATION,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,St.TEXT_BORDER_COLOR,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS],Rt={OPACITY:"uOpacity"},Vt=[Rt.OPACITY];class Pt{constructor(t,n,e=0){Object(k["a"])(this,"_engine",void 0),Object(k["a"])(this,"idmap",void 0),Object(k["a"])(this,"idlist",void 0),Object(k["a"])(this,"_meshConfig",void 0),Object(k["a"])(this,"vao",void 0),Object(k["a"])(this,"instanceCount",0),Object(k["a"])(this,"instanceCountMax",0),Object(k["a"])(this,"instanceCountInited",0),Object(k["a"])(this,"attribBuffers",new Map),Object(k["a"])(this,"attribBufferDatas",new Map),Object(k["a"])(this,"attribIsModifieds",new Map),Object(k["a"])(this,"attribLocals",new Map),Object(k["a"])(this,"uniformLocals",new Map),Object(k["a"])(this,"uniformDatas",new Map),Object(k["a"])(this,"_display",ot.DISPLAY),Object(k["a"])(this,"displayIsModified",!1),this._engine=t,this._meshConfig=n;const r=t.gl,o=t.prg,i=Math.floor(e);this.instanceCountMax=i>0?i:wt,this.instanceCountInited=this.instanceCountMax,Dt.forEach(t=>{const n=new Float32Array(this.instanceCountMax*Et.get(t));this.attribBuffers.set(t,r.createBuffer()),this.attribBufferDatas.set(t,n),this.attribIsModifieds.set(t,!0),this.attribLocals.set(t,r.getAttribLocation(o,t))}),Vt.forEach(t=>{this.uniformLocals.set(t,r.getUniformLocation(o,t)),this.uniformDatas.set(t,new Float32Array(4))}),this.uniformDatas.set(Rt.OPACITY,new Float32Array([1,0,0,0])),this.idmap=new Map,this.idlist=[]}regist(){const t=this._engine.gl,n=this._meshConfig,e=n.currVertexes,r=n.prevVertexes,o=n.nextVertexes,i=n.currOffsetRatios,a=n.prevOffsetRatios,s=n.nextOffsetRatios,c=e.length/2,l=[],d=[],h=[],u=[],p=n.uvs,v=n.edgeOffsetRatios;for(let f=0;f<c;f++)l.push(e[2*f],e[2*f+1],i[2*f],i[2*f+1]),d.push(r[2*f],r[2*f+1],a[2*f],a[2*f+1]),h.push(o[2*f],o[2*f+1],s[2*f],s[2*f+1]),u.push(p[2*f],p[2*f+1],v[f],0);return this.vao=t.createVertexArray(),t.bindVertexArray(this.vao),this.registAttribute(yt.CURR_VERTEX_AND_RATIO,new Float32Array(l)),this.registAttribute(yt.PREV_VERTEX_AND_RATIO,new Float32Array(d)),this.registAttribute(yt.NEXT_VERTEX_AND_RATIO,new Float32Array(h)),this.registAttribute(yt.UV_AND_EDGE_OFFSET_RATIO,new Float32Array(u)),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint32Array(this._meshConfig.indeces),t.STATIC_DRAW),t.bindVertexArray(null),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),this}updateToGL(){const t=this._engine.gl;let n=this.displayIsModified;return t.bindVertexArray(this.vao),Dt.forEach(t=>{!0===this.attribIsModifieds.get(t)&&(this.updateBufferToGL(t,this.attribBuffers.get(t),this.attribBufferDatas.get(t),Et.get(t)),this.attribIsModifieds.set(t,!1),n=!0)}),this.displayIsModified=!1,n}updateUniform(){const t=this.engine.gl;Vt.forEach(n=>{t.uniform4fv(this.uniformLocals.get(n),this.uniformDatas.get(n))})}setAttribute(t,n,e,r=0){if(!t||""==t)return;const o=this.idmap.get(t),i=Et.get(n);let a;a=this.attribBufferDatas.get(n),this.attribIsModifieds.set(n,!0),a.set(e.slice(0,i-r),o*i+r)}getAttribute(t,n,e=0,r=0){const o=this.idmap.get(t),i=Et.get(n);let a;a=this.attribBufferDatas.get(n),this.attribIsModifieds.set(n,!0);const s=o*i+e;let c;return c=r>0?Math.min(s+r,(o+1)*i):(o+1)*i,Array.from(a.subarray(s,c))}add(){this.instanceCount==this.instanceCountMax&&this.grow();const t=this.createId(),n=this.instanceCount;return this.idmap.set(t,n),this.idlist[n]=t,this.instanceCount++,Dt.forEach(t=>this.attribIsModifieds.set(t,!0)),t}remove(t){const n=this.idmap.get(t),e=this.instanceCount;if(e<1||n<0||n>=e)return;Dt.forEach(n=>{this.removeAttributeBufferData(t,n),this.attribIsModifieds.set(n,!0)});const r=this.idlist[this.instanceCount-1];this.idmap.set(r,n),this.idlist[n]=r,this.idmap.delete(t),this.idlist.pop(),this.instanceCount--}clear(){if(this.instanceCountMax>this.instanceCountInited){const t=this.instanceCountMax/this.instanceCountInited;Dt.forEach(n=>{const e=this.attribBufferDatas.get(n).length;this.attribBufferDatas.set(n,new Float32Array(e/t))}),this.instanceCountMax=this.instanceCountInited}else this.attribBufferDatas.forEach(t=>t.fill(0));this.attribIsModifieds.forEach((t,n)=>this.attribIsModifieds.set(n,!0)),this.idmap.clear(),this.idlist=[],this.instanceCount=0}fill(t,n){this.attribBufferDatas.get(t).fill(n),this.attribIsModifieds.set(t,!0)}batchSet(t,n,e=0){const r=Et.get(t);if(r<=e)return;const o=this.attribBufferDatas.get(t),i=this.instanceCount,a=n.slice(0,r-e);let s=e;for(let c=0;c<i;c++)o.set(a,s),s+=r;this.attribIsModifieds.set(t,!0)}batchAdd(t,n,e=0){const r=Et.get(t);if(r<=e)return;const o=this.attribBufferDatas.get(t),i=this.instanceCount,a=n.slice(0,r-e),s=a.length;let c=e;for(let l=0;l<i;l++){for(let t=0;t<s;t++)o[c+t]+=a[t];c+=r}this.attribIsModifieds.set(t,!0)}destroy(){this.attribBuffers.clear(),this.attribBufferDatas.clear(),this.attribIsModifieds.clear(),this.idmap.clear(),this.idlist=[],this.instanceCount=0,this.vao=null}draw(){const t=this._engine.gl,n=this._meshConfig;t.bindVertexArray(this.vao),t.drawElementsInstanced(n.primitiveMode,n.indeces.length,t.UNSIGNED_INT,0,this.instanceCount)}set display(t){this._display=t}get display(){return this._display}set opacity(t){const n=Math.max(0,t),e=this.uniformDatas.get(Rt.OPACITY);e.set([n],0),this.displayIsModified=!0}get opacity(){return this.uniformDatas.get(Rt.OPACITY)[0]}get engine(){return this._engine}getVertexesPositionById(t,n=0){let e=this._meshConfig.currVertexes;const r=this._meshConfig.currOffsetRatios,o=this.getAttribute(t,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,0,2),i=this.getAttribute(t,St.TRANSLATION_AND_ROTATION,0,2),a=this.getAttribute(t,St.TRANSLATION_AND_ROTATION,2,1)[0],s=e.length/2;let c=Mt.create();Mt.fromZRotation(c,-a);let l=[];for(let h=0;h<s;h++){const t=Ot.fromValues(e[2*h],e[2*h+1],0),n=Ot.fromValues(r[2*h],r[2*h+1],0);let i=lt(t,n,Ot.fromValues(o[0],o[1],0));l.push(i)}const d=[];for(let h=0;h<s;h++){let t=0==h?s-1:h-1,e=h==s-1?0:h+1;const r=l[t],o=l[h],a=l[e],u=r.map((t,n)=>t-o[n]),p=a.map((t,n)=>t-o[n]);let v=ct(u,p,o,n);Ot.transformMat4(v,v,c),Ot.add(v,v,Ot.fromValues(i[0],i[1],0)),d.push(v[0],v[1])}return d}createId(){return st.createId()}registAttribute(t,n){const e=this.engine.gl,r=this.engine.prg,o=e.createBuffer(),i=Tt.get(t),a=e.getAttribLocation(r,t);e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),e.vertexAttribPointer(a,i,e.FLOAT,!1,0,0),e.enableVertexAttribArray(a)}updateBufferToGL(t,n,e,r,o=0){const i=this._engine.gl,a=(this._engine.prg,e.BYTES_PER_ELEMENT),s=this.attribLocals.get(t),c=this.instanceCount;i.bindBuffer(i.ARRAY_BUFFER,n),i.bufferData(i.ARRAY_BUFFER,e,i.DYNAMIC_DRAW,0,c*r),i.enableVertexAttribArray(s),i.vertexAttribPointer(s,r,i.FLOAT,!1,r*a,o*a),i.vertexAttribDivisor(s,1),i.bindBuffer(i.ARRAY_BUFFER,null)}removeAttributeBufferData(t,n){const e=this.idmap.get(t),r=this.attribBufferDatas.get(n),o=Et.get(n),i=Math.max(1,this.instanceCount-1),a=new Array(o);a.fill(0),r.set(r.slice(i*o,(i+1)*o),e*o),r.set(a,i*o)}grow(){Dt.forEach(t=>{let n=this.attribBufferDatas.get(t),e=new Float32Array(2*n.length);e.set(n),this.attribBufferDatas.set(t,e),n=null}),this.instanceCountMax*=2}}const It=window.devicePixelRatio,Nt={NONE:0,X:1,Y:2,BOTH:3};class Ct extends q{constructor(t,n){super(t.engine.searcher),Object(k["a"])(this,"_id",void 0),Object(k["a"])(this,"_originUnit",void 0),Object(k["a"])(this,"_borderUnit",void 0),Object(k["a"])(this,"_originId",void 0),Object(k["a"])(this,"_borderId",void 0),Object(k["a"])(this,"_isAdded",void 0),Object(k["a"])(this,"_isBorderAdded",void 0),Object(k["a"])(this,"_texture",void 0),Object(k["a"])(this,"_needReset",!1),Object(k["a"])(this,"_attribs",{translation:[0,0],rotation:0,scale:1,backgroundColor:[0,0,0,0],uv:null,vertexOffsetValue:[0,0],isText:!1,textBorderWidth:0,textBorderColor:[0,0,0,0],borderWidth:0,borderColor:[0,0,0,0],borderDashed:0,opacity:1,display:ot.DISPLAY,outViewportStatus:Nt.NONE,attachViewportScale:!0,attachViewportTranslation:!0}),Object(k["a"])(this,"_attriblist",["vertexOffsetValue","translation","rotation","scale","backgroundColor","uv","borderWidth","borderColor","borderDashed","isText","textBorderWidth","textBorderColor","opacity","display","outViewportStatus","attachViewportScale","attachViewportTranslation"]),this._originUnit=t,this._borderUnit=n,this._id=st.createId()}get id(){return this._id}get engine(){return this._originUnit.engine}get isShown(){return this._isAdded}show(){return this._isAdded||(this._originId=this._originUnit.add(),this._isAdded=!0,this.updateStatus(),this.searchable&&this.registToSearcher()),this.borderWidth=this.borderWidth,this}hide(){return this._isAdded&&this._originUnit.remove(this._originId),this._isBorderAdded&&this._borderUnit.remove(this._borderId),this._isAdded=!1,this._isBorderAdded=!1,this._originId=null,this._borderId=null,this.deregistToSearcher(),this}set translation(t){this._isAdded&&this._originUnit.setAttribute(this._originId,St.TRANSLATION_AND_ROTATION,t,0),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,St.TRANSLATION_AND_ROTATION,t,0),this._attribs["translation"]=t,this.searchable&&this.registToSearcher()}get translation(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.TRANSLATION_AND_ROTATION,0,2):this._attribs["translation"]}set rotation(t){const n=[t];this._isAdded&&this._originUnit.setAttribute(this._originId,St.TRANSLATION_AND_ROTATION,n,2),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,St.TRANSLATION_AND_ROTATION,n,2),this._attribs["rotation"]=t,this.searchable&&this.registToSearcher()}get rotation(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.TRANSLATION_AND_ROTATION,2,1)[0]:this._attribs["rotation"]}set scale(t){const n=[t];this._isAdded&&this._originUnit.setAttribute(this._originId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,n,3),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,n,3),this._attribs["scale"]=t,this.searchable&&this.registToSearcher()}get scale(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,3,1)[0]:this._attribs["scale"]}set backgroundColor(t){const n=t.map(t=>t/255);this._isAdded&&this._originUnit.setAttribute(this._originId,St.BACKGROUND_COLOR,n),this._attribs["backgroundColor"]=t}get backgroundColor(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.BACKGROUND_COLOR,0,4).map(t=>255*t):this._attribs["backgroundColor"]}set texture(t){if(null==t)return this._texture&&this._texture instanceof nt&&(this._texture.removeEventListener(tt.UPDATE,this.changeUV,this),this._texture=null),void this.changeUV(null);if(!(t instanceof nt))return;const n=this._texture,e=t;(this._needReset||n!=e)&&(n instanceof nt&&n.removeEventListener(tt.UPDATE,this.changeUV,this),this._texture=t,this.changeUV(this._texture),this._texture.addEventListener(tt.UPDATE,this.changeUV,this))}set borderWidth(t){if(this._isBorderAdded&&t==this._attribs.borderWidth)return;this._attribs["borderWidth"]=t;const n=[t];this._isBorderAdded?t>0?this._borderUnit.setAttribute(this._borderId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,n,2):this.removeBorder():t>0&&this.addBorder()}get borderWidth(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,2,1)[0]:this._attribs["borderWidth"]}set borderColor(t){const n=t.map(t=>t/255);this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,St.BACKGROUND_COLOR,n),this._attribs["borderColor"]=t}get borderColor(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,St.BACKGROUND_COLOR,0,4).map(t=>255*t):this._attribs["borderColor"]}set borderDashed(t){this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[t*It],2),this._attribs.borderDashed=t}get borderDashed(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,2,1)[0]:this._attribs.borderDashed}set vertexOffsetValue(t){this._originUnit.setAttribute(this._originId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,t),this._borderUnit.setAttribute(this._borderId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,t),this._attribs["vertexOffsetValue"]=t,this.searchable&&this.registToSearcher()}get vertexOffsetValue(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,0,2):this._attribs["vertexOffsetValue"]}set size(t){this.vertexOffsetValue=t}get size(){return this.vertexOffsetValue}set isText(t){let n=t?1:0;const e=[n];this._originUnit.setAttribute(this._originId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,e,0),this._attribs["isText"]=t}get isText(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,0,1)[0]:this._attribs["isText"]}set textBorderWidth(t){const n=[t];this._originUnit.setAttribute(this._originId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,n,1),this._attribs["textBorderWidth"]=t}get textBorderWidth(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,1,1)[0]:this._attribs["textBorderWidth"]}set textBorderColor(t){this._originUnit.setAttribute(this._originId,St.TEXT_BORDER_COLOR,t.map(t=>t/255)),this._attribs["textBorderColor"]=t}get textBorderColor(){return this._attribs["textBorderColor"]}set opacity(t){const n=Math.max(0,t),e=[n];this._originUnit.setAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,0),this._borderUnit.setAttribute(this._borderId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,0),this._attribs["opacity"]=n}get opacity(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,0,1)[0]:this._attribs["opacity"]}set display(t){const n=[t];this._originUnit.setAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,1),this._borderUnit.setAttribute(this._borderId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,1),this._attribs["display"]=t}get display(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,1)[0]:this._attribs["display"]}set outViewportStatus(t){const n=[t];this._originUnit.setAttribute(this._originId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,n,3),this._borderUnit.setAttribute(this._borderId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,n,3),this._attribs["outViewportStatus"]=t}get outViewportStatus(){return this._isAdded?this._originUnit.getAttribute(this._originId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,3,1)[0]:this._attribs["outViewportStatus"]}set attachViewportScale(t){const n=t?1:0,e=[n];this._originUnit.setAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,2),this._borderUnit.setAttribute(this._borderId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,2),this._attribs["attachViewportScale"]=t}get attachViewportScale(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,2,1)[0]:this._attribs["attachViewportScale"]}set attachViewportTranslation(t){const n=t?1:0,e=[n];this._originUnit.setAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,3),this._borderUnit.setAttribute(this._borderId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,3),this._attribs["attachViewportTranslation"]=t}get attachViewportTranslation(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,3,1)[0]:this._attribs["attachViewportTranslation"]}getVertexPositions(t=0){return this._originUnit.getVertexesPositionById(this._originId,t)}changeUV(t){if(t&&t instanceof nt){const n=[t.u,t.v,t.width,t.height];this._isAdded&&this._originUnit.setAttribute(this._originId,St.UV_RECT,n),this._attribs["uv"]=n}else this._isAdded&&this._originUnit.setAttribute(this._originId,St.UV_RECT,[0,0,0,0])}updateStatus(){this._needReset=!0;this._attriblist;const t=this._attribs;this._isAdded&&(this._originUnit.setAttribute(this._originId,St.TRANSLATION_AND_ROTATION,[t["translation"][0],t["translation"][1],t["rotation"]]),this._originUnit.setAttribute(this._originId,St.BACKGROUND_COLOR,t["backgroundColor"].map(t=>t/255)),this._originUnit.setAttribute(this._originId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[t["isText"]?1:0,0,0,t["scale"]]),this._originUnit.setAttribute(this._originId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,[t["opacity"],t["display"],t["attachViewportScale"]?1:0,t["attachViewportTranslation"]?1:0]),this._originUnit.setAttribute(this._originId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,[t["vertexOffsetValue"][0],t["vertexOffsetValue"][1],t["borderWidth"],t["outViewportStatus"]])),this.changeUV(this._texture),this._needReset=!1}addBorder(){this._isBorderAdded||(this._borderId=this._borderUnit.add(),this._borderUnit.setAttribute(this._borderId,St.TRANSLATION_AND_ROTATION,[this.translation[0],this.translation[1],this.rotation],0),this._borderUnit.setAttribute(this._borderId,St.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,[this.vertexOffsetValue[0],this.vertexOffsetValue[1],this.borderWidth,this.outViewportStatus],0),this._borderUnit.setAttribute(this._borderId,St.BACKGROUND_COLOR,this.borderColor.map(t=>t/255),0),this._borderUnit.setAttribute(this._borderId,St.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[this.borderDashed*It,this.scale],2),this._borderUnit.setAttribute(this._borderId,St.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,[this.opacity,this.display,this.attachViewportScale?1:0,this.attachViewportTranslation?1:0],0),this._isBorderAdded=!0)}removeBorder(){this._isBorderAdded&&(this._borderUnit.remove(this._borderId),this._borderId=void 0,this._isBorderAdded=!1)}}const Lt=et["vec2"],jt={ONE_WAY:1,TWO_WAY:2};class Bt extends q{constructor(t,n,e,r=0){super(t.engine.searcher),Object(k["a"])(this,"_type",jt.ONE_WAY),Object(k["a"])(this,"_id",void 0),Object(k["a"])(this,"_height",void 0),Object(k["a"])(this,"_indent",void 0),Object(k["a"])(this,"_fromTo",[0,0,0,0]),Object(k["a"])(this,"_oneObj",void 0),Object(k["a"])(this,"_twoObj",void 0),Object(k["a"])(this,"_isShown",!1),this._id=st.createId(),this._oneObj=t,this._twoObj=n,this._height=e,this._indent=r}get robj(){return this._type==jt.ONE_WAY?this._oneObj:this._twoObj}get nobj(){return this._type==jt.TWO_WAY?this._oneObj:this._twoObj}get id(){return this._id}get isShown(){return this._isShown}show(){return this._isShown||(this.robj.show(),this.nobj.hide(),this.setFromToAndWidth(),this._isShown=!0),this}hide(){return this._isShown?(this.robj.hide(),this._isShown=!1,this.deregistToSearcher(),this):this}get rid(){return this.robj.id}set fromTo(t){this._fromTo=t,this.setFromToAndWidth()}get fromTo(){return this._fromTo}set type(t){t!=this._type&&(this._type=t,this.nobj.hide(),this._isShown&&(this.robj.show(),this.borderWidth=this.nobj.borderWidth,this.borderColor=this.nobj.borderColor,this.borderDashed=this.nobj.borderDashed,this.opacity=this.nobj.opacity,this.display=this.nobj.display,this.backgroundColor=this.nobj.backgroundColor,this.outViewportStatus=this.nobj.outViewportStatus,this.attachViewportScale=this.nobj.attachViewportScale,this.attachViewportTranslation=this.nobj.attachViewportTranslation,this.setFromToAndWidth()))}get type(){return this._type}set backgroundColor(t){this.robj.backgroundColor=t}get backgroundColor(){return this.robj.backgroundColor}set borderWidth(t){this.robj.borderWidth=t}get borderWidth(){return this.robj.borderWidth}set borderColor(t){this.robj.borderColor=t}get borderColor(){return this.robj.borderColor}set borderDashed(t){this.robj.borderDashed=t}get borderDashed(){return this.robj.borderDashed}set opacity(t){this.robj.opacity=t}get opacity(){return this.robj.opacity}set display(t){this.robj.display=t}get display(){return this.robj.display}set outViewportStatus(t){this.robj.outViewportStatus=t}get outViewportStatus(){return this.robj.outViewportStatus}set attachViewportScale(t){this.robj.attachViewportScale=t}get attachViewportScale(){return this.robj.attachViewportScale}set attachViewportTranslation(t){this.robj.attachViewportTranslation=t}get attachViewportTranslation(){return this.robj.attachViewportTranslation}setFromToAndWidth(){const t=this._fromTo,n=this._indent,e=Lt.fromValues(t[0],t[1]),r=Lt.fromValues(t[2],t[3]),o=Lt.sub(Lt.create(),r,e),i=Lt.normalize(Lt.create(),o),a=Lt.len(o)-2*n,s=Lt.add(Lt.create(),i.map(t=>t*n),e),c=Math.atan2(o[0],o[1]);let l;l=this.type==jt.ONE_WAY?Math.max(0,a-this._height):Math.max(0,a-2*this._height),this.robj.translation=s,this.robj.rotation=c,this.robj.vertexOffsetValue=[0,l],this.searchable&&this.registToSearcher()}getVertexPositions(t=0){return this.robj.getVertexPositions(t)}}class Ft{constructor(t,n,e=0,r=1,o=0){Object(k["a"])(this,"_engine",void 0),Object(k["a"])(this,"originUnit",void 0),Object(k["a"])(this,"borderUnit",void 0),Object(k["a"])(this,"originIdx",void 0),Object(k["a"])(this,"borderIdx",void 0),this._engine=t,this.originIdx=Math.floor(e),this.borderIdx=Math.floor(r),this.originUnit=new Pt(t,n.originMeshConfig,o).regist(),this.borderUnit=new Pt(t,n.borderMeshConfig,o).regist(),this.engine.registVAO(this.originUnit,this.originIdx),this.engine.registVAO(this.borderUnit,this.borderIdx)}instance(){return new Ct(this.originUnit,this.borderUnit)}destroy(){this.engine.unRegistVAO(this.originUnit,this.originIdx),this.engine.unRegistVAO(this.borderUnit,this.borderIdx),this.originUnit.destroy(),this.borderUnit.destroy(),this.originUnit=null,this.borderUnit=null}clear(){this.originUnit.clear(),this.borderUnit.clear()}set opacity(t){this.originUnit.opacity=t,this.borderUnit.opacity=t}set display(t){this.originUnit.display=t,this.borderUnit.display=t}set translate(t){this.originUnit.batchAdd(St.TRANSLATION_AND_ROTATION,t,0),this.borderUnit.batchAdd(St.TRANSLATION_AND_ROTATION,t,0)}get engine(){return this._engine}}class kt{constructor(t,n,e,r=0,o=0,i=1,a=0){Object(k["a"])(this,"_engine",void 0),Object(k["a"])(this,"og",void 0),Object(k["a"])(this,"tg",void 0),Object(k["a"])(this,"_height",void 0),Object(k["a"])(this,"_indent",void 0),this._engine=t,this.og=new Ft(t,new xt(n,e),o,i,a),this.tg=new Ft(t,new At(n,e),o,i,a),this._height=e,this._indent=r}instance(){return new Bt(this.og.instance(),this.tg.instance(),this._height,this._indent)}destroy(){this.og.destroy(),this.tg.destroy(),this.og=null,this.tg=null}clear(){this.og.clear(),this.tg.clear()}set translate(t){this.og.translate=t,this.tg.translate=t}set display(t){this.og.display=t,this.tg.display=t}set opacity(t){this.og.opacity=t,this.tg.opacity=t}get engine(){return this._engine}}function Ut(){return[255*Math.random(),255*Math.random(),255*Math.random(),255]}function Wt(t,n,e=!1){let r=null;return function(...o){if(r&&window.clearTimeout(r),e){let e=!r;e&&t.apply(this,o),r=setTimeout(()=>{r=null},n)}else r=setTimeout(()=>{t.apply(this,o),r=null},n)}}function Ht(t,n){let e=!0;return function(...r){e&&(t.apply(this,r),e=!1,setTimeout(()=>{e=!0},n))}}const Gt=e("8554"),Yt=e("405a"),qt=e("11d9"),zt=e("bafb");var Xt={name:"xxx",components:{},data(){return{arrowType:1,vpOffsetX:0,vpOffsetY:0,vpOx:0,vpOy:0,vpScaleRatio:1}},mounted(){this.initCtx()},methods:{initCtx(){const t=document.getElementById("canvas");let n=new _t(t);n.isDebug=!1,n.sizeRatio=1;n.searcher;let e=n.textureFactroy,r=n.viewport;r.setBackgroundColor([186,186,186,255]),window.vp=r,window.engine=n;let o=[];console.log("engine",n),at([Gt,Yt,qt,zt]).then(t=>{o=t.map(t=>{e.createTexture(t,t.width,t.height)}),window.textures=o,this.initRender(n,o)})},initRender(t,n){t.render()},handleClear(){window.g1&&window.g1.clear(),window.g2&&window.g2.clear(),window.g3&&window.g3.clear()},handleSetVp(){const t=+this.vpOffsetX,n=+this.vpOffsetY,e=+this.vpScaleRatio,r=+this.vpOx,o=+this.vpOy;window["vp"].resetTranslationAndScale(t,n,e,r,o),console.log(window["vp"])},handleDrawArrow(){1==this.arrowType?this.drawOneWayArrow():this.drawTwoWayArrow()},handleDrawRect(){this.drawRects(window.engine,window.textures[0],10,0,0,600)},drawRects(t,n,e,r,o,i){const a=new gt,s=new Ft(t,a);window.g1=s;const c=e,l=i/c;for(let d=0;d<c;d++)for(let t=0;t<c;t++){let e=Ut();e[3]=200;let i=s.instance();i.searchable=!1,i.show(),i.translation=[d*l+l/2+r,t*l+l/2+o],i.backgroundColor=e,i.texture=n,i.size=[l,l],i.rotation=Math.PI/6,d%3==0&&(i.borderWidth=1,i.borderDashed=2,i.borderColor=Ut())}},drawOneWayArrow(){const t=new xt(100,100),n=new Ft(window.engine,t);window.g2=n;const e=n.instance().show();e.translation=[300,300],e.vertexOffsetValue=[0,100],e.rotation=Math.PI/4,e.backgroundColor=Ut(),e.searchable=!0,e.expandRadius=20},drawTwoWayArrow(){const t=new kt(window.engine,100,100,10);window.g3=t;const n=t.instance();n.fromTo=[0,0,200,200],n.type=2,n.show(),n.backgroundColor=Ut(),n.borderWidth=3,n.borderDashed=10,n.borderColor=[0,0,0,255],n.searchable=!0,n.expandRadius=20}}},Jt=Xt,$t=(e("e891"),Object(d["a"])(Jt,B,F,!1,null,"59e8921a",null)),Kt=$t.exports,Zt=function(){var t=this,n=t._self._c;return n("div",{staticClass:"flow"},[n("div",{staticClass:"left"},[n("h3",[t._v("节点物料区")]),n("div",{staticClass:"node-wrapper",on:{dragstart:t.onNodeDragStart}},t._l(t.nodeTypeList,(function(e){return n("div",{key:e.code,staticClass:"drag-node",class:e.code,attrs:{draggable:"","data-type":e.code},on:{mousedown:t.onNodeTypClick}},[t._v(" "+t._s(e.name)+" ")])})),0),n("el-button",{staticClass:"confirm-btn",attrs:{type:"primary"},on:{click:t.handleDone}},[t._v("提交流程图")])],1),n("div",{staticClass:"center"},[n("main",{ref:"canvas-wrapper",on:{dragover:t.onNodeDragOver,drop:t.onNodeDrop}},[n("div",{ref:"canvas",attrs:{id:"flow-canvas"}})])]),n("div",{staticClass:"right"},[n("h3",[t._v("属性编辑区")]),n("div",{directives:[{name:"show",rawName:"v-show",value:t.flowInfoVisible,expression:"flowInfoVisible"}],staticClass:"flow-props"},[n("FlowProps")],1),n("div",{directives:[{name:"show",rawName:"v-show",value:t.nodeInfoVisible,expression:"nodeInfoVisible"}],staticClass:"node-props"},[n("h4",[t._v("节点属性配置")]),n("el-form",{ref:"nodeForm",attrs:{model:t.nodeForm,rules:t.rules,"label-width":"100px"}},[n("el-form-item",{attrs:{label:"节点类型",prop:"nodeType"}},[n("span",[t._v(t._s(t.nodeType2NameMap[t.nodeForm.nodeType]))])]),n("el-form-item",{directives:[{name:"show",rawName:"v-show",value:t.isBranchOrDelay||t.isBussiness,expression:"isBranchOrDelay || isBussiness"}],attrs:{label:"节点名称",prop:"nodeId"}},[n("el-select",{attrs:{placeholder:"请选择"},model:{value:t.nodeForm.nodeId,callback:function(n){t.$set(t.nodeForm,"nodeId",n)},expression:"nodeForm.nodeId"}},[n("el-option",{attrs:{label:"功能节点1",value:"111"}}),n("el-option",{attrs:{label:"功能节点2",value:"222"}}),n("el-option",{attrs:{label:"功能节点3",value:"333"}})],1)],1),n("el-form-item",{directives:[{name:"show",rawName:"v-show",value:t.isBranchOrDelay||t.isBussiness,expression:"isBranchOrDelay || isBussiness"}],attrs:{label:"节点别名",prop:"nodeAlias"}},[n("el-input",{model:{value:t.nodeForm.nodeAlias,callback:function(n){t.$set(t.nodeForm,"nodeAlias","string"===typeof n?n.trim():n)},expression:"nodeForm.nodeAlias"}})],1),n("el-form-item",{directives:[{name:"show",rawName:"v-show",value:t.isBussiness,expression:"isBussiness"}],attrs:{label:"执行上级库存",prop:"executeParentStoresFlag"}},[n("el-switch",{attrs:{"active-value":1,"inactive-value":0},model:{value:t.nodeForm.executeParentStoresFlag,callback:function(n){t.$set(t.nodeForm,"executeParentStoresFlag",n)},expression:"nodeForm.executeParentStoresFlag"}})],1),n("el-form-item",{directives:[{name:"show",rawName:"v-show",value:t.isBussiness,expression:"isBussiness"}],attrs:{label:"执行本级库存",prop:"executeThisStoresFlag"}},[n("el-switch",{attrs:{"active-value":1,"inactive-value":0},model:{value:t.nodeForm.executeThisStoresFlag,callback:function(n){t.$set(t.nodeForm,"executeThisStoresFlag",n)},expression:"nodeForm.executeThisStoresFlag"}})],1),n("el-form-item",{directives:[{name:"show",rawName:"v-show",value:t.isBussiness,expression:"isBussiness"}],attrs:{label:"规则应用",prop:"ruleId"}},[n("el-select",{attrs:{placeholder:"请选择"},model:{value:t.nodeForm.ruleId,callback:function(n){t.$set(t.nodeForm,"ruleId",n)},expression:"nodeForm.ruleId"}},[n("el-option",{attrs:{label:"规则1",value:"111"}}),n("el-option",{attrs:{label:"规则2",value:"222"}}),n("el-option",{attrs:{label:"规则3",value:"333"}})],1)],1),n("el-form-item",{directives:[{name:"show",rawName:"v-show",value:t.isBranchOrDelay||t.isBussiness,expression:"isBranchOrDelay || isBussiness"}],attrs:{label:"节点备注",prop:"remark"}},[n("el-input",{attrs:{type:"textarea"},model:{value:t.nodeForm.remark,callback:function(n){t.$set(t.nodeForm,"remark","string"===typeof n?n.trim():n)},expression:"nodeForm.remark"}})],1)],1),n("el-row",{directives:[{name:"show",rawName:"v-show",value:t.isBranchOrDelay||t.isBussiness,expression:"isBranchOrDelay || isBussiness"}]},[n("el-button",{on:{click:t.onNodeEditCancel}},[t._v("取消")]),n("el-button",{attrs:{type:"primary"},on:{click:t.onNodeEditSubmit}},[t._v("确认")])],1)],1)])])},Qt=[],tn=e("5728"),nn=e("b458"),en=e("54cf"),rn=e("e619"),on=e("0806");e("13d5");const an=[{type:40,code:"start",name:"开始节点"},{type:50,code:"end",name:"结束节点"},{type:10,code:"bussiness",name:"业务节点"},{type:20,code:"branch",name:"条件节点"},{type:30,code:"delay",name:"延迟节点"}],sn=an.reduce((t,n)=>({...t,[n.code]:n.type}),{}),cn=an.reduce((t,n)=>({...t,[n.type]:n.code}),{}),ln=an.reduce((t,n)=>({...t,[n.type]:n.name}),{}),dn=4,hn={groups:{top:{position:"top",attrs:{circle:{r:dn,magnet:!0,stroke:"#5F95FF",strokeWidth:1,fill:"#fff",style:{visibility:"hidden"}}}},right:{position:"right",attrs:{circle:{r:dn,magnet:!0,stroke:"#5F95FF",strokeWidth:1,fill:"#fff",style:{visibility:"hidden"}}}},bottom:{position:"bottom",attrs:{circle:{r:dn,magnet:!0,stroke:"#5F95FF",strokeWidth:1,fill:"#fff",style:{visibility:"hidden"}}}},left:{position:"left",attrs:{circle:{r:dn,magnet:!0,stroke:"#5F95FF",strokeWidth:1,fill:"#fff",style:{visibility:"hidden"}}}}},items:[{group:"top"},{group:"right"},{group:"bottom"},{group:"left"}]},un={width:200,height:60,label:"业务节点",inherit:"rect",attrs:{body:{strokeWidth:1,stroke:"#d8d8d8",fill:"#FFFFFF"},text:{fontSize:14,fill:"#0062ff"}},ports:{...hn}},pn={label:"条件节点",inherit:"rect",width:200,height:60,attrs:{body:{strokeWidth:1,stroke:"#d8d8d8",fill:"#FFFFFF"},text:{fontSize:14,fill:"#ffac00"}},ports:{...hn,items:[{group:"top"},{group:"bottom"}]}},vn={label:"延迟节点",inherit:"rect",width:200,height:60,attrs:{body:{strokeWidth:1,stroke:"#d8d8d8",fill:"#FFFFFF"},text:{fontSize:14,fill:"#905fe9"}},ports:{...hn,items:[{group:"top"},{group:"bottom"}]}},fn={width:120,height:48,label:"开始节点",inherit:"rect",attrs:{body:{strokeWidth:1,stroke:"#d8d8d8",fill:"#FFFFFF",rx:24,ry:24},text:{fontSize:14,fill:"#000000"}},ports:{...hn,items:[{group:"bottom"}]}},_n={width:120,height:48,label:"结束节点",inherit:"rect",attrs:{body:{strokeWidth:1,stroke:"#d8d8d8",fill:"#FFFFFF",rx:20,ry:26},text:{fontSize:14,fill:"#000000"}},ports:{...hn,items:[{group:"top"}]}},mn={nodeType:void 0,nodeId:void 0,nodeAlias:"",executeParentStoresFlag:0,executeThisStoresFlag:0,ruleId:void 0,remark:"",pos:""};function bn(t,n){for(let e=0,r=t.length;e<r;e+=1)t[e].style.visibility=n?"visible":"hidden"}function gn(t){return`${t}_${Math.random()}`}var xn={showPorts:bn,genNodeId:gn};function An(t){return{container:t.container,autoResize:!0,background:{color:"#F2F7FA"},grid:{visible:!0},scaling:{min:.5,max:2},panning:{enabled:!0},mousewheel:{enabled:!0,factor:1.05},connecting:{allowBlank:!1,allowEdge:!1,allowMulti:!1,allowLoop:!1,allowNode:!1,validateConnection(t){const{sourceCell:n,targetPort:e,sourcePort:r}=t,o=this.getOutgoingEdges(n);return!("branch"===n.shape&&o.length>2)&&(e&&e!==r)},router:"manhattan",connector:{name:"rounded",args:{radius:8}},anchor:"center",connectionPoint:"anchor",snap:{radius:20},createEdge(){return new tn["p"].Edge({attrs:{line:{stroke:"#A2B1C3",strokeWidth:2,targetMarker:{name:"block",width:8,height:8}}},zIndex:0})}}}}var wn=function(){var t=this;t._self._c;return t._m(0)},Mn=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"props"},[n("h4",[t._v("流程基础信息")]),n("div",{staticClass:"row"},[n("span",[t._v("功能模块:")]),n("span",[t._v("入库")])]),n("div",{staticClass:"row"},[n("span",[t._v("流程编码:")]),n("span",[t._v("InboundXXXX")])]),n("div",{staticClass:"row"},[n("span",[t._v("功能名称:")]),n("span",[t._v("入库流程")])]),n("div",{staticClass:"row"},[n("span",[t._v("业务类型:")]),n("span",[t._v("完整入库")])])])}],On={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},yn=On,Tn=(e("a0b1"),Object(d["a"])(yn,wn,Mn,!1,null,"2d6ecc52",null)),Sn=Tn.exports,En=e("2ef0");tn["k"].registerNode("bussiness",un,!0),tn["k"].registerNode("branch",pn,!0),tn["k"].registerNode("delay",vn,!0),tn["k"].registerNode("start",fn,!0),tn["k"].registerNode("end",_n,!0);let Dn=null;var Rn={name:"Flow",components:{FlowProps:Sn},data(){return{rules:{nodeId:[{required:!0,message:"请选择节点名称",trigger:"change"}],nodeAlias:[{required:!0,message:"请输入节点别名",trigger:"blur"}]},nodeRx:0,nodeRy:0,flowInfoVisible:!0,nodeInfoVisible:!1,nodeForm:{nodeType:void 0,nodeId:void 0,nodeAlias:"",executeParentStoresFlag:0,executeThisStoresFlag:0,ruleId:void 0,remark:""},currCellId:""}},computed:{nodeTypeList(){return an},nodeType2NameMap(){return ln},isStartOrEnd(){return 40==this.nodeForm.nodeType||50==this.nodeForm.nodeType},isBussiness(){return 10==this.nodeForm.nodeType},isBranchOrDelay(){return 20==this.nodeForm.nodeType||30==this.nodeForm.nodeType}},mounted(){this.initGraph()},methods:{initGraph(){Dn&&Dn.dispose();const t=this.$refs.canvas,n=An({container:t}),e=new tn["k"](n);e.use(new nn["a"]({enabled:!0})),e.use(new en["a"]({enabled:!0,multiple:!1,showNodeSelectionBox:!0,pointerEvents:"none"})),e.use(new rn["a"]),e.use(new on["a"]({enabled:!0})),e.bindKey(["meta+c","ctrl+c"],()=>{const t=e.getSelectedCells();if(t.length){const n=t[0],{shape:r}=n;"edge"!==r&&e.copy(t)}return!1}),e.bindKey(["meta+v","ctrl+v"],()=>{if(!e.isClipboardEmpty()){const t=e.paste({offset:32}),n=t[0],{data:r}=n,o=n.position();console.log("oldNode",o),e.removeCell(n);const i=xn.genNodeId(cn[r.nodeType]),a={id:i,x:o.x,y:o.y,shape:cn[r.nodeType],data:{...r,pos:i}};e.addNode(a),e.resetSelection(i)}return!1}),e.bindKey("backspace",()=>{const t=e.getSelectedCells();t.length&&e.removeCells(t)}),Dn=e,e.centerContent(),e.on("node:mouseenter",()=>{const t=this.$refs.canvas,n=t.querySelectorAll(".x6-port-body");xn.showPorts(n,!0)}),e.on("node:mouseleave",()=>{const t=this.$refs.canvas,n=t.querySelectorAll(".x6-port-body");xn.showPorts(n,!1)}),e.on("node:click",()=>{e.getEdges().forEach(t=>{t.attr("line/stroke","#A2B1C3")})}),e.on("edge:click",({edge:t})=>{e.getEdges().forEach(t=>{t.attr("line/stroke","#A2B1C3")}),t.attr("line/stroke","#0062ff"),this.graphBlankClick()}),e.on("blank:click",()=>{e.getEdges().forEach(t=>{t.attr("line/stroke","#A2B1C3")}),this.graphBlankClick()}),e.on("edge:connected",({isNew:t,edge:n})=>{const r=n.getSourceNode();if(console.log("edge:connected sourceNode",t,r),"branch"===r.shape){const t=e.getOutgoingEdges(r);if(console.log("branchNodeEdges",t),1===t.length)n.setData({isYes:1});else if(2===t.length){const n=t.filter(t=>!!t.data)[0],e=t.filter(t=>!t.data)[0];if(n){const{isYes:t}=n.data;e.setData({isYes:1===t?0:1})}}t.forEach(t=>{const{data:e}=t,{isYes:r}=e;n.setLabels({attrs:{label:{text:r?" 是 ":" 否 ",fill:r?"#00c172":"red"}},position:{distance:.5}})})}}),e.on("node:selected",({node:t})=>{this.graphNodeSelected(t)})},onNodeTypClick(t){const n=t.clientX,e=t.clientY,r=t.target.getBoundingClientRect(),o=Math.ceil(n-r.left),i=Math.ceil(e-r.top);this.nodeRx=o,this.nodeRy=i},onNodeDragStart(t){const n=t.target.dataset.type;t.dataTransfer.setData("NodeType",n)},onNodeDragOver(t){t.preventDefault(),t.dataTransfer.dropEffect="copy"},onNodeDrop(t){t.preventDefault(),t.stopPropagation();const n=t.dataTransfer.getData("NodeType"),e=Math.ceil(t.clientX-this.nodeRx),r=Math.ceil(t.clientY-this.nodeRy),o=Dn.clientToLocal(e,r),i=xn.genNodeId(n),a={id:i,x:o.x,y:o.y,data:{...Object(En["cloneDeep"])(mn),pos:i,nodeType:sn[n]}};Dn.addNode({...a,shape:n})},onNodeEditCancel(){},onNodeEditSubmit(){this.$refs["nodeForm"].validate(t=>{if(!t)return!1;if(console.log("submit!",this.nodeForm,this.currCellId),this.currCellId){let t=Dn.getCellById(this.currCellId);t.updateData(this.nodeForm),console.log("updateData",t)}})},graphBlankClick(){this.flowInfoVisible||(this.flowInfoVisible=!0,this.nodeInfoVisible=!1)},resetNodeForm(){this.nodeForm.nodeType=void 0,this.nodeForm.nodeId=void 0,this.nodeForm.nodeAlias="",this.nodeForm.executeParentStoresFlag=0,this.nodeForm.executeThisStoresFlag=0,this.nodeForm.ruleId=void 0,this.nodeForm.remark=""},graphNodeSelected(t){this.nodeInfoVisible||(this.nodeInfoVisible=!0,this.flowInfoVisible=!1),console.log("node selected",t),this.currCellId=t.id;const n=t.getData();console.log(n),Object.keys(this.nodeForm).forEach(t=>{this.nodeForm[t]=n[t]})},handleDone(){if(Dn){const t=Dn.toJSON(),n=[],e=Dn.getNodes();for(let r=0;r<e.length;r++){const t=e[r],o=Dn.getPredecessors(t,{distance:1}),i=Dn.getSuccessors(t,{distance:1});let[a,s,c,l]=[[],[]];if(o&&(a=o.map(t=>t.id)),i&&(s=i.map(t=>t.id)),"branch"===t.shape){const n=Dn.getOutgoingEdges(t);n.forEach(t=>{const{data:n,target:e}=t;n&&n.isYes?l=e.cell:c=e.cell})}const d={...t.data,fromNodePosList:a,toNodePosList:s,toYesPos:l,toNoPos:c};n.push(d)}console.log("serverNodes",n),console.log("layout json",JSON.stringify(t))}}}},Vn=Rn,Pn=(e("3b73"),e("6794"),Object(d["a"])(Vn,Zt,Qt,!1,null,"71919547",null)),In=Pn.exports,Nn=function(){var t=this,n=t._self._c;return n("div",{ref:"canvas",staticClass:"flow-view"})},Cn=[];e("ce21");function Ln(t){return{container:t.container,autoResize:!0,background:{color:"#F2F7FA"},grid:{visible:!0},interacting:{nodeMovable:!1},scaling:{min:.5,max:2},panning:{enabled:!0},mousewheel:{enabled:!0,factor:1.05},connecting:{router:"manhattan",connector:{name:"rounded",args:{radius:8}},anchor:"center",connectionPoint:"anchor"}}}const jn={shape:"bussiness_init",width:200,height:60,label:"业务节点",effect:["data"],html(t){const{status:n}=t.getData();console.log("xxxx",n);const e=document.createElement("div");return e.className="html-node bussiness "+n,e},tools:[{name:"button",args:{markup:[{tagName:"circle",selector:"button",attrs:{r:14,stroke:"#fe854f",strokeWidth:2,fill:"white",cursor:"pointer"}},{tagName:"text",textContent:"Btn",selector:"icon",attrs:{fill:"#fe854f",fontSize:10,textAnchor:"middle",pointerEvents:"none",y:"0.3em"}}],x:"100%",y:"100%",offset:{x:-20,y:-20},onClick({cell:t}){console.log("xxxxx",t)}}}]};let Bn;tn["p"].HTML.register(jn);var Fn={name:"xxx",components:{},data(){return{}},mounted(){this.initFlowGraph()},methods:{initFlowGraph(){Bn&&Bn.dispose();const t=this.$refs.canvas,n=Ln({container:t}),e=new tn["k"](n);e.addNode({shape:"bussiness_init",x:60,y:100,data:{status:"init"}}),Bn=e,e.centerContent()}}},kn=Fn,Un=(e("b99a"),e("5820"),Object(d["a"])(kn,Nn,Cn,!1,null,"834442d6",null)),Wn=Un.exports,Hn=function(){var t=this;t._self._c;return t._m(0)},Gn=[function(){var t=this,n=t._self._c;return n("div",{staticClass:"wrapper"},[n("canvas",{attrs:{id:"map"}}),n("div",{staticStyle:{position:"absolute",bottom:"10px",left:"10px",background:"rgba(0, 0, 0, 0.6)",color:"#fff",padding:"5px 10px","border-radius":"5px","font-family":"monospace","font-size":"12px"},attrs:{id:"cameraInfo"}})])}],Yn=e("72fe"),qn=e("5a89"),zn=e("4721");let Xn,Jn,$n,Kn,Zn,Qn,te=null;const ne=[];var ee={components:{},data(){return{rafId:null}},mounted(){this.init(),this.renderLoop()},beforeDestroy(){this.rafId&&cancelAnimationFrame(this.rafId),$n.dispose()},methods:{renderLoop(){this.rafId=window.requestAnimationFrame(this.renderLoop),Kn.update();const t=Jn.position,n=Kn.target;cameraInfo.innerHTML=`\n    <b>Camera Pos:</b><br/>\n    x: ${t.x.toFixed(2)},\n    y: ${t.y.toFixed(2)},\n    z: ${t.z.toFixed(2)}<br/>\n    <b>Look At:</b><br/>\n    x: ${n.x.toFixed(2)},\n    y: ${n.y.toFixed(2)},\n    z: ${n.z.toFixed(2)}\n  `,$n.render(Xn,Jn)},init(){let t=document.getElementById("map");console.log(t.offsetLeft,t.offsetWidth,t.offsetHeight),Xn=new Yn["dd"],Xn.background=new Yn["r"](15790320),Jn=new Yn["cc"](60,t.offsetWidth/t.offsetHeight,.1,1e3),Jn.position.set(30,30,40),$n=new qn["a"]({antialias:!0,canvas:t}),$n.setPixelRatio(window.devicePixelRatio),$n.setSize(t.offsetWidth,t.offsetHeight),Kn=new zn["a"](Jn,$n.domElement),Kn.enableDamping=!0,Xn.add(new Yn["i"](8947848));const n=new Yn["K"](16777215,.8);n.position.set(20,40,20),Xn.add(n);const e=new Yn["vb"](new Yn["ec"](60,40),new Yn["zb"]({color:14540253}));e.rotation.x=-Math.PI/2,e.position.y=-15,Xn.add(e);const r=new Yn["zb"]({color:3368652});for(let a=-20;a<=20;a+=10)for(let t=-10;t<=10;t+=10){const n=new Yn["vb"](new Yn["l"](4,10,8),r.clone());n.position.set(a,-10,t),n.userData={type:"shelf",id:`S-${a}-${t}`,capacity:10},Xn.add(n),ne.push(n);for(let e=0;e<3;e++){const n=new Yn["vb"](new Yn["l"](2,2,2),new Yn["zb"]({color:16750899}));n.position.set(a,2.5*e-5,t),n.userData={type:"cargo",id:`C-${a}-${t}-${e}`,weight:10+2*e+"kg"},Xn.add(n),ne.push(n)}}function o(){Jn.aspect=t.offsetWidth/t.offsetHeight,Jn.updateProjectionMatrix(),$n.setSize(t.offsetWidth,t.offsetHeight)}function i(n){Qn.x=(n.clientX-t.offsetLeft)/t.offsetWidth*2-1,Qn.y=-n.clientY/t.offsetWidth*2+1,Zn.setFromCamera(Qn,Jn);const e=Zn.intersectObjects(ne);if(e.length>0){var r;const t=e[0].object;var o;if(te)null===(o=te.material.emissive)||void 0===o||o.setHex(0);te=t,null===(r=te.material.emissive)||void 0===r||r.setHex(4473856),console.log(t)}}Zn=new Yn["Tc"],Qn=new Yn["Bd"],window.addEventListener("resize",o,!1),window.addEventListener("click",i,!1)}}},re=ee,oe=(e("e277"),Object(d["a"])(re,Hn,Gn,!1,null,"cce5737a",null)),ie=oe.exports,ae=function(){var t=this,n=t._self._c;return n("div",[n("div",{staticClass:"i-nav"},t._l(t.interviewsList,(function(e){return n("router-link",{key:e.path,attrs:{to:e.path}},[t._v(t._s(e.name))])})),1),n("router-view")],1)},se=[],ce={name:"xxx",components:{},data(){return{interviewsList:[]}},mounted(){const t=this.$router.options.routes.filter(t=>"Study"===t.name)[0].children;this.interviewsList=t},methods:{}},le=ce,de=(e("b1b7"),Object(d["a"])(le,ae,se,!1,null,"4525cc4a",null)),he=de.exports,ue=function(){var t=this;t._self._c;return t._m(0)},pe=[function(){var t=this,n=t._self._c;return n("div",[n("section",[t._v(" html超文本标记语言，由一系列的元素（elements）组成；元素可以告诉浏览器如何展示内容； "),n("pre",[t._v("      文档类型声明（DOCTYPE）!DOCTYPE html ；\n      html 元素：文档的根元素，所有的内容都包含在这个元素内。\n      head 元素：包含文档的元数据，如字符集声明、页面标题和链接到 CSS 文件。\n      body 元素：包含可见的页面内容\n      标题和段落：h1 到 h6 定义标题，p 定义段落\n      链接：a 元素用于创建链接\n      图片：img 元素用于嵌入图片\n      列表：ul 表示无序列表，ol 表示有序列表，li 表示列表项。\n      表格：table 用于创建表格，tr 用于行，th 和 td 分别用于表头和单元格\n      "),n("a",{attrs:{href:"https://evelance.notion.site/Table-8dde6cdd0844459b96f2fc9ec7ba8793"}},[t._v("表格：table注意事项")]),t._v("\n      表单：form 用于创建表单，input 用于收集用户输入\n      ")])]),n("section",[t._v(" https://evelance.notion.site/56e3e25360914897ad0717fbd06a17d1 "),n("pre",[t._v("      ## 语义化的理解\n- 用正确的标签做正确的事情，结构清晰，可读性高，方便维护\nheader / main / aside / section / article / footer / canvas / video / audio\n- 利于 SEO（搜索引擎优化）\n\n## SEO\n一种搜索引擎的搜索规则，可利用它来提高网站在搜索结果中的排名\n前端 SEO 实践与注意点：\n- 实践：\n    - head 标签中：\n        - `title`：言简意赅，需要体现出页面的主要内容\n        - `description`：对页面内容的高度概括\n        - `keywords`：列举出网站重要关键词\n- 注意点：\n    - 重要内容不要 JS 输出，爬虫不会执行 JS 获取内容\n    - 非装饰性图片必须加 alt\n    - 提高网站访问速度\n    ")])]),n("section",[n("p",[t._v("Web Worker")]),t._v(" 在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。 web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面你的性能。并且通过 postMessage 将结果回传到主线程。 这样在进行复杂计算操作的时候，就不会阻塞主线程了。 如何创建 web worker: 1. 检测浏览器对于 web worker 的支持性 2. 创建 web worker 文件(js，回传函数等) 3. 创建 web worker 对象 https://github.com/mdn/dom-examples/tree/main/web-workers ")]),n("section",[t._v(" Canvas 和 SVG 有什么区别 绘制方式：js xml 分辨率影响: 逐像素，矢量图(独立于像素) 元素事件：不支持， 支持 场景：频繁重绘，数据量大；svg是dom操作，不适用频繁重绘 ")])])}],ve={name:"HHHH",components:{},data(){return{}},mounted(){},methods:{}},fe=ve,_e=Object(d["a"])(fe,ue,pe,!1,null,null,null),me=_e.exports,be=function(){var t=this;t._self._c;return t._m(0)},ge=[function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("1.引入 CSS 的 4 种方式")]),n("div",[t._v('导入 @import "mystyle.css";')]),n("div",[t._v('外链 link rel="stylesheet" type="text/css" href="my.css" ;')]),n("div",[t._v('行内式 div style="border:1px red solid;";')]),n("div",[t._v('style标签 style type="text/css" div { margin: 0; } style')])]),n("section",[n("h3",[t._v("盒模型")]),n("p",[t._v(" Dom中对一个元素在占据布局空间的描述，从内到外：content，padding，border，margin ")]),n("pre",[t._v("box-sizing影响盒模型的计算方式：同样是设置的css宽高像素100px；\n标准的 content-box： 内容宽度（100px） 不包括 内边距 + 边框宽度\nIE的border-box：  内容宽度 100px（包括了内边距+边框）\n")])]),n("section",[n("h3",[t._v("display属性")]),n("pre",[t._v("    block，inline 和 inline-block：\n    - `inline`\n    - 不会独占一行；相邻的排同一行；一行排不下会换行\n    - 不可设置宽高\n    - `padding`、`margin` **水平**方向上设置**有效**，**垂直**方向上**无效**\n\n    - `inline-block`\n    - 和其他元素同一行（行内元素特点）\n    - 可以设置宽高（块级元素特点）\n    - `padding`、`margin` **设置有效**\n\n    - `block`\n    - 独占一行\n    - 可以设置宽高\n    - `padding`、`margin` 设置有效\n\n比较 opacity: 0、visibility: hidden、display: none 的区别\n结构：\ndisplay:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，\nvisibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击\nopacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击\n\n继承：\ndisplay: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。\nvisibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。\n\n性能：\ndisplay：none 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大\nvisibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容\nopacity: 0 ： 修改元素会造成重绘，性能消耗较少\n      ")])]),n("section",[n("h3",[t._v("css选择器")]),n("a",{attrs:{href:"https://evelance.notion.site/CSS-757cd0fa3932490bb5abd723b7726345",target:"_blank"}},[t._v("css选择器")]),n("p",[t._v("选择器匹配规则: 从右往左， why？")]),n("pre",[t._v('        **1. 从右向左匹配的步骤**\n假设有一个选择器 `div ul > li a.active`：\n\n1. **从最右边的选择器开始**，即 `.active`，查找所有带有 `class="active"` 的 `a` 元素。\n2. 然后**往左移动**到 `li a.active`，过滤掉不在 `li` 内部的 `a` 元素。\n3. 接着移动到 `ul > li a.active`，进一步过滤掉不在直接子元素 `li` 内部的 `a` 元素。\n4. 最后到 `div ul > li a.active`，过滤掉不在 `div` 内部的 `ul` 内部的 `li` 内部的 `a` 元素。\n\n**2. 优化原因**\n\n这种从右向左的匹配方式主要是为了优化选择器的性能：\n- **减少不必要的查找**：从右向左匹配能够立即定位具体的元素，从而避免从文档根部开始的全局搜索。\n假设选择器是从左到右匹配，会从文档根部开始搜索所有 `div`，然后查找每个 `div` 下的 `ul`，再查找 `ul` 下的 `li`，最后检查 `li` 下是否有符合条件的 `a`。\n  这可能导致大量无效的查找。\n- **降低复杂度**：CSS 引擎可以快速排除不符合条件的元素。\n例如，选择器 `.active` 可以迅速筛选出特定的 `a` 元素，大大减少需要进一步检查的元素数量。\n      ')])]),n("section",[n("h3",[t._v("CSS 优先级算法")]),n("pre",[t._v("    - 优先级：\n    - 同权重下: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）\n    - !important > id > class > tag\n    - !important 比 内联优先级高\n\n    - **同权重下**：\n    - 优先级就近原则，样式定义最近者为准\n    - 载入样式以最后载入的定位为准\n      ")])]),n("section",[n("h3",[t._v("BFC")]),n("pre",[t._v("        BFC块级格式化上下文 是 CSS 中页面的一块独立渲染区域，内部元素的渲染遵循特定规则，与区域外部的元素相互隔离。\n触发条件:\n- `html` 根元素（整个文档的根元素自动成为 BFC）。\n- 元素的 `float` 属性值不是 `none`（即设置了浮动 `left` 、 `right`）。\n- 元素的 `position` 属性值是 `absolute`（绝对定位）或 `fixed`（固定定位）。\n- 元素的 `display` 属性值是 `inline-block`、`table-cell`、`flex`、`table-caption`、`inline-flex` 等。\n- 元素的 `overflow` 属性值不是 `visible`（如 `auto`、`hidden`、`scroll`）。\n特点：\n1. 同一个 BFC 内部的盒子会按照正常文档流一个接一个地放置。\n2. BFC 内部的元素垂直方向的距离由`margin`决定，属于同一个 BFC 的两个相邻元素的`margin`会发生重叠。\n3. BFC 的区域不会与浮动盒子重叠。\n4. BFC 是一个隔离的独立容器，容器里面的子元素不会影响外面的元素，反之亦然。\n作用：\n清除浮动影响 和 margin重叠\n      ")])]),n("section",[n("h3",[t._v("CSS单位: px, %, em, rem, vw/vh")]),n("pre",[t._v("- 使用 `px` ，结合 Media Query 进行阶梯式的适配\n- 使用 `%` ，按百分比自适应布局\n- `em`，相对单位，相对于父元素的字体大小\n- `rem`，也是相对单位，相对于根元素 `html`。使用`rem`，结合 `html` 元素的 `font-size` 来根据屏幕宽度适配\n- 使用 `vw`、`vh`，直接根据视口宽高适配。\n1. 在视觉稿要求固定尺寸的元素上使用 `px`。比如 `1px` 线，`4px` 的圆角边框。\n2. 在字号、（大多数）间距上使用 `rem`。\n3. 慎用 `em`。\n")]),n("p",[t._v("像素和分辨率的关系")]),n("pre",[t._v("css中用 px 作为单位来表示尺寸的大小。px 是一个抽象逻辑单位，在不同设备、不同分辨率下，px 所代表的物理像素是不一样的。\n\n设备像素: 即物理像素，是屏幕硬件层面的最小显示单元（pt），屏幕在生产时就已经确定了其设备像素的数量和排列方式;\n1080P 显示器，其物理分辨率为 1920 x 1080，即 1920 个水平物理像素和 1080 个垂直物理像素，总共有 2,073,600 个设备像素；\n2K 显示器，其物理分辨率为 2560 x 1440，即 2560 个水平物理像素和 1440 个垂直物理像素，总共有 3,686,400 个设备像素；\n\n一个物理像素点 由 pt 来表示，pt 是物理绝对尺寸单位，大小始终固定，指的是 72分之一英寸（inch）\n\n设备独立像素：（Device Independent Pixel）：又称为逻辑像素，指的是可以通过程序控制的虚拟像素，css 中的像素单位 px 就是一个逻辑像素单位，px 是一个相对单位，它的大小并不固定\n通常，我们可以在电脑上通过设置，改变屏幕的分辨率，这里可以被改变的分辨率，就是逻辑像素分辨率。注意它与物理像素分辨率的区别；\nwindow.screen.width / window.screen.height 查看当前设备的逻辑（虚拟）分辨率\n\n设备分辨率缩放比（dpr）：物理像素和逻辑像素的比值；\n电脑显示器为物理分辨率为 5K，5120 x 2880，我的系统设置的标准逻辑分辨率为 2560 x 1440；\nwindow.devicePixelRatio = 5120 / 2560 = 2，一个 px 在我的电脑上，就对应了 2 个物理像素\n\n浏览器缩放比：在浏览器的设置中，修改网页缩放比，和修改屏幕分辨率不同，修改网页缩放比是在设备（物理）分辨率缩放比的基础之上进行修改；\n我当前的设备分辨率缩放比为 2，修改浏览器中网页缩放比为 150%；对于web页面而言，新的设备分辨率缩放比为 2 * 1.5 = 3\nwindow.devicePixelRatio = 2 * 1.5\n\n屏幕英寸大小：屏幕的物理尺寸大小\n\nPPI （pixel per inch），每英寸像素，像素密度\n\n")])]),n("section",[n("h3",[t._v("css3新特性")]),n("pre",[t._v("        transition: CSS属性，花费时间，运动曲线(默认ease)，延迟时间(默认0)\n        animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），\n是否反向播放动画（默认normal），是否暂停动画（默认running）\n        transform：\ntransform: rotate(30deg);\ntransform: translate(30px, 30px);\ntransform: scale(.8);\ntransform: skew(10deg, 10deg);\ntransform-origin: left top; 左上（默认中心）【改变元素变形的原点】\n\nFlex 布局：\nflex 弹性盒布局模型的目的：提供一种更加高效的方式来对容器中的元素进行布局、对齐和分配空间\n主轴方向：水平排列（默认） | 水平反向排列 | 垂直排列 | 垂直反向排列\nflex-direction: row | row-reverse | column | column-reverse;\n\n换行：不换行（默认） | 换行 | 反向换行(第一行在最后面)\nflex-wrap: nowrap | wrap | wrap-reverse;\n\nflex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\nflex-flow: flex-direction || flex-wrap;\n\n主轴对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐\njustify-content: flex-start | flex-end | center | space-between | space-around;\n\n交叉轴对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 第一行文字的基线对齐\nalign-items: stretch | flex-start | flex-end | center | baseline;\n\n多根轴线对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐\nalign-content: stretch | flex-start | flex-end | center | space-between | space-around;\n\n- `flex` 默认设置是 `flex: 0 1 auto`\n- 意思是项目默认有剩余空间也不放大（0），但空间不足会缩小（1）\n\n      ")])]),n("section",[n("h3",[t._v("响应式设计")]),n("p",[t._v(" 一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 ")]),n("pre",[t._v("@media screen and (max-width: 990px) {\n    .container {\n        background: orange;\n    }\n}\n\n@media (max-width: 575px) {\n   .call-me {\n      .call-item:first-child {\n         border-right: 0 !important;\n         border-bottom: 1px solid #e6e6e6;\n      }\n   }\n}\n      ")])])])}],xe={name:"css",components:{},data(){return{}},mounted(){},methods:{}},Ae=xe,we=(e("bd86"),Object(d["a"])(Ae,be,ge,!1,null,"6313b6e3",null)),Me=we.exports,Oe=function(){var t=this;t._self._c;return t._m(0)},ye=[function(){var t=this,n=t._self._c;return n("div",[n("a",{attrs:{href:"https://github.com/Troland/how-javascript-works/tree/master"}},[t._v("how-javascript-works")]),n("h3",[t._v("=====语法======")]),n("pre",[t._v("1.数据类型\n# 基本类型\n- `undefined` 、 `null`\n- `string` 、 `boolean` 、 `number`\n- `symbol` （es6）、`bigint` （es10）\n# 复杂类型\n- `object`\n    - Array，Date，RegExp，Function\n    - 基本包装类型 Boolean，Number，String\n    - 单体内置对象 Global，Math\n- 值类型存储在栈(stack)中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n- 引用类型存储在堆(heap)中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；\n\n引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n- 栈(stack)：是栈内存的简称，栈是自动分配相对固定大小的内存空间，并由系统自动释放，栈数据结构先进后出的原则\n- 堆(heap)：是堆内存的简称，堆是动态分配内存，内存大小不固定，也不会自动释放，堆数据结构是一种无序的树状结构\n# 类型检测\ntypeof x =》 'undefined'\ninstanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\nauto instanceof Car =》 true/false\n\n使用 if(xx == null) 来判断变量 xx 是否为 undefined 和 null，更加简洁。\n（在目前最新的语法中 ?? 就是只针对 undefined 和 null 做判断处理，如 let a = xx ?? 123）\n\n# 进制装换\n十进制 → n进制\nfunction decimalToBaseN(decimalNumber, base) {\n    if (base 《= 2 || base > 36) {\n        throw new Error(\"Base must be between 2 and 36\");\n    }\n    return Number(decimalNumber).toString(base);\n}\nN进制 → 10进制\nfunction baseNToDecimal(baseNNumber, base) {\n    if (base 《 2 || base > 36) {\n        throw new Error(\"Base must be between 2 and 36\");\n    }\n    return parseInt(baseNNumber, base);\n}\n# 隐式转换\n[] + {};\n([]).toString() + ({}).toString() =》 \"\" + \"[object Object]\" =》 \"[object Object]\"\n{} + []; // 0\n\n# 函数\nfunction func(a, b, c) {\n  console.log(arguments.length); // 实参有 2 个：1 跟 2\n  console.log(func.length); // 形参有3个：a, b, c\n}\nfunc(1, 2);\n\n# 上下文\n## AO（activation object）活跃对象，函数上下文\nvar声明：变量提升到全局\n## GO（global object）全局上下文\n1. 寻找变量\n2. 寻找函数声明\n3. 执行\n\nif代码块中的 var 变量会提升，但函数声明并不会整体提升，而只会提升函数名到当前作用域的顶端\n\nfunction test() {\n\treturn a;\n  a = 1;\n  function a() {}\n  var a = 2;\n}\nconsole.log(test());\n// 答案: function a() {}\n\n# 作用域\n作用域就是`变量`与`函数`的可访问范围，由当前环境与上层环境的一系列变量对象组成\n1. 全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。\n2. 函数作用域：在固定的代码片段才能被访问\n3. 块级作用域：使用 `{}` 包裹的代码块，如 `if` 、 `for` 、 `while` 、 `try/catch`\n作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突\n作用域链\n访问一个变量，先在函数作用域内部取值，如果没有查到，就向上级作用域中查找，直到查到全局作用域为止，\n这样一个查找过程形成的链条叫做作用域链\n\n[[scope]]：\n- **函数创建时**，生成的一个 JS 内部的隐式属性\n- 函数存储【作用域链】的容器\n    - 作用域链：\n        - **AO - 函数的执行期上下文**\n        - **GO - 全局的执行期上下文**\n- 函数执行完成以后，AO 会被销毁，再执行会重新创建一个新的 AO\n- 全局执行的前一刻 GO -》 函数声明已经定义\n\n## **总结**\n1. 只要函数被定义，就生成作用域（scope）和相应的作用域链（scope chain），并把 GO 放进去\n2. 只要函数被执行的那一刻（准确的说应该是执行前的预编译阶段），就生成AO，然后把自身的AO放进作用域链，并自身排首位，把之前的作用域们（其他AO和GO）依次往下挪\n3. **函数执行完毕，销毁自身AO；此时自身作用域回归被定义时的状态**\n\n闭包就是能够读取其他函数内部变量的函数\n## **闭包的特性**\n- 函数内再**嵌套函数**\n- 内部函数可以**访问外层的参数和变量**\n- 参数和变量**不会被垃圾回收机制回收**\n\n当内部函数被返回到外部并保存时，一定会产生闭包。闭包会导致原来的作用域链不释放。过度的闭包可能会导致内存泄漏（因为常驻内存），或加载过慢。\nfunction fn1() {\n  var arr = new Array(9999999999999)\n  function fn2() {\n    console.log(arr)\n  }\n  return fn2\n}\nvar f = fn1()\nf() // 没有释放，arr就一直在内存中占着，导致内存泄漏\n// 记得释放\nf = null\n\n## **闭包的用途**\n- **保存**（缓存数据，延长作用域链）（onclick = 一个立即执行函数，这个立即执行函数返回一个函数，形成闭包）【形成一个不销毁的栈内存，把一些值保存起来，比如索引（**选项卡**）】\n    - 即：闭包中想要提供给外界调用访问的变量，相当于把一些值保存起来了\n- **保护**（避免全局污染）：**形成私有作用域**，保护里面私有变量不受外面干扰，不与别人冲突\n    - 希望函数内部的值不能被外部直接修改，但是可以通过return出去的方法让外部访问和间接修改\n        - **jquery**（利用闭包保护机制，自执行函数私有作用域,里边有个类叫jquery，通过window.$=window.jquery把它暴露给全局)\n    - 即：闭包中不希望外界访问的私有变量和参数，相当于保护私有变\n\n\n# 构造函数\n- 每次 new 出来的都是崭新出厂的全新对象，是互不相同的\n- new 之后 this 才存在，this 指向实例化的对象；否则指向GO =》window\n\nvar obj = new Object()；new 做了什么\n- **创建一个新对象**：\n    - 创建一个新的空对象，并将其作为函数的上下文（`this`）对象。\n- **设置原型链**：\n    - 将新对象的原型（`__proto__`）设置为构造函数的 `prototype` 属性。这样，新对象就可以访问构造函数原型上的属性和方法。\n- **执行构造函数**：\n    - 使用新对象作为 `this` 执行构造函数代码。构造函数中的代码可以对新对象进行初始化操作，例如添加属性和方法。\n- **返回新对象**：\n    - 如果构造函数显式地返回一个对象，那么 `new` 表达式会返回这个对象。\n    - 如果构造函数没有显式地返回对象，则 `new` 表达式会返回步骤 1 中创建的新对象。\n\nfunction selfNew(Obj, ...args) {\n  // 创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__（原型）\n  const newobj = Object.create(Obj.prototype)\n  // 使用新对象作为 this 执行构造函数\n  const result = Obj.apply(newobj, args);\n  // 如果构造函数显式返回了一个对象，则返回该对象，否则返回新创建的对象\n  return (result && typeof result === 'object') ? result : newobj;\n}\n\n## call/apply 更改 this 指向\nfunction test() {\n\tconsole.log(1);\n}\ntest(); //  test.call() 调用函数时，系统隐式的加了 .call\n\n原型 prototype\nprototype 是函数的属性，其值是个对象\n## **prototype 是构造函数中的，构造出的每个实例对象的公共祖先**\n## **所有被该构造函数构造出来的对象，都可以继承原型上的属性和方法**\nconstructor 指向构造函数本身\nHandphone.prototype.constructor =》Handphone\nconstructor 可以被修改； Handphone.prototype.constructor = XXX\n__proto__ 属性是实例化以后的结果， handphone1.__proto__  =》 Handphone.prototype\n\n沿着原型__proto__往上不断找属性的这条链条叫做原型链\n- 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果这个对象本身没有这个属性时，它就会去他的`__proto__隐式原型`上去找（即它的构造函数的 prototype）。\n- 如果还找不到，就去原型的原型（`即构造函数的prototype的__proto__`）上去找，....一直找到最顶层（`Object.prototype`）为止。\n- 如果还没有找到，则返回 undefined。\n\n对象构造函数继承\n// 定义基类构造函数\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n// 在 Person 的原型上定义方法\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n};\n\n// 定义子类构造函数\nfunction Student(name, age, major) {\n  Person.call(this, name, age); // 调用父类构造函数\n  this.major = major;\n}\n// 设置原型链\nStudent.prototype = Object.create(Person.prototype);\n\n// 修正 constructor 引用\nStudent.prototype.constructor = Student;\n\n// 在 Student 的原型上定义方法\nStudent.prototype.study = function() {\n  console.log(`${this.name} is studying ${this.major}.`);\n};\n\n链式操作 - return this\n\n# 对象属性遍历\nhasOwnProperty 返回自身非原型的属性\nfor...in 会把原型上的属性也遍历\nfor(var key in car) {\n  if(car.hasOwnProperty(key)) {\n\t\tconsole.log(key + ': ' + car[key])\n  }\n}\n判断属性是否在对象内 console.log('color' in car);in 不会排除对象原型上属性\n\n# 函数内部 this 指向\n- 普通函数 this 指向 window\n- 构造函数通过 new 调用 this 指向实例化对象\n\n闭包、箭头函数、setTimeout 中 this\nvar x = {\n  name: 'bw2',\n  getName1: function() {\n    console.log(this)\n  },\n  getName2: function() {\n    setTimeout(() =》 {\n      console.log(this)\n    },0)\n  },\n  getName31: () =》 {\n    console.log(this)\n  },\n  getName32: function() {\n    return function() {\n      console.log(this)\n    }\n  }\n}\n\n# 错误类型\nSyntaxError 语法错误\nReferenceError 引用错误\nRangeError 范围错误\nTypeError 类型错误\nURIError URI 错误\nEvalError eval 函数执行错误\nError 构造函数\nvar err = new Error('代码错误');\n\ntry 中的错误，不影响外部代码和 finally 中代码的执行\ntry {\n\tconsole.log('正常执行1');\n  console.log(a);\n  console.log('正常执行2');\n} catch(e) {\n\tconsole.log('e->', e);\n  console.log('e.name->', e.name);\n  console.log('e.message->', e.message);\n} finally {\n\tconsole.log('正常执行3');\n}\nconsole.log('正常执行4');\n\nthrow 手动抛错 throw '出错啦'\n\n# 垃圾回收\n- 找出**不再使用的变量**\n- **释放**其占用**内存**\n- **固定**的时间间隔**运行**\n\n## **标记清除 mark and sweep**\n- 标记进入环境\n- 离开环境时，排除全局变量和形成闭包的变量，然后清除\n\n## **引用计数 reference counting**\n- 循环引用时，无法清除变量可能引发内存溢出\n\n解除闭包内存\nfunction test1() {\n\tvar a = 1;\n  return function() {\n  \ta++;\n    console.log(a);\n  }\n}\nvar test = test1();\ntest();\ntest();\ntest();\ntest = null;\n")]),n("h3",[t._v("=====DOM======")]),n("pre",[t._v("文档对象模型（Document Object Model）\n用来**表示或操作** HTML 和 XML; 属于 **宿主对象**\nDOM 结构树\n判断dom元素类型\nObject.prototype.toString.call(document) // '[object HTMLDocument]'\nObject.prototype.toString.call(document.createElement('div')) // '[object HTMLDivElement]'\n获取元素 document\n获取父节点: Node.parentNode\n获取子节点: Node.childNodes, 不止包含元素节点;获取的是子代子节点而不是全部的后代子节点\n节点的增删改\ncreateElement\ncreateTextNode\nappendChild\ninsertBefore\nremoveChild\n\nDOM 对象 = 元素节点\n\n节点：\n元素节点、文本节点、属性节点、注释节点、document、DocumentFragment\n\nDOM对象\nvar div = document.getElementsByTagName('div')[0];\n\n-》 元素 -》 元素节点\nnodeName nodeValue nodeType attributes hasChildNodes\n\n元素 \t\t-》 \t\t构造函数实例化\t\t\t -》 \t\tdiv节点\ndiv\t\t\t\tnew HTMLDivElement()\t\t\tremoveChild(div)\n\t\t\t\t\t\t-》 div DOM对象\t\t\t\t\t\t删除了节点，但DOM对象还存在内存\n            \t\t存储在内存中\n\n p.remove(); 元素销毁，删除自身和自身所有子节点\n\n## **data-***\n- 设置自定义属性\n- HTML5内容\n- IE9以下没有\n### **dataset**\n- 管理自定义属性 console.log(p.dataset);\n\n# 元素视图的各个尺寸、滚动距离与偏移量\n- `offsetParent` —— 返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 `table`, `td`, `th`, `body` 元素。\n- `offsetLeft/offsetTop` —— 是相对于 `offsetParent` 的左上角边缘的坐标。\n- **`offsetWidth/offsetHeight` —— 元素的“外部” width/height，边框（border）尺寸计算在内。**\n\n- `clientLeft/clientTop` —— 从元素左上角外角到左上角内角的距离。\n对于从左到右显示内容的操作系统来说，它们始终是左侧/顶部 border 的宽度。\n而对于从右到左显示内容的操作系统来说，垂直滚动条在左边，所以 `clientLeft` 也包括滚动条的宽度。\n- **`clientWidth/clientHeight` —— 内容的 width/height，包括 padding，但不包括滚动条（scrollbar）。**\n\n- **`scrollWidth/scrollHeight` —— 内容的 width/height，就像 `clientWidth/clientHeight` 一样，但还包括元素的滚动出的不可见的部分。**\n- `scrollLeft/scrollTop` —— 从元素的左上角开始，滚动出元素的上半部分的 width/height。\n\n浏览器可视区域的尺寸（窗口的宽高）\n- `window.innerWidth`\n- `window.innerHeight`\n\n# 事件\n绑定事件：绑定事件的处理函数\n事件 + 事件的反馈 = 前端交互\n事件句柄：div.onclick = function() {}\n事件源：事件作用在谁身上，谁就是事件源\n\n事件流有三个阶段\n- 事件捕获阶段：顶层window到目标元素\n- 处于目标阶段 - 代码按先后顺序执行（新版chrome先捕获后冒泡）\n- 事件冒泡阶段：目标元素到顶层window\n\nJS 事件委托（事件代理）是一种利用事件冒泡机制来优化事件处理的技术。\n在 JS 的事件流中，事件会经历捕获阶段、目标阶段和冒泡阶段。\n当一个元素上的事件被触发时，该事件会从最具体的目标元素（即被点击的元素）开始向上冒泡，依次传递到它的父元素、祖父元素等，直到到达文档的根节点。\n事件委托就是利用这个冒泡机制，将事件处理程序绑定到目标元素的父元素或更外层的祖先元素上，当子元素上的事件触发时，会冒泡到外层的祖先元素，从而在外层元素的事件处理程序中进行处理\n- 减少内存占用和提高性能\n- 动态生成的子元素事件绑定\n\n事件对象\nevent.target 和 event.currentTarget 的区别\n- target\t             当前触发事件的元素\n- **currentTarget**\t   绑定事件处理函数的元素\n\n# **onmouseenter、onmouseleave**\n只绑定在当前元素本身，不存在冒泡行为\nmouseover，mouseout，mousemove\n当鼠标移入某元素时触发，移入和移出其子元素时也会触发。\n\n自定义事件 CustomEvent\n\nWeb Components 组件化\nshadowDOM\n通过Shadow DOM，可以创建具有特定结构和样式的元素，然后在页面上像使用普通元素一样使用这些自定义元素\n    ")]),n("h3",[t._v("=====ES6+======")]),n("pre",[t._v("# let，const\n不能在同一作用域中重复声明\n没有声明提升，声明之前不可用，会产生一个暂时性死区\n只在当前作用域下生效\nlet 本质上是就是为 js 增加了一个块级作用域\nconst 值不可被修改，不可重复声明，有块级作用域，const 存储引用类型值不保证不可被更改\n\n# 函数默认值会在()内形成一个单独的作用域\nfunction foo(x = 3) {\n  let x = 2;\n  console.log(x);\n}\nfoo();\n// Identifier 'x' has already been declared\n// 函数默认值可以等效为 let x = 3 ，由于此刻就声明了x，\n// 所以函数内部再次声明，报错\n\n# 解耦赋值：对象，数组\n\n# 箭头函数\n- **没有自身 this**，this 由外层作用域决定\n- **不能作为构造函数**使用，底层原理与普通函数不同\n- **无法**通过 apply、call、bind 来**显式改变箭头函数 this 指向**\n- **没有 arguments 对象**，用 rest 运算符替代\n- yield 命令不能生效，在 generator 函数中\n\n# 对象属性描述符\ndefineProperty\nvar obj = {};\nObject.defineProperty(obj, 'a', {\n\tvalue: 2,\n  configurable: true,\n  writable: true,\n  enumerable: true\n});\ngetter/setter\nobj.a; //属性获取 [[Get]] 默认操作\nobj.a = 3; // 赋值操作[[Put]]\nget, set 应该成对出现\nvar obj = {\n\tget a() {\n  \treturn this._a; // 返回私有变量_a\n  },\n  set a(val) {\n  \tthis._a = val * 2;\n  }\n}\n\n# Object.assign\n- 浅拷贝\nvar clone = Object.create(\n  Object.getPrototypeOf(obj), \n  Object.getOwnPropertyDescriptors(obj)\n)\nassign 拷贝是无法拿到 set 方法的\n同名属性替换\nvar tar = {a: {b: 1, c: 2}}\nvar source = {a: {b: 'hhhh'}}\nconsole.log(Object.assign(tar, source)) // {a: {b: 'hhhh'}}\n\n# **super**\n- 指向的是对象的原型对象\n- 对象的简写的方法上才能使用\n\n# Symbol\n应用场景1：使用 Symbol 来作为对象属性名\nconst gender = Symbol('gender')\nconst obj = {\n  name: 'Sunshine_Lin',\n  [gender]: '男'\n}\nSymbol作为属性的属性不会被枚举出来，这也是 JSON.stringfy(obj) 时，Symbol 属性会被排除在外的原因\n使用 Symbol 来替代常量\n使用 Symbol 定义类的私有属性\nclass Login {\n  constructor(username, password) {\n    const PASSWORD = Symbol()\n    this.username = username\n    this[PASSWORD] = password\n  }\n  checkPassword(pwd) { return this[PASSWORD] === pwd }\n}\nconst login = new Login('123456', 'hahah')\nconsole.log(login.PASSWORD) // 报错\n\n# iterator 迭代器\n对数据结构的读取的一种方式，有序的，连续的，基于拉取的一种消耗数据的组织方式\n- [] 数据\n- arguments、nodeList、Map、Set、WeakMap、WeakSet 类数组\n- TypeArray 二进制数据的缓存区，有点像数组\n\nfunction myIterator(arr) {\n  let index = 0;\n  return {\n    next() {\n      return index 《 arr.length \n          ? { value: arr[index++], done: false }\n          : { value: undefined, done: true }\n    }\n  }\n}\nfor...of 遍历含有iterator的对象\nfor await of 批量异步队列 同步执行\n\nfunction fn (time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`${time}毫秒后我成功啦！！！`)\n    }, time)\n  })\n}\nasync function asyncFn () {\n  const taskArr = [fn(3000), fn(1000), fn(1000), fn(2000), fn(500)]\n  for await (let x of taskArr) {\n    console.log(x)\n  }\n}\n# Array.of()\n- 代替 new Array()\nconsole.log(Array.of());\nconsole.log(Array.of(1, 2));\nArray.from(arrayLike 类数组)\n\n# ES Module\n- `export { add, minus }` 导出一个模块\n- `import { add, minus } from 'xxx'`\n\n- `export default {}` 导出一个对象\n- `import obj from 'xxx'`\n\n# 运算符\n?. 取一个可能不存在的值\nobj?.dog?.name // undefined\n\n?? undefined 和 null 才算假值\n0 || 'Lance' // 假值取右边 Lance\n\n或等于(||=)   a ||= b 等同于 a || (a = b);\n且等于(&&=)   a &&= b 等同于 a && (a = b);\n\nPromise.any： 当有成功的时候，返回最快那个成功\n- 接收一个 Promise 数组，数组中如有非 Promise 项，则此项当做成功\n- **如果有一个 Promise 成功**，则返回这个成功结果\n- 如果所有 Promise 都失败，则报错\nPromise.any([fn(2000, true), fn(3000), fn(1000, true)]).then(res => {\n  console.log(res) // 1秒后 输出  1000毫秒后我成功啦\n}, err => {\n  console.log(err)\n})\n\n# Set\n- 成员唯一（基本类型去重，复杂类型不去重）\n- 类数组结构\n# Map\n键名可以为任何值（包括函数、对象或任何原始值）\n会把复杂类型 toString 后设置为键名\nvar m = new Map([['name', 'zhangsan'], ['age', 10]]);\n\n- Set 是**有序列表**，类似于数组，但是没有重复值\n- Map 是存储许多键值对的**有序列表**，**key 和 value 支持所有数据类型**\n- 都是有序列表\n- set 值不重复；map 键不重复\nMap 与 Object 区别\n- Object 的键只能是 字符串 or Symbol；Map 可以是任意类型\n- Map 可以通过 size 获取元素个数，Object 得遍历\n- Map 是有序的；Object 是无序的\n- **Map 可迭代**；Object 只能遍历，或通过 Object.entries/values/keys 迭代\n\nWeakMap、WeakSet\n- 没有迭代接口\n- **成员只能是对象**\n\n# Proxy\n- `Object.defineProperty(obj, prop, descriptor)` 是直接处理 obj，然后当操作 obj 时，会在 set、get 方法中进行拦截\n    - **对 obj 本身操作**\n    - 给 obj 上新增没有的属性\n\n- Proxy(target, handler) 是通过处理 obj 以后，是**返回了一个代理对象**，你是通过操作这个代理对象，来对数据做操作的\n    - 创建一个 obj 的代理，中间隔了一层交流\n    - 相比 defineProperty 少了个 prop 参数，因为是对已有的 obj 操作、处理\n\n- defineProperty 给对象增加属性用\n- proxy 代理对象，通过重写 handler 对象，间接达到修改 target 的目的\n\nlet target = {\n  a: 1,\n  b: 2\n}\nlet proxy = new Proxy(target, {\n  get(target, prop) {\n    console.log('This is property value ' + target[prop]);\n    return target[prop];\n  },\n  set(target, prop, value) {\n    console.log(1111)\n    target[prop] = value;\n  }\n});\n\nconsole.log(\"proxy.a\", proxy.a); // 走了代理 This is ...\nconsole.log(\"target.a\", target.a); // 直接访问，没走代理。没显示 This is ...\nproxy.b = 3;\nconsole.log(\"target.b\", target.b); // 3\nconsole.log(\"proxy.b\", proxy.b); // 3\nconsole.log(proxy); // Proxy {a: 1, b: 2}\n\n- Object.defineProperty 没法直接处理数组\n- Proxy 可以\n\nlet proxy = new Proxy(target, {\n  get(target, prop) {\n    return 'GET: ' + prop + ' = ' + target[prop];\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    console.log('SET: ' + prop + ' = ' + value);\n  },\n  has(target, prop) {\n    return Reflect.has(target, prop);\n  },\n  deleteProperty(target, prop) {\n  \tdelete target[prop];\n    console.log(1);\n  }\n});\n\nfunction deepClone(org, tar) {\n    let target = tar || {},\n        toStr = Object.prototype.toString,\n        arrType = '[object Array]';\n\n    for (var key in org) {\n      if (org.hasOwnProperty(key)) {\n        let value = org[key];\n        if (typeof value === 'object' && value !== null) {\n          if (toStr.call(value) === arrType) {\n            target[key] = [];\n          } else {\n            target[key] = {};\n          }\n          deepClone(value, target[key]);\n        } else {\n          target[key] = value;\n        }\n      }\n    }\n    return target;\n  }\n}\n\n# class\n### **static**\n- 可以修饰属性和方法\n- 不会被继承，只能通过类来调用\n- 只在 Class 类中生效\nPerson.say()\n\nclass A {}\nclass B extends A {\n  constructor() {\n    super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。\n  }\n}\n当做对象使用\nclass A {\n  c() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.c()); // 2\n  }\n}\nlet b = new B();\n上面代码中，子类 B 当中的 `super.c()`，就是将 `super` 当作一个对象使用。\n这时，`super` 在普通方法之中，指向 `A.prototype`，所以 `super.c()` 就相当于 `A.prototype.c()`。\n\n**通过 super 调用父类的方法时，super 会绑定子类的 this。**\nclass A {\n  constructor {\n    this.x = 1;\n  }\n  s() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.s();\n  }\n}\n\nlet b = new B();\nb.m(); // 2\n\n# 模块化\n为什么用到 IIFE\n立即执行函数执行完后作用域销毁，自身的 AO，GO 都销毁，\n只剩下 return 返回值和返回值持有的函数中的变量的引用（e.g. 闭包），这样做到了变量的私有化\n\n缺点\n- 相互依赖关系一旦复杂，不好捋顺\n- 模块一旦变多，又出现全局变量可能覆盖的问题\n    - 进一步解决：namespace 命名空间\n\n## **模块化发展**\n无模块化 \n→ CommonJS规范（nodejs） : exports = module.exports\n→ AMD规范 \n→ CMD规范 \n→ ES6模块化\n\nCommonJs和ES6区别\nCommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用\n\n运行时加载(全量): CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n编译时加载(按需): ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”\n\nimport\n- 静态导入\n    - 初始化加载\n        - `import xxx from './xxx';` ，`script` 依赖 `type=\"module\"`\n- 动态导入 import() 不是在调用方法，只是动态导入的一种规定的语法\n    - 按需加载\n        - `import('./xxx');` 不依赖 `type=\"module\"`\n            - `import('./xxx').then(module => console.log(module));`\n")]),n("h1",[t._v("专题系列")]),n("pre",[t._v("# WeakMap使用场景\nconst oBtn1 = document.querySelector('#btn1');\nconst oBtn2 = document.querySelector('#btn2');\n\nconst oBtnMap = new WeakMap();\noBtnMap.set(oBtn1, handleBtn1Click);\noBtnMap.set(oBtn2, handleBtn2Click);\n\noBtn1.addEventListener('click', oBtnMap.get(oBtn1), false);\noBtn2.addEventListener('click', oBtnMap.get(oBtn2), false);\n\noBtn1.remove();\noBtn2.remove();\n\n# this指向\n- this 是 JavaScript 的关键字\n- 是 当前环境 执行期上下文对象 的 一个属性\n- this 明确指向的时机：**执行期**\n- this 在不同环境、不同作用域下，表现不同\n\n    ")])])}],Te={name:"JS",components:{},data(){return{}},mounted(){},methods:{}},Se=Te,Ee=Object(d["a"])(Se,Oe,ye,!1,null,"21c2607d",null),De=Ee.exports,Re=function(){var t=this;t._self._c;return t._m(0)},Ve=[function(){var t=this,n=t._self._c;return n("section",[n("div",[n("h4",[t._v("浏览器事件循环")]),n("pre",[t._v("## 进程\n- CPU正在进行的一个任务的运行过程的调度单位\n- 浏览器是一个多进程的应用程序\n- 进程是计算机调度的基本单位\n- 进程包含线程，线程在进程中运行\n    - **没有进程就没有线程**\n    - **为什么分进程：进程之间耦合低，chrome一个tab就是一个单独进程，单个tab卡死不会影响其他tab页面的工作**\n\n- 任务管理器（mac活动监视器）查看chrome的进程情况\n\n- 每一个tab都会开启一个进程\n- 浏览器有一个主进程（用户界面：指的是整个浏览器的界面，地址栏、标签栏、页面内容...）\n- 每一个 tab 各自有独立的：\n    - 渲染进程（浏览器内核Renderer，渲染引擎）\n    - 网络进程（网络请求）\n    - GPU进程（动画与3D绘制 e.g. css3动画开启GPU加速就用的这个进程）\n    - 插件进程（vue devtool 等 chrome 插件）\n- 每个进程里包含多个线程运行\n\n### 比如渲染进程\n- 包含\n    1. GPU 渲染线程（负责渲染页面）\n      - 解析 HTML，CSS\n      - 构建 DOM、CSSOM / Render 树\n      - 初始布局与绘制\n      - 回流与重绘    \n    2. JS 引擎线程\n      - 一个主线程与多个辅助线程\n      - 一个浏览器只有一个 JS 引擎（浏览器只有**一个JS主线程**，也就是所谓的JS是单线程的）\n      - 解析JS脚本\n      - 运行JS代码\n- 运行互斥\n    - GPU渲染与JS引擎线程，**运行互斥** why? 因为不能一边渲染内容，一边JS在修改DOM\n    - JS执行的时候，渲染线程挂起\n    - JS引擎任务空闲，GPU渲染更新\n\n### 事件触发线程：事件循环（Event Loop）线程（事件环是个单独线程管理的）\n- 事件线程：用户交互事件、setTimeout、Ajax\n\n#### 宏任务、微任务\n- 宏任务\n    - 宿主提供的异步方法和任务\n        - script 的执行（JS整体代码，比如 `script...script` 这段脚本整体，也是个宏任务）\n        - setTimeout、setImmediate、setInterval\n        - UI渲染、UI交互（Ajax、mouseover, click 各种事件回调）、I/O\n\n- 微任务\n    - 语言标准（ECMA262）提供的API\n        - Promise、process.nextTick（NodeJS）、MutationObserver\n\n循环执行逻辑：\n1. 先在JS引擎线程执行栈中**执行同步代码**（遇到宏任务，会执行它们，并把宏任务们的回调放进宏任务队列）\n2. 然后**清空所有微任务**\n3. **执行GUI渲染逻辑**\n4. 取一个**宏任务回调**出来执行（先进先出）\n-【处理的都是宏任务的回调函数：ajax回调，setTimeout回调，执行时遇到 setTimeout ，其实是执行了setTimeout，但把它回调放进了宏任务队列】\n5. 再执行同步代码\n6. 清空微任务\n7. ... 循环\n\n事件监听\n- 如果 JS 主动触发 click 回调，则相当于把回调同步的依次执行； btn.click()\n- 如果用户点击按钮触发 click 回调，则先把所有回调依次放进宏任务队列，再每次取出一个cb出来执行\n\n任务优先级\n1. Promise（微任务）\n2. MutationObserver（微任务）\n3. setImmediate（宏任务）\n4. setTimeout（宏任务）\n\n## requestAnimationFrame、setInterval\n- requestAnimationFrame 请求动画帧\n    - 告诉浏览器，在**下次重绘之前调用**回调函数更新动画\n        - 第一次主动触发，回调函数中还得递归调用\n    - 回调函数接受到一个参数 timestamp 时间戳\n- setInterval 间隔 xx ms 执行回调\n\n## MutationObserver、nextTick\n- MutationObserver\n    - **监听DOM改变，然后执行回调（回调是个微任务）**\n        - **Vue.$nextTick 就是利用这一点，在页面更新后，执行一些事情**\n    - mutation：变化 的意思\n    - `const observer = new MutationObserver(回调)`\n    - `observer.observe()`\n    - 回调中可以拿到两个参数：\n        - mutationList\t变化列表\n            - mutation.target 被改变的目标节点\n            - mutation.addedNodes 目标节点下新增的节点\n        - observer\t观察者实例对象\n- process.nextTick\n    - 作为微任务，是优先于 promise.then 执行的\n\n## 为何说 JS 是单线程的？\nJavaScript解释器引擎的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作DOM。\n这决定了它只能是单线程，否则会带来很复杂的同步问题。\n比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成这门语言的核心特征，将来也不会改变。\n注意：所谓单线程，是指在**JS引擎中负责解释和执行JavaScript代码**的线程只有一个。\n\n### **简单性**\n- 单线程模型使得JavaScript的编写和调试变得相对简单。开发者不需要处理多线程编程中的复杂问题，如竞争条件、死锁和线程同步等。\n### 与DOM的交互\nJavaScript在浏览器中的主要任务之一是与DOM进行交互。如果允许多个线程同时操作DOM，可能会导致不可预测的行为和数据不一致的问题。单线程保证了DOM操作的原子性和一致性。\n### 单线程的实现机制\n虽然JavaScript是单线程的，但通过异步编程模型和事件循环机制，它能够处理并发任务。这种机制包括以下部分：\n\n1. **调用栈（Call Stack）**：\n    - 调用栈是一个数据结构，用于追踪当前执行的代码位置。当一个函数被调用时，它会被压入栈顶，当函数执行完毕时，它会从栈顶弹出。\n2. **消息队列（Message Queue）**：\n    - 消息队列是一个任务队列，存储着待处理的异步任务和回调函数。当调用栈为空时，事件循环会从消息队列中取出第一个任务并执行。\n3. **事件循环（Event Loop）**：\n    - 事件循环是一个无限循环，它不断地检查调用栈是否为空。如果为空，它会从消息队列中取出一个任务并将其压入调用栈执行。这个过程持续进行，从而实现异步任务的处理。\n4. **总结**\n    - **单线程：指JavaScript在任何时刻只有一个主线程在执行代码。**\n    - **事件循环**：通过事件循环机制，JavaScript能够处理异步任务，实现非阻塞的并发执行。\n    - **简单性和安全性**：单线程模型简化了开发，并避免了多线程编程中的复杂问题，特别是在DOM操作方面。\n")])]),n("div",[n("h4",[t._v("浏览器渲染进程")]),n("pre",[t._v("- GPU 渲染线程（渲染页面）\n    - 解析 HTML、CSS 构建 DOM、CSSOM（渲染树）\n    - 初始布局与绘制\n    - 回流与重绘\n- JS 引擎线程\n    - 一个主线程与多个辅助线程（Web Workers、Service Workers）\n    - 一个浏览器只有一个JS引擎（浏览器只有一个JS主线程，也就是所谓的JS是单线程的）\n    - 解析JS脚本，运行JS代码\n      ")])]),n("div",[n("pre",[t._v("css放在 head 中的好处：\n- **提高加载性能**：在页面内容渲染之前应用样式，减少页面重绘和重排。\n- **改善用户体验**：避免用户在页面加载时看到未样式化的内容，防止“闪烁”效果。   \n\n为何要将 JS 放在 HTML 底部\n1. S 放在底部可以保证让**浏览器优先渲染完现有的 HTML 内容**，让用户先看到内容，体验好。\n2. 另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。**JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。**\n3. **渲染过程中，如果遇到`script`就停止渲染**，执行 JS 代码。因为**浏览器渲染和 JS 执行共用一个线程**，**而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突**。待`script`内容执行完之后，浏览器继续渲染。\n    ")])]),n("pre",[t._v('JS 延迟加载的方法有哪些\n1. async：给script标签加async属性，则加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）\n2. defer：给script标签加defer属性，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成\n3. 动态创建script标签：等到DOMContentLoaded 事件触发时，生成一个script标签，渲染到页面上上\n4. setTimeout 定时器延迟代码执行\n\n- 懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数\n- 预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映\nimg.src = imgSrc;\nimg.onload = function() { // 图片加载完后再添加到页面中去\n    oDiv.appendChild(img);\n}\n\n浏览器多标签页之间的通信\n1. websocket\n    1. 全双工（full-duplex）通信自然可以实现多个标签页之间的通信。\n2. setInterval + cookie 存值\n    1. 在页面 A 设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。\n3. **使用 localStorage**\n    1. localStorage 是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信（ps：sessionStorage 是会话级的存储空间，每个标签页都是单独的）。 直接在 window 对象上添加监听即可：\nwindow.addEventListener("storage", (e) =》 console.log(e))\n    ')])])}],Pe={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Ie=Pe,Ne=Object(d["a"])(Ie,Re,Ve,!1,null,"c6c95894",null),Ce=Ne.exports,Le=function(){var t=this;t._self._c;return t._m(0)},je=[function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("浏览器请求网页的过程")]),n("p",[t._v(" 具体定位某个资源的位置的时候叫：URL（统一资源定位符）（Uniform Resource Locator） ")]),n("img",{attrs:{width:"600px",src:e("97e5"),alt:""}}),n("img",{attrs:{width:"600px",src:"https://evelance.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4af8c5f0-a397-4979-b87c-d983938af4e9%2FUntitled.png?table=block&id=befa0cb0-40e2-43ab-bac3-660dd542ad07&spaceId=c9e7ae34-64f6-4cc4-9c74-4ce3b1d1ee92&width=1540&userId=&cache=v2\n"}}),n("pre",[t._v("# DNS：Domain Name Server 域名服务器\n- 作用：转换 域名与对应ip 的服务器，保存了一张它们的对应的表\n客户端询问 DNS本地服务器 这个域名的 IP =》根服务器 =》 .com服务器 =》xxx.com域服务器\n\n# IP：PORT\n- IPv4：4组，十进制\n- IPv6：8组，十六进制\n- 形式：192.168.0.1（长度32位（4个字节），十进制表示） （IPv4）\n\n# TCP\n- TCP: Transmission Control Protocol 传输控制协议\n- 特点：面向连接（收发数据前，必须建立可靠的连接）\n- 建立连接基础：三次握手\n- 应用场景：数据必须准确无误的收发\n    - HTTP请求、FTP文件传输、邮件收发\n- 优点：速度慢、稳定、重传机制、拥塞控制机制、断开连接\n- 缺点：效率低、占用资源、容易被攻击（三次握手 → DOS、 DDOS攻击）\n\n- TCP/IP协议组：提供点对点的连接机制，制定了数据封装、定址、传输、路由、数据接收的标准。\n\n- 只要是传数据，不管收发，都得建立**可靠的连接**\n\n## TCP 和 UDP 的区别\n1. TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接。\n2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 尽最大努力交付，即不保证可靠交付。 并且因为 TCP 可靠，面向连接，不会丢失数据因此适合大数据量的交换。\n3. TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。\n4. TCP只能是 1 对 1 的，UDP 支持 1 对 1, 1 对多。\n5. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。\n6. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。\n\n## **HTTP 和 HTTPS 区别**\n\n1. HTTP 是不安全的（监听和中间人攻击等手段，获取网站账户信息和敏感信息）\n    1. HTTPS 可防止被攻击\n2. HTTP 协议的传输内容都是明文，直接在 TCP 连接上运行，客户端和服务器都无法验证对方身份\n3. HTTPS 协议的传输内容都被 SSL/TLS 加密，且运行在 SSL/TLS 上， SSL/TLS 运行在 TCP 连接上，所以数据传输是安全的\n\n### GET/POST 区别\n\n1. POST**更安全**\n    - 不作为url一部分，不会被缓存，不在浏览器记录中，不保存在服务器日志中\n2. POST能发送**更大数据**\n3. POST能发送**更多数据类型**，而GET只能是ASCII码字符\n4. POST比GET**慢**\n    1. 过程慢\n    2. get能进行数据缓存，post不行（e.g. 例如下载图片，get的能缓存）\n    3. post不能进行管道化传输 （一旦传输过程中出现断开，需要重新开始一次队列任务）\n\n# 浏览器缓存\n## Cache-Control字段\n- no-cache 让浏览器忽略缓存，而不是让浏览器不缓存。（浏览器依旧缓存）\n    - 可以在客户端存储资源，**每次都必须去服务端做新鲜度校验**，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的**协商缓存**。\n- no-store 这个才是不让浏览器缓存\n- max-age 从请求开始算，到过期时间之间的秒数\n- public 谁都能缓存，代理服务器也行\n- private 代理服务器不能缓存\n\n## Expires字段\nExpires: Thu, 10 Nov 2017 08:45:11 GMT 在未过期之前不需要再次请求\n\n## 浏览器缓存策略：强缓存 与 协商缓存\n- expires 或 cache-control 没过期，走强制缓存\n- if-none-match 和 if-modified-since 与 ETag 和 last-modified 匹配，走协商缓存 304\n\n## 关闭tcp\n为什么挥手需要四次？\n- 关闭连接时，客户端向服务端发送 `FIN` 时，**仅仅表示客户端不再发送数据**了**但是还能接收**数据。\n- 服务器收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文（**告知客户端“我知道你想断开连接的请求了”。这样客户端便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。**），\n而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。\n客户端收到关闭通知，告诉服务端我关了\n\n服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，从而比三次握手导致多了一次。\n\n## 同源策略\nAccess-Control-Allow-Origin\n目的：\n- 减少服务器压力\n- 加强数据安全\n规避同源策略\n- 网页图片链接可以不同源\n- 加载 cdn link 可以不同源\n\n      ")])]),n("section",[n("h3",[t._v("AJAX")]),n("pre",[t._v("# GET\nvar xhr;\n\n// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器\nif (window.XMLHttpRequest) { // 兼容性\n  xhr = new XMLHttpRequest();\n} else {\n  xhr = new ActiveXObject('Microsoft.XMLHTTP');\n}\n\n// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址\nxhr.open('GET', 'https://api.publicapis.org/entries', true);\n\n// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求\nxhr.send();\n\nconsole.log(xhr.readyState); // 0 1 在发送前和发送后\n\n// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作\nxhr.onreadystatechange = function() {\n  console.log(xhr.readyState); // 2 3 4 在 onreadystatechange 中\n  // 通过 xhr 的 readyState 判断此次请求的响应是否接收完成\n  // 4代表done\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    // 通过 xhr 的 responseText 获取到响应的响应体\n    console.log(JSON.parse(xhr.responseText));\n  }\n}\n# POST\nvar xhr;\n\nif (window.XMLHttpRequest) { // 兼容性\n  xhr = new XMLHttpRequest();\n} else {\n  xhr = new ActiveXObject('Microsoft.XMLHTTP');\n}\n\nxhr.open('POST', 'https://api.publicapis.org/entries', true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n// post请求要写 👆(setRequestHeader写open和send之间) \n// post参数是字符串形式 👇🏻\nxhr.send('status=1&flag=1');\n\nconsole.log(xhr.readyState); // 0 1 在发送前和发送后\n\nxhr.onreadystatechange = function() {\n  console.log(xhr.readyState); // 2 3 4 在 onreadystatechange 中\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    console.log(JSON.parse(xhr.responseText));\n  }\n}\n\n# 6 种跨域获取数据\n1.代理服务器\n同源策略只针对浏览器（客户端），服务器之间没有跨域限制。客户端先向同源的服务器发送请求，同源服务器再向不同源的服务器请求数据，最后同源服务器将获取到的数据返回给客户端。\n    const http = require('http');\n    const url = require('url');\n\n    // 创建代理服务器\n    const proxyServer = http.createServer((req, res) => {\n        // 解析目标服务器的 URL\n        const targetUrl = 'http://target-domain.com' + req.url;\n        const options = {\n            hostname: url.parse(targetUrl).hostname,\n            port: 80,\n            path: url.parse(targetUrl).path,\n            method: req.method,\n            headers: req.headers\n        };\n\n        // 向目标服务器发送请求\n        const proxyReq = http.request(options, (proxyRes) => {\n            // 将目标服务器的响应返回给客户端\n            res.writeHead(proxyRes.statusCode, proxyRes.headers);\n            proxyRes.pipe(res);\n        });\n\n        req.pipe(proxyReq);\n    });\n\n    proxyServer.listen(3000);\n\n## 2.CORS 跨域\n    const http = require('http');\n    const url = require('url');\n\n    http.createServer((req, res) =》 {\n        const origin = req.headers.origin;\n        // 允许指定源访问\n        res.setHeader('Access-Control-Allow-Origin', 'http://allowed-domain.com');\n        // 允许的请求方法\n        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n        // 允许的请求头\n        res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\n        const data = { response: 'Data from server' };\n        res.end(JSON.stringify(data));\n    }).listen(8081);\n\n## iframe跨域\n\n## jsonp不支持POST请求，只支持GET\nscript src=\"http://example.com/api?callback=myCallback\" /script\n      ")])]),n("section",[n("h3",[t._v("专题系统")]),n("pre",[t._v('# **为什么需要加密？**\n因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。\n劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。\n所以我们才需要对信息进行加密。\n\n最容易理解的就是对称加密\n简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多\n如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。\n\n非对称加密\n简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。\n\n数字签名 CA证书\n\n# http2 与 http1.1 区别\n- HTTP/1.1有两个主要的缺点：安全不足和性能不高。\n- HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；\n- QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。\n\n# 前端网络储存\ncookie与session\n\n### 使用方式\ncooki机制：\n\n- 生命周期\n    - 默认情况下，cookie**保存在内存**中，浏览器关闭就没了\n    - **设置过期**时间后，cookie**保存在硬盘**上，关闭浏览器仍然存在，直到过期时间结束才消失。\n- 数据类型\n    - cookie以**文本**形式保存在客户端，每次请求时都带上它。\n\nsession机制：\n\n- 每次请求，服务器会检查是否有sessionid\n    - 有，服务器根据id返回对应session对象\n    - 无，服务器创建新的session对象，并把sessionid在本次响应中返回给客户端。\n- 通常使用cookie方式存储sessionid到客户端\n    - **用户禁用cookie时，如何传递sessionid**\n    - 服务端渲染：服务端可以使用URL重写，就是把session_id附带在每个网址后面\n\n- 前后端分离：\n    - 后端把 sessionid 返回给前端\n    - 前端判断浏览器是否禁用cookie `navigator.cookieEnabled` 如果禁用把 sessionid 存进 `localStorage` ，登录后传递 cookie\n\n### 存储方式\n\n- cookie\n    - 只能保存**字符串类型**，以文本的方式\n    - 根据同源策略，cookie 是区分端口的，但是浏览器实现来说，“cookie 区分域，而不区分端口，也就是说，同一个 ip 下的多个端口下的 cookie 是共享的！\n- session\n    - 能支持**任何类型**的对象\n\n### 存储大小\n\n- cookie单个不超过**4kb**\n- session没限制\n\n### 安全性\n\n- cookie（不安全）：Cookie欺骗，Cookie截获；\n- session（相对安全）的原因：\n    - sessionID存在cookie中，首先得攻破cookie\n    - sessionID得有人登录，或启动session_start才会有，所以攻破cookie也不一定能得到sessionID\n    - 第二次启动session_start后，前一次的sessionID就失效，session过期后，sessionID也随之失效\n    - sessionID是加密的\n\n# localStorage 和 sessionStorage 区别\n### 生命周期\n\n- sessionStorage：\n    - 有“浏览器窗口”的概念，在同源的窗口中始终存在。只要这个浏览器**标签或窗口没有关闭**，**刷新或进入同源另一个页面(不是同源也行)，数据依然存在**。\n    但是sessionStorage在关闭了浏览器窗口后就会被销毁。\n    同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。（隔离性）\n- localStorage：\n    - **生命周期永久**，除非主动删除**（js删除，清除浏览器缓存）**\n\n### 存储大小\n- 一般都是：5MB\n\n### 存储位置\n- 都保存在客户端，不与服务器进行交互通信\n\n### 存储类型\n- 只能存储**字符串类型**，对于复杂的对象可以使用ECMAScript提供的**JSON对象的stringify和parse**来处理\n\n### 使用场景\n- localStorage：购物车\n- sessionStorage：**编辑页刷新页面**，写的内容不丢失。\n\n### web storage 和 cookie 的区别\n**作用不同**：web storage是用于**本地大容量存储**数据(存储量5MB);而cookie是用于**存用户登录状态**；\n**使用方式**：web storage有setItem、getItem、removeItem、clear等方法，cookie需要我们自己来封装setCookie、getCookie、removeCookie。\n\n## 前端请求axios\n- 默认 headers 的 `Content-Type` ：\n    - get: 无\n    - put、post、patch 都为 `application/json`\n- data、params\n    - get 请求用：`params`\n    - post 请求用：`data`\n- post 请求常见的数据格式（content-type）\n    1. `Content-Type: application/json` ： 请求体中的数据会以 json 字符串的形式发送到后端\n        1. 后端得配置 `Access-Control-Allow-Headers`\n    2. `Content-Type: application/x-www-form-urlencoded`：请求体中的数据会以普通表单形式（键值对）发送到后端 username=user1&password=pass123；\n    3. `Content-Type: multipart/form-data`： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件\n      ')])])])}],Be={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Fe=Be,ke=Object(d["a"])(Fe,Le,je,!1,null,"1cdd8970",null),Ue=ke.exports,We=function(){var t=this;t._self._c;return t._m(0)},He=[function(){var t=this,n=t._self._c;return n("div",[n("pre",[t._v("master\n - dev（release）\n  - feature\n    ")]),n("h3",[t._v("npm包管理")]),n("pre",[t._v("项目级 npmrc 》 用户级 npmrc 》 全局 npmrc 》 npm 内置 npmrc\n\nnpm link的本质是创建一个软连接\n工作原理是 : 将其链接到全局 node 模块安装路径中 . 为目标 npm 模块的可执行 bin 文件创建软连接 将其连接到全局 node 命令安装路径中 \n\nnpx 可以直接执行 node_modules/.bin 下的文件 , 可以自动去 node_modules/.bin 路径和环境变量 $path 中检查命令是否存在 .\nnpx 会在执行模块时 优先安装依赖 , 但是在安装结束后便删除该依赖 , 优点是 : 避免全局安装模块\n\nnpm install ，就可以自动安装对应的模块：\n- 发出 npm install 命令，查询 node_modules 目录之中是否已经存在指定模块\n    - 若存在，不再重新安装\n    - 若不存在\n        - npm 向 registry 查询模块压缩包的网址\n        - 下载压缩包，存放在根目录下的 `.npm` 目录里\n        - 解压压缩包到当前项目的 `node_modules` 目录\n    ")])])}],Ge={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Ye=Ge,qe=Object(d["a"])(Ye,We,He,!1,null,"371b8053",null),ze=qe.exports,Xe=function(){var t=this,n=t._self._c;return n("div",[t._m(0),n("h3",[t._v("Vue")]),n("pre",[t._v('# 核心概念\n- 组件化\n- 数据双向绑定（基于 ES5 中的 defineProperty 实现的）IE9及以上才支持\n    - 通过 `defineProperty` 深度遍历并劫持 data 数据\n        - 通过 getter 读取属性值\n        - 通过 setter 监听属性变化，通知 watcher 更新（update）视图\n    - 通过编译模板，寻找类似 input 中 v-model 绑定\n        - 给 input 添加事件绑定\n        - `value` 变化触发 `@input` 事件，更改数据\n        - `v-model` 是 `@input + value` 的语法糖\n- MVVM\n    - data 变化 --- vm 数据劫持 --》 view 更新\n    - data 更新 《-- vm 事件监听 --- view 变化\n\n# 相关使用\n## v-model 本质上是语法糖，即利用 v-model 绑定数据，其实就是既绑定了数据，又添加了一个 input 事件监听\ninput 元素：v-model = @input + :value\n\n父组件 :xxxx.sync="prop"\n子组件 this.$emit("update:xxxx", value)\n\n## 指令 directive：v-xxx=""\n公共逻辑复用\nVue.directive（\'focus\', 『\n  bind: function (el) { \n    // 每当指令绑定到元素上时，会立即执行这个函数，只执行一次\n    // 注意：在每个函数中，第一个参数永远是 el ，表示被绑定了指令的那个元素。\n    // \t\t这个 el 参数，是一个原生的JS对象\n    // 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用 focus 方法没有作用\n    //  因为，一个元素，只有插入DOM之后，才能获取焦点\n    // el.focus() 无效\n  },\n  inserted: function (el) {  // 元素插入到DOM中的时候，会执行 inserted 函数【触发1次】\n    el.focus()\n    // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效\n  },\n  updated: function (el) {  // 当VNode更新的时候，会执行 updated， 可能会触发多次\n  }\n\n# 生命周期\nbeforeCreate\ncreated：组件实例已经创建完成，data、props 已经初始化\nbeforeMount\nmounted：组件已挂载到真实 DOM\nbeforeUpdate：data 中的状态值是最新\nupdated：虚拟 DOM 重新渲染\nbeforeDestroy：实例仍然完全可用\ndestroyed：实例销毁后调用（刷新页面并不会触发 beforeDestroy 或 destroyed）\n// 页面加载时只执行onload\n// 页面关闭时先执行onbeforeunload，最后onunload\n// 页面刷新时先执行onbeforeunload，然后onunload，最后onload\n\n# Mixins混入\n1. data\n    每个mixin都可以拥有自己的data 每个data函数都会被调用 并将返回结果合并 在数据的 property 发生冲突时 会以组件自身的数据为优先。\n2. 值为对象的选项\n    例如 methods、components 和 directives 将被合并为同一个对象。两个对象键名冲突时 取组件对象的键值对。\n\n# 说说nextTick的用处\n**修改数据时不能马上得到最新的DOM信息**，所以需要使用nextTick，在**nectTick回调**中可以获取最新DOM树信息\n**nextTick触发的时机：\n同一事件循环中的代码执行完毕 → DOM信息更新→ nextTick callback触发**。\n\n实现原理：\nvue维护一个数组，每次调用时把回调函数压入这个数组，然后优先选择微任务，在微任务回调中去执行数组中的所有回调，同时维护一个布尔值，确保每一次队列 进行一次执行数组所有回调\n\n## 为什么nextTick优先是微任务？\n\nnextTick 优先级如下：\n- Promise.resolve().then：微任务\n- MutationObserver：宏任务\n- setImmediate：宏任务\n- setTimeout：宏任务\n\n优先是Promise.then方法，是个微任务。\n微任务一定比宏任务优先执行，如果nextTick是微任务，它会在当前同步任务执行完立即执行所有的微任务，也就是修改DOM的操作也会在当前tick内执行，等本轮tick任务全部执行完成，才是开始执行UI rendering。\n如果nextTick是宏任务，它会被推进宏任务队列，并且在本轮tick执行完之后的某一轮执行，注意，它并不一定是下一轮，因为你不确定宏任务队列中它之前还有多少个宏任务在等待着。所以为了能够尽快更新DOM，Vue中优先采用的是微任务，并且在Vue3中，它没有了兼容判断，直接使用的是`promise.then`微任务，不再考虑宏任务了。\n\n    ')]),n("input",{attrs:{type:"checkbox"},domProps:{checked:t.checked},on:{change:t.updateSomething}}),n("h3",[t._v("vue-router")]),n("pre",[t._v("## hashchange   \n锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据\n## window.history.pushState ， replaceState\n## 实例属性\n- route（只读、具备信息的对象）\n- router（具备功能函数）\n\n## 导航守卫解析流程\n- 全局 beforeEach\n- 重用组件调用 beforeRouteUpdate\n- 路由独享守卫 beforeEnter\n- 组件内 beforeRouteEnter\n- 全局 beforeResolve\n- 全局 afterEach\n- 组件内 beforeRouteLeave\n\n## history 原理\n- location.pathname 读取\n- history.pushState(state, 'title', 'url'); 写入\n- `popstate` 监听浏览器的前进后退\n- vue使用history模式，后端得配置\n    - 让用户无论访问什么路由，都返回 `index.html` 让vue接管路由\n\n## hash原理\n- `location.hash` 读写\n- `hashchange` 监听\n\n## 讲一讲完整的路由导航解析流程\n\n1. 导航被触发。\n2. 在失活的组件里调用 beforeRouteLeave 守卫。\n3. 调用全局的 beforeEach 守卫。\n4. 在**重用的**组件里调用 beforeRouteUpdate 守卫 (2.2+)。\n5. 在**路由配置**里调用 beforeEnter。\n6. 解析异步路由组件。\n7. 在被激活的组件里调用 beforeRouteEnter。\n8. 调用全局的 beforeResolve 守卫 (2.5+)。\n9. 导航被确认。\n10. 调用全局的 afterEach 钩子。\n11. 触发 DOM 更新。\n12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n**简化版：**\n1. from当前路由 beforeRouteEnter\n2. 全局路由 beforeEach\n\n3. to路由钩子 beforeRouteEnter\n4. 全局 beforeResolve\n5. 全局 afterEach\n\n6. DOM 更新\n7. 调用 beforeRouteEnter 中传入的 next 回调函数\n  ")]),n("h3",[t._v("vuex")]),n("pre",[t._v("why：为了保存组件之间需要共享的数据 \nstate的数据：不能直接修改。需通过 mutations 来改变\n\n Vuex 插件初始化时，new Vue 中传入的 store 实例，install 时会被混入到 App.vue 组件上；\n 最终所有组件都将混入来自父组件的 store 实例，从而实现 store 容器实例的共享\n     ")]),n("h2",[t._v("原理")]),n("pre",[t._v('# Vue 如何实现双向数据绑定的？\n\nObserver（观察者）\n- 给 data 对象下所有的属性添加上 get 和 set 方法。\n- get： 提供属性值的获取。每个属性如果是第一次调用 get 方法，就给当前属性添加上一个**消息订阅器**。\n- set：当监听到值有改动时，让消息订阅器通知 watcher 更新页面\n\nCompiler（指令解析器）\n- 扫描根节点下的所有元素，找到每个节点上的指令并解析。\n- 譬如一个 input 标签有个 v-model ，首先通过 vm 实例把属性名相同的值赋给它，再就是添加事件（input），在事件触发的时候把标签上的值赋值给 data 中相应的属性\n- 如果是个 `{{}}` ，就给这个属性添加一个 watcher，在接收到消息订阅器的消息后调用 update 方法更新值\n\nDep（消息订阅器）\n- 负责发布订阅\n- 把订阅者放进数组中，每当 notify 被调用后（Observer 的 set 改变时触发），会通知 watcher 订阅者更新视图\n\nWatcher（订阅者）\n- 在消息订阅器上订阅每个属性的变化，在属性变化后收到消息执行回调 update 方法，从而更新视图\n\n# defineProperty的问题\n1. Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；\n2. Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。\n3. Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。\n\n# data 为什么必须得是个函数\n如果 data 不是个函数，则有可能出现不同实例、或者组件修改的是同一份 data 引用\n\n# v-if/v-show 实现原理\nv-if: \n- true: 显示DOM\n- false: 用**注释节点占位**\n- **注释节点与DOM之间的切换**\nv-show\n- true: 不作处理（用户自己设置的 `display`）\n- false: 行内样式设置**`display: none`**\n- **行内样式：style or style="display: none"**\n\n# computed\n- 根据 computed 特性来思考\n    - 数据得缓存\n        - 得有个地方保存每次计算后的结果\n    - get函数中的依赖发生变化后，就得重新计算\n        - 所以得把这些依赖收集起来\n    - 监听到依赖变化后得更新\n        - 还得保存get函数\n\n- computedPool\n    - 有一个 pool 存所有 computed\n    - pool 中每个 computed 都是个对象，包含\n        - value：缓存计算结果\n        - get：保存 get 函数\n        - dep：收集函数中的依赖\n\n# vue模板编译过程\n\n输入template =》输出 DOM\n\n1. 获取 template\n2. template 转 AST 抽象语法树\n3. AST 转为 render 函数\n4. render 函数 转换 虚拟节点\n5. 设置 PATCH打补丁， 生成新真实 DOM（diff算法）\n\n# keep-alive\nkeep-alive 在内部维护了一个 key数组和一个 缓存对象；\n- key数组: 记录目前缓存的组件key值，如果组件没有指定key值，会自动生成一个唯一的key值\n- cache对象： 以 key 值为键，vnode 为值，用于**缓存组件**对应的**虚拟DOM**\n\n# mvc 和 mvvm\n## mvc\n- Model：模型层\n    - 定义数据结构\n    - 连接、修改数据库\n- View：视图层\n    - 数据展示、交互\n- Controller：控制层\n    - 事件绑定\n    - 关联视图和数据\n    - 需要操作 DOM\n\n## MVVM\n- Model：模型层\n    - 定义数据结构\n    - 连接、修改数据库\n- View：视图层、视图模板\n    - 数据展示、交互\n- ViewModel：**视图驱动**\n    - 关联View与Model\n    - 渲染视图、绑定事件\n    - 让用户关注业务，**减少DOM操作**\n    - **数据绑定、事件监听**\n\n    ')]),n("h3",[t._v("Vue3")]),n("pre",[t._v("# Vue2 和 Vue3 区别\n## Options API VS Composition API\nOptions API\n- 优点：\n    - 低耦合：横向切割清晰，数据全放 data，方法全放 methods\n- 缺点：\n    - 逻辑不内聚\n        - 一旦 methods 中有上十个、上百个方法，要更改 data 下上百个数据，维护起来就很困难了，得上下滚动页面到处找修改的出处\n\nComposition API\n- 优点：\n    - 高内聚低耦合\n    - 基于函数：\n        - 为什么要基于函数？\n            - 因为函数最好抽离、最好抽象、最好组合、还能利用闭包缓存数据、更改 this 等好处\n- 在 setup 中可以提取逻辑\n\n# Vue3.0 新特性\n\n## 重写双向数据绑定\n- 可以监听数组变化\n- 可以监听动态新增的属性\n- 可以监听删除的属性\n- 可以监听数组的索引和 length 属性的变化\n- 代码更简化\n \n## VDOM diff优化\n增加 patch flag 补丁标记\n在 Vue2 中，每次更新 diff，都是全量对比，Vue3 则只对比带有标记的，这样大大减少了非动态内容的对比消耗\n\n## Fragments\n允许我们支持多个根节点， jsx， tsx语法\n\n## Tree-Shaking 的支持\n保持代码运行结果不变的前提下，去除无用的代码；\n在 Vue2 中，无论我们使用什么功能，它们最终都会出现在生产代码中。\n主要原因是 Vue 实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到\n\n- Composition API\n\n    ")]),n("h3",[t._v("对比")]),n("pre",[t._v("## Vue 跟 React 有什么异同\n- 相同\n    - 都是**单向数据流**\n    - 都使用了 **虚拟DOM** 技术\n    - 都支持 SSR\n    - 都是基于**组件化开发**\n- 不同点\n- 视图\n    - vue: template\n    - react: JSX\n- 数据改变\n    - vue: 响应式\n    - react: **手动 setState**\n- 事件绑定\n    - vue: 双向绑定\n    - react: 单向绑定\n- 状态管理工具\n    - vue: Vuex\n    - react: Redux、Mobx\n\n    ")])])},Je=[function(){var t=this,n=t._self._c;return n("section",[n("h4",[t._v("Virtual DOM")]),n("img",{attrs:{src:"https://evelance.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd12335be-14e8-424d-a7a1-a6337bff01bc%2FUntitled.png?table=block&id=1a85d29c-7fa8-4f0c-9e1f-07021f84d9bd&spaceId=c9e7ae34-64f6-4cc4-9c74-4ce3b1d1ee92&width=1420&userId=&cache=v2",alt:""}}),n("pre",[t._v("Virtual DOM 的概念有很多解释，分别是：一个对象，两个前提，三个步骤\n一个对象 指的是 Virtual DOM 是一个基本的 JavaScript 对象，也是整个 Virtual DOM 树的基本\n两个前提 分别是:\n直接操作 DOM 的低效和 JavaScript 的高效相对比，为 Virtual DOM 的产生提供了大前提\n\n- **运行效率高**\n    - 因为 DOM 操作的执行速度远不如 **Javascript 的运算速度快**。因此，把大量的 DOM 操作放在到 Javascript 中，运用 **patch 算法**来计算出**真正需要更新的节点**，最大限度地**减少 DOM 操作**，从而显著**提高性能**\n- **提高渲染的性能**\n    - Virtual DOM 的优势在于在**大量、频繁的数据更新**下，能够对视图进行**合理、高效的更新**\n- **具备跨平台的优势**\n    - 由于 Virtual DOM 是**以 Javascript 对象为基础而不依赖真实平台环境**，所以使它具有了跨平台的能力\n\n# 虚拟 DOM 更新 + diff 算法\n1.生成 Virtual DOM 树\n抽象出一个 DOM 节点却只需要三部分：节点类型，节点属性、子节点; 给节点实现渲染方法，就可以实现虚拟节点到真实 DOM 的转化。\n\n2.对比两棵树的差异（diff）\n为了避免这些不必要的 DOM 操作，就需要将新的虚拟节点与上一次渲染视图所使用的旧的虚拟节点做对比，找出真正需要更新的节点来进行 DOM 操作。最后在更新视图。\n\n首次渲染 和 再次渲染\n\n### diff设计规则\n同层比较、不跨级\n标签名不同，直接替换，不深度比较\n标签名和 key 都相同，当做相同节点，属性改变则更新属性\n\n步骤：\n1.新老节点不是同一个节点名称，删除旧的节点，创建插入新的节点\n2.只能同级比较，不能跨层比较，如果跨层那么就暴力删除旧的节点，\n3.相同节点，又分为很多情况\n3.1 新节点有没有 children\n  证明新节点是文本，那直接把旧的替换成新的文本\n3.2 新节点也有 children \n===========================\n3.2.1==新节点的有 children，旧节点的也有 children （diff 算法核心（最复杂的情况））\n1. 旧前 vs 新前\n2. 旧后 vs 新后\n3. 旧前 vs 新后\n4. 旧后 vs 新前\n5. 以上都不满足，遍历查找\n6. 创建 or 删除\n\n3.2.2==新的有 children，旧的没有 children\n创建元素并添加\n\npatch， patchVnode， updateChildren方法（4个指针扫描遍历）\n\n      ")])])}],$e={name:"xxx",model:{prop:"checked",event:"change"},props:{checked:{type:Boolean,default:!1}},data(){return{}},mounted(){},methods:{updateSomething(t){this.$emit("change",t.target.checked)}}},Ke=$e,Ze=Object(d["a"])(Ke,Xe,Je,!1,null,"764cbabf",null),Qe=Ze.exports,tr=function(){var t=this;t._self._c;return t._m(0)},nr=[function(){var t=this,n=t._self._c;return n("div",[n("h3",[t._v("react")]),n("p",[t._v("react核心运行过程")]),n("img",{staticStyle:{width:"800px"},attrs:{src:"https://github.com/adodo0829/blog/blob/master/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React%E6%BA%90%E7%A0%81/images/react-core.png?raw=true",alt:""}}),n("p",[n("a",{staticStyle:{color:"blue"},attrs:{href:"https://7km.top/main/macro-structure"}},[t._v("图解react，便于理解Ta的工作流")])]),n("pre",[t._v("React 仅仅负责 View 层渲染, 库级别\n1.jsx\n2.ReactDOM.render(jsx, rootDom)\n3.组件\n- 组件一般在内部管理数据集合（state）\n- 外部传入配置集合（props）\nsetState 操作合并的原理 - 浅合并\n数据（状态）从父到子，由上而下传递的这种方式叫做单向数据流\n\nHooks\n1. Hook是 React 16.8.0 版本增加的新特性/新语法\n2. 可以让你在函数组件中使用 state 以及其他的 React 特性\n\nuseEffect Hook 看做如下三个函数的组合\ncomponentDidMount()\ncomponentDidUpdate()\ncomponentWillUnmount()\n\n组件通信方式\n- 父子组件：props\n- 兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理 redux\n- 祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)\n\n对于状态管理的解决思路就是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测\nredux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数\n\nReact 的基本思维模式是每次有数据变动就整个重新渲染整个应用\n    ")])])}],er={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},rr=er,or=Object(d["a"])(rr,tr,nr,!1,null,null,null),ir=or.exports,ar=function(){var t=this;t._self._c;return t._m(0)},sr=[function(){var t=this,n=t._self._c;return n("div",[n("h3",[t._v("构建工具 webpack")]),n("pre",[t._v("为什么要用：\n- 实现项目工程的自动化：本地 和 线上 分离\n    - 本地版本：\n        - html，js，css分离\n        - 模块化\n        - 方便维护\n        - es6\n        - sass\n    - 线上版本（webpack打包）：\n        - 高性能\n        - 体积小\n        - 速度快\n\n怎么玩：\nwebpack.config.js 配置\n\n# loader\nloader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；\n实质是一个转换器，将A文件进行编译形成B文件，操作的是文件\n\n- 核心点\n    - loader 是个函数，有个 source 参数，内容就是 .md 文件源码\n    - 我们需要 .md 最终返回的是个vue组件字符串\n        - 在函数中处理md语法转为 html标签\n        - 最后返回这个这个拼凑的组件\n\nmodule.exports = (source) =》 {\n  return 'template xxxx template'\n}\n\n# plugin\nplugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事;\n可以理解为打包产物加工器\n\n## loader 与 plugin的区别\n- 运行时机\nloader 运行在打包文件之前\nplugins 在整个编译周期都起作用\n\n\n\n# 构建流程\nwebpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来；\n在运行过程中会广播事件，插件plugin只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变webpack的运作，使得整个系统扩展性良好\n\n从启动到结束会依次执行以下三大步骤:\n- 初始化流程：从配置文件(webpack.config.js，)和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\n- 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理\n- 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\n\n# 编写loader\n其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader设为一个箭头函数\n函数接受一个参数source，为 webpack 传递给 loader 的文件源内容；\n\n函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息\n函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer\n\n// 导出一个函数，source为webpack传递给loader的文件源内容\nmodule.exports = function(source) {\n    const content = doSomeThing2JsString(source);\n\n    // 如果 loader 配置了 options 对象，那么this.query将指向 options\n    const options = this.query;\n\n    // 可以用作解析其他模块路径的上下文\n    console.log('this.context');\n\n    /*\n     * this.callback 参数：\n     * error：Error | null，当 loader 出错时向外抛出一个 error\n     * content：String | Buffer，经过 loader 编译后需要导出的内容\n     * sourceMap：为方便调试生成的编译后内容的 source map\n     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程\n     */\n    this.callback(null, content); // 异步\n    return content; // 同步\n}\n\n# 编写plugin\n由于webpack基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务\n\n- 插件必须是一个函数或者是一个包含 apply(compiler) 方法的对象，这样才能访问compiler实例\n- 传给每个插件的 compiler 和 compilation 对象都是同一个引用，因此不建议修改\n异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程\n\nclass MyPlugin {\n    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply (compiler) {\n    // 找到合适的事件钩子，实现自己的插件功能\n    compiler.hooks.emit.tap('MyPlugin', compilation =》 {\n        // compilation: 当前打包构建流程的上下文\n        console.log(compilation);\n        // do something...\n        compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tapAsync('MyPlugin', (htmlPluginData, callback) =》 {\n          htmlPluginData.xxx = xxxx\n          callback(null, htmlPluginData)\n        })\n    })\n  }\n}\n在 emit 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容\n\n# webpack 热更新原理\n1. 当修改了一个或多个文件；\n2. 文件系统接收更改并通知 webpack；\n3. webpack 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；\n4. HMR Server 使用 webSocket 通知 HMR runtime 需要更新，HMR 运行时通过 HTTP 请求更新 jsonp；\n5. HMR 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新\n    ")]),n("h3",[t._v("vite")]),n("pre",[t._v("# 组成\n1.开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）\n2.一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源\n\nnpm init vite@latest\n    ")]),n("h3",[t._v("Babel")]),n("pre",[t._v("# Babel 的原理\nBabel 的转译过程分为三个阶段:\n1. 解析 Parse : 将代码解析生成抽象语法树（即AST），即词法分析与语法分析的过程\n2. 转换 Transform: 对于 AST 进行变换一系列的操作，Babel 接受得到 AST 并通过 `babel-traverse` 对其进行遍历，在此过程中进行添加、更新及移除等操作\n3. 生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模块是 `babel-generator`\n\n# 如何写一个 Babel 插件\nBabel 解析成 AST，然后插件更改 AST，最后由 Babel 输出代码\nmodule.exports = function(babel) {\n  return {\n    visitor: {}\n  }\n}\n    ")])])}],cr={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},lr=cr,dr=Object(d["a"])(lr,ar,sr,!1,null,"bda94d7e",null),hr=dr.exports,ur=function(){var t=this;t._self._c;return t._m(0)},pr=[function(){var t=this,n=t._self._c;return n("div",[n("h3",[t._v("typescript")]),n("pre",[t._v("为什么出现，弥补js的不足，类型声明， 很多错误只有在运行时才会被，提前规避发现\n增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\n\n1.静态类型检查让 TS 成为强类型语言\n2.TS 在支持与 JS 几乎相同的原始类型之外，还额外提供了枚举（Enum）和元组（Tuple）的支持\n\n## 修饰符和静态关键字\n1. 访问修饰符：public private protected\n2. 静态关键字：static 定义全局唯一的静态变量和静态函数。\n3. 抽象关键字：abstract\n4. 只读关键字：readonly\n\n## 接口\n接口（interface）用于一系列成员的声明，但不包含实现，接口支持合并（重复声明），也可以继承于另一接口\n\n## 联合类型\n使用联合类型（Union Types）允许你在声明变量或接收参数时兼容多种类型\n\n## 泛型\n使用泛型可以让一个类/函数支持多种类型的数据，使用时可以传入需要的类型。\n\n## 命名空间\n命名空间（namespace）用来定义标识符的可用范围，主要用于解决重名的问题，对于项目模块化有很大的帮助。Cocos Creator 中的 cc 就是一个内置的命名空间。\n    ")]),n("h3",[t._v("question")]),n("pre",[t._v("# type 和 interface 的区别？\n- 声明：interface 可以重复声明，type 不行\n- 继承：方式不一样，type 使用交叉类型方式，interface 使用 extends 实现。在对象扩展的情况下，使用接口继承要比交叉类型的性能更好。\n- 建议：使用 interface 来描述对象对外暴露的接口 ，使用 type 将一组类型重命名（或对类型进行复杂编程\n    ")])])}],vr={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},fr=vr,_r=Object(d["a"])(fr,ur,pr,!1,null,"65f16075",null),mr=_r.exports,br=function(){var t=this;t._self._c;return t._m(0)},gr=[function(){var t=this,n=t._self._c;return n("div",[n("p",[t._v(" 思考一下：为什么要优化，有必要一开始就优化吗？排期与优化冲突时如何抉择？ ")]),n("h3",[t._v("通用的优化手段")]),n("pre",[t._v("web前端优化：无非就是让软件界面如何 快速响应 （主要分为时间，空间两大方向）。\n\n# 1.空间内存优化\n1.静态资源压缩\n前端所有的文件程序代码都是要通过浏览器下载下来运行使用，涉及到网络和请求延时，所以前端文件的精简和压缩决定了前端性能的第一步\nhtml，css，js，图片压缩等，gizp，icon替代图片等\n需要Nginx配置\n\n2.资源合并\n减少文件请求次数（H5中比较明显）\n\n# 2.响应时间优化\n1.根据浏览器加载规则 来 合理安排静态资源引用的顺序；\n2.缓存优化\nHTTP协议缓存 =》到浏览器缓存 =》app cache\n- 强缓存：Expires 和 Cache-Control\n- 协商缓存：Last-Modified & Etag\n- 浏览器缓存 一些系统常量数据\n- Service Worker 代理服务器，离线资源缓存\n\n3.懒加载与预加载\n4.升级为http2\n需要升级服务器配置，nginx1.9.5以上，配置SSL\n5.首屏资源优化\nPreload 和 Prefetch\nPreload 一个基本的用法是提前加载资源,告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级，加载但是不运行，占用浏览器对同一个域名的并发数:\nPrefetch 一个一般用法是浏览器会在空闲的时候，下载资源, 并缓存起来。当有页面使用的时候，直接从缓存中读取。其实就是把决定是否和什么时间加载这个资源的决定权交给浏览器。\n对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。\n\n# 纯 前端层面的优化\n渲染优化\n- 重绘和重排控制（布局css使用）\n- requestAnimationFrame\n- requestIdleCallback,浏览器处于空闲状态执行，可以理解为后台运行，不要操作任何DOM\n- 虚拟列表等\n- 防抖节流等\n    ")]),n("h3",[t._v("其他")]),n("pre",[t._v("# 如何排查内存泄漏导致的卡顿？\n根据现象推断问题，页面卡顿，说明渲染线程阻塞了，什么能导致阻塞呢？该分给他的执行资源被别的模块占用了\n\n1.内存泄漏\n变量没有被手动的回收或自动回收；\nJavaScript的垃圾回收机制是自动执行的，并且会通过标记来识别并清除垃圾数据，\n在离开局部作用域后，若该作用域内的变量没有被外部作用域所引用，则在后续会被清除；\nJavaScript是运行在主线程上的，所以执行垃圾回收机制时会暂停js的运行，若垃圾回收执行时间过长，则会给用户带来明显的卡顿现象，\n所以垃圾回收机制会被分成一个个的小任务，穿插在js任务之中，即交替执行，尽可能得保证不会带来明显的卡顿感\n\n排查：\nChrome devTools =》performance =》 录制快照\n    ")]),n("h3",[t._v("业务上的优化思路")]),n("pre",[t._v("同样也是时间和空间上的优化：利用相关特性\n1.切片思想\n大任务切片，切成小任务\n2.合并思想\ngpu批处理\n\n")])])}],xr={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Ar=xr,wr=Object(d["a"])(Ar,br,gr,!1,null,"3dcb7a3a",null),Mr=wr.exports,Or=function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("观察者模式")]),n("img",{staticStyle:{width:"600px"},attrs:{src:"https://evelance.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa8956dcf-ca76-4292-926f-e00c0f962883%2FUntitled.png?table=block&id=7a8d0b3c-b382-4bb2-8954-17a6944e4bf0&spaceId=c9e7ae34-64f6-4cc4-9c74-4ce3b1d1ee92&width=1250&userId=&cache=v2",alt:""}}),n("pre",[t._v("  ## 观察者模式\n  定义是在对象之间定义一个**一对多的依赖**，当一个对象自身状态改变的时候，会自动通知给关心该状态的观察者；\n  解决了主体对象与观察者之间功能的耦合，即一个对象状态改变给其他对象通知的问题；\n  这种对象与对象，有点像 商家-顾客 的关系，顾客对商家的某个商品感兴趣，就被商家记住，等有新品发布，便会直接通知顾客\n")]),n("button",{on:{click:t.handleObserver}},[t._v("观察者接受主题发消息")]),n("button",{on:{click:t.handleEmit}},[t._v("发布订阅模式 发消息")])]),t._m(0),t._m(1),n("section",[n("h3",[t._v("单例模式")]),n("p",[t._v(" 一个类只有一个实例，访问的实例永远都是同一个； 全局变量也是一种简单的单例模式； 其实就是对同一个对象引用的操作 ")]),n("button",{on:{click:t.handleSingleMode}},[t._v("测试单例")]),n("pre",[t._v("// Singleton.js 导出去是同一个实例的引用,也可以当做单例使用\nclass Singleton {\n  constructor() {\n    this.someMethod = () => {\n      console.log('Doing something...');\n    };\n  }\n}\nconst instance = new Singleton();\nexport default instance;\n\nimport singletonInstance from './Singleton.js';\nconst instance1 = singletonInstance;\nconst instance2 = singletonInstance;\nconsole.log(instance1 === instance2); // 输出：true\n\n      ")])])])},yr=[function(){var t=this,n=t._self._c;return n("section",[n("h3",[t._v("发布订阅")]),n("img",{staticStyle:{width:"600px"},attrs:{src:"https://evelance.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9faab839-61db-4e57-8593-bececd6409da%2FUntitled.png?table=block&id=ecc4a952-cca9-4e28-82f9-1f4d05422777&spaceId=c9e7ae34-64f6-4cc4-9c74-4ce3b1d1ee92&width=1340&userId=&cache=v2",alt:""}}),n("pre",[t._v("  ## 发布订阅模式\n  也是定义一对多的依赖关系，对象状态改变后，通知给所有关心这个状态的订阅者。\n  订阅发布模式有订阅的动作，可以不和商家直接产生联系，只要能订阅上关心的状态即可，通常利用第三方媒介来做，而发布者也会利用三方媒介来通知订阅者。\n  有点像 商家-APP-顾客 的关系，某个产品断货，顾客可以在APP上订阅上货通知，待上新，商家通过APP通知订阅的顾客\n  在程序实现中，第三方媒介称之为 EventBus(事件总线/事件调度中心)，可以理解为订阅事件的集合，它提供订阅、发布、取消等功能。\n  订阅者订阅事件，和发布者发布事件，都通过事件总线进行交互。\n")]),n("pre",[t._v("两种模式的异同\n- 观察者模式\n    - 理解\n        - 顾客（观察者）→ 商店（被观察者）\n    - 行为\n        - 观察者观察对象的改变，对象改变后通知观察者自身改变\n        - 被观察者 自身管理 观察者以及后续的通知操作\n- 发布订阅模式\n    - 理解\n        - 顾客（订阅者）→ 公众号（事件总线/调度中心） ← 商店（发布者）\n    - 行为\n        - 顾客通过公众号订阅商店，商店发布消息后通过公众号告知所有顾客\n- 差异\n    - **发布订阅模式其实就是观察者模式的进一步抽象**，把**订阅池和发布功能**抽离成了一个事件总线/调度中心，方便灵活使用\n\n从概念上理解，两者没什么不同，都在解决对象之间解耦，通过事件的方式在某个时间点进行触发，监听这个事件的订阅者可以进行相应的操作。\n\n在实现上有所不同，**观察者模式**中的**发布者自身来维护**订阅者，后续的一些列操作都要通过**发布者完成**；\n订阅发布模式是订阅者和发布者中间会有一个**事件总线**，操作都要**经过事件总线**完成。\n    ")])])},function(){var t=this,n=t._self._c;return n("section",[n("pre",[t._v("面向对象：把具有相同属性和行为的事物抽象成一个事物类别，通过实例化，让这个事物类别构造出一个具体的事物，这个具体的事物就是对象\nclass实例化： 属性和方法集合的抽象\n\n封装：控制类的属性与方法的可访问方式：\n- private\t只有类的内部可访问\n- public\t完全开放访问\n- protected\t可供子类访问\n Symbol 实现方法私有化\n\nconst doAjax = Symbol('doAjax');\nclass HTTP {\n\t[doAjax](options) {\n  \t...\n  }\n}\n多态：方法的重写和重载\n\n继承：\n实例的__p__指向构造函数的原型prototype\nperson1.__proto__ === Person.prototype\n原型链是JavaScript中实现继承的机制。\n当试图访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript引擎会沿着原型链向上查找，直到找到该属性或者到达原型链的末端（Object.prototype的原型是null）。\n      ")])])}];class Tr{constructor(){Object(k["a"])(this,"handlerMap",{})}on(t,n,e){Array.isArray(this.handlerMap[t])||(this.handlerMap[t]=[]),this.handlerMap[t].includes(n)||(n.once=e,this.handlerMap[t].push(n))}off(t,n){this.handlers[t]&&(this.handlers[t]=this.handlers[t].filter(t=>t!==n))}once(t,n){this.on(t,n,!1)}emit(t,...n){const e=this.handlerMap[t];e.length&&e.forEach(e=>{n.length?e.apply(this,n):e.call(this),e.once&&this.off(t,e)})}}class Sr{static getInstance(t){return Sr.instance||(Sr.instance=new Sr(t)),Sr.instance}constructor(t){this.options=t}getOptions(){console.log("xxxx",this.options)}}Object(k["a"])(Sr,"instance",null);class Er{constructor(){this.someMethod=()=>{console.log("Doing something...")}}}new Er;class Dr{constructor(t){this.name=t}update(t){console.log(`我是观察者 watcher ${this.name}，收到通知`,t)}}class Rr{constructor(){this.observerMap={}}addListener(t,n){Array.isArray(this.observerMap[t])||(this.observerMap[t]=[]),this.observerMap[t].includes(n)||this.observerMap[t].push(n)}removeListener(t,n){const e=this.observerMap[t];if(e&&e.length){const r=e.filter(t=>t!==n);this.observerMap[t]=r}}emitListener(t,n){const e=this.observerMap[t];e&&e.length&&e.forEach(t=>{t.update(n)})}}var Vr={name:"xxx",components:{},data(){return{}},mounted(){},methods:{handleObserver(){const t=new Rr,n=new Dr(1),e=new Dr(2),r=new Dr(3);t.addListener("obWater",n),t.addListener("obWater",e),t.addListener("obTV",r),setTimeout(()=>{t.emitListener("obWater","水降价=》来啊，购买啊"),t.emitListener("obTV","tv降价了")},2e3)},handleEmit(){const t=new Tr;function n(t){console.log("我是执行 add1任务的",t)}function e(t){console.log("我是执行 add2任务的",t)}function r(t){console.log("我是执行 delete任务的",t)}t.on("add",n),t.on("add",e),t.on("del",r),t.emit("add",11),t.emit("del",222)},handleSingleMode(){let t=Sr.getInstance("xxxaa"),n=Sr.getInstance();t.getOptions(),n.getOptions(),console.log(t===n)}}},Pr=Vr,Ir=Object(d["a"])(Pr,Or,yr,!1,null,null,null),Nr=Ir.exports,Cr=function(){var t=this;t._self._c;return t._m(0)},Lr=[function(){var t=this,n=t._self._c;return n("div",[n("section",[n("h3",[t._v("递归")]),n("p",[t._v("函数中调用这个函数自身")]),n("pre",[t._v("函数的内部语句可以调用这个函数自身，从而发起对函数的一次迭代;\n在新的迭代中，又会执行调用函数自身的语句，从而又产生一次迭代;\n当函数执行到某一次时，不再进行新的迭代，函数被一层一层返回，函数被递归.\n它把一个大型复杂的问题，层层转化为一个与原问题相似的，但规模较小的问题来求解\n      ")]),n("h3",[t._v("遍历访问")]),n("p",[t._v("遍历通常指的是按照某种顺序访问数据结构中的每个元素；")]),n("pre",[t._v("\n顺序遍历：对于线性数据结构（如数组、链表），按照元素的顺序一个接一个地访问。\n\n深度优先遍历（DFS）：对于树或图，从根节点开始，尽可能深地搜索树的分支。\n从根节点出发，按照从左到右的顺序，访问其子节点，如果子节点还有子节点，则一直向下访问，直到没有子节点为止。\n从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止\n\n广度优先遍历（BFS）：对于树或图，从根节点开始，先访问所有相邻节点，然后逐层向外扩展。\n简单点说就是从根节点出发，一层一层的从上向下访问，同层节点从左往右访问，直到所有的节点都被访问到为止。\n是从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止\n\n二叉树遍历：对于二叉树，有前序遍历（根-左-右）、中序遍历（左-根-右）和后序遍历（左-右-根）三种主要方式。\n图的遍历：对于图，可以使用DFS或BFS来访问图中的所有顶点。\n层次遍历：对于多维数组或矩阵，可以按行或按列逐层访问\n      ")]),n("h3",[t._v("排序")]),n("p",[t._v(" 将一系列元素（如数字、字符串等）按照一定的顺序（通常是升序或降序）排列的过程 ")]),n("pre",[t._v('1.冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。\n2.快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的元素均比另一部分记录的元素小，继而再分别对这两部分记录递归的进行同样的排序操作。\n3.归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。\n      ')]),n("h3",[t._v("查找")]),n("pre",[t._v("1. 线性查找（Linear Search）\n线性查找是一种最简单的查找算法，它逐个检查数据结构中的每个元素，直到找到所需的元素或检查完所有元素为止。这种查找方法适用于无序数据结构。\n\n2. 二分查找（Binary Search）\n二分查找是一种在有序数组中查找特定元素的算法。它通过反复将待查找的元素与数组中间元素进行比较，缩小查找范围，直到找到元素或查找范围为空。\n\n3. 插值查找（Interpolation Search）\n插值查找是二分查找的一种改进版，它利用数据分布的特性来预测查找的下一位位置。如果数据分布均匀，插值查找可以更快地缩小查找范围。\n\n4. 指数查找（Exponential Search）\n指数查找首先使用二分查找的思想来确定待查找元素的大致范围，然后在这个范围内进行线性查找。\n\n5. 斐波那契查找（Fibonacci Search）\n斐波那契查找类似于二分查找，但它使用斐波那契数列来减少搜索区间的大小。斐波那契查找可以减少比较次数，但查找过程中的索引计算较为复杂。\n\n6. 哈希查找（Hash Search）\n哈希查找通过哈希函数将键映射到表中一个位置，以支持快速的插入、删除和查找操作。哈希查找的平均时间复杂度为O(1)，但在最坏情况下可能退化到O(n)。\n\n8. 深度优先搜索（Depth-First Search, DFS）\n深度优先搜索用于树或图结构中，从一个节点开始，尽可能深地搜索树/图的分支。\n\n9. 广度优先搜索（Breadth-First Search, BFS）\n广度优先搜索也是用于树或图结构中，从一个节点开始，先访问所有相邻节点，再逐层向外扩展。\n\n\n      ")])])])}],jr={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Br=jr,Fr=Object(d["a"])(Br,Cr,Lr,!1,null,null,null),kr=Fr.exports,Ur=function(){var t=this;t._self._c;return t._m(0)},Wr=[function(){var t=this,n=t._self._c;return n("div",[n("h3",[t._v("微前端")]),n("pre",[t._v("随着业务的复杂程度越来越高，我们的项目也变的越来越大，越来越臃肿，达到一定程度以后，如果后期想要重构，那将是灾难级别的。\n而且技术随着不断的更新，以前的老项目使用的老旧的技术栈，项目更新新技术就只能从新开一个项目。\n\n一个管理系统，里面有各种模块。我们可以按照业务拆分为多个系统进行开发。\n我们可以有一个主应用，然后把多个系统当成是子应用，独立开发，独立测试，独立部署，最后所有的子应用就承载到主应用上。\n\n需要先加载基座（主应用），再把选择权交给主应用，由主应用根据注册过的子应用来抉择加载谁，当子应用加载成功后，再由vue-router或react-router来根据路由渲染组件\n\n# 微前端的核心价值\n- 技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权\n- 独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n- 增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n- 独立运行时每个微应用之间状态隔离，运行时状态不共享\n\n# 主流方案\n## iframe\n天生隔离样式与脚本、多页\n1. 不是单页应用，会导致浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用\n2. 弹框类的功能无法应用到整个大应用中，只能在对应的窗口内展示\n3. 由于可能应用间不是在相同的域内，主应用的 cookie 要透传到根域名都不同的子应用中才能实现免登录效果\n4. 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程，占用大量资源的同时也在极大地消耗资源\n5. iframe的特性导致搜索引擎无法获取到其中的内容，进而无法实现应用的seo\n\n## Web Components（micro app）\n天生隔离样式与脚本，\n无法兼容所有浏览器\n\n## ESM\n远程加载模块\n1. 无法兼容所有浏览器(但可以通过编译工具解决)\n2. 需手动隔离样式（可通过css module解决）\n\n## qiankun\n1. HTML Entry 接入方式\n2. 资源预加载\n\n    ")])])}],Hr={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Gr=Hr,Yr=Object(d["a"])(Gr,Ur,Wr,!1,null,"3609c0be",null),qr=Yr.exports,zr=function(){var t=this,n=t._self._c;return n("div",[n("p",[n("button",{on:{click:function(n){return t.handledebounce1()}}},[t._v("防抖1,执行函数不传参")]),n("button",{on:{click:function(n){return t.handledebounce2("xx",{oo:1})}}},[t._v(" 防抖2，执行函数传参 ")]),n("button",{on:{click:function(n){return t.handledebounce3()}}},[t._v("防抖3,首次立即执行")])]),n("p",[n("button",{on:{click:function(n){return t.handleThrollte1()}}},[t._v("节流1,执行函数不传参")]),n("button",{on:{click:function(n){return t.handleThrollte2("xx",{oo:1})}}},[t._v(" 节流2，执行函数传参 ")])])])},Xr=[];function Jr(t,n){console.log("dbfunc",t,n)}function $r(t){console.log("throttle",t)}var Kr={name:"xxx",components:{},data(){return{}},mounted(){},methods:{handledebounce1:Wt(Jr,2e3),handledebounce2:Wt(Jr,2e3),handledebounce3:Wt(Jr,2e3,!0),handleThrollte1:Ht($r,2e3),handleThrollte2:Ht($r,2e3)}},Zr=Kr,Qr=Object(d["a"])(Zr,zr,Xr,!1,null,null,null),to=Qr.exports;i["default"].use(p["a"]);const no=[{path:"/",redirect:"/GLSL"},{path:"/GLSL",name:"GLSL",component:g},{path:"/Coord",name:"Coord",component:y},{path:"/Vector",name:"Vector",component:V},{path:"/Matrix",name:"Matrix",component:j},{path:"/TEST_GL_API",name:"TEST_GL_API",component:Kt},{path:"/Flow",name:"Flow",component:In},{path:"/FlowView",name:"FlowView",component:Wn},{path:"/three",name:"three",component:ie},{path:"/study",name:"Study",component:he,redirect:"/study/html",children:[{path:"/study/html",name:"html",component:me},{path:"/study/css",name:"css",component:Me},{path:"/study/js",name:"js",component:De},{path:"/study/browser",name:"浏览器",component:Ce},{path:"/study/network",name:"network",component:Ue},{path:"/study/git",name:"Git管理",component:ze},{path:"/study/vue",name:"框架vue",component:Qe},{path:"/study/react",name:"框架react",component:ir},{path:"/study/webpack",name:"webpack",component:hr},{path:"/study/ts",name:"ts",component:mr},{path:"/study/optimize",name:"优化手段",component:Mr},{path:"/study/designmode",name:"设计模式",component:Nr},{path:"/study/aigorithm",name:"算法",component:kr},{path:"/study/bussiness1",name:"业务1",component:qr},{path:"/study/test",name:"logicCode",component:to}]}],eo=new p["a"]({mode:"history",base:"/hh-render/",routes:no});var ro=eo,oo=e("2f62");i["default"].use(oo["a"]);var io=new oo["a"].Store({state:{},mutations:{},actions:{},modules:{}});e("8e1f");i["default"].use(o.a),i["default"].config.productionTip=!1,new i["default"]({router:ro,store:io,render:t=>t(u)}).$mount("#app")},5820:function(t,n,e){"use strict";e("f992")},6794:function(t,n,e){"use strict";e("d960")},"838c":function(t,n,e){},8554:function(t,n,e){t.exports=e.p+"static/img/1.3058969f.jpg"},"859d":function(t,n,e){},"8a76":function(t,n,e){t.exports=e.p+"static/img/coordlr.33299a8b.png"},"8e1f":function(t,n,e){},9376:function(t,n,e){},"97e5":function(t,n,e){t.exports=e.p+"static/img/bs.768201a7.png"},"9c9c":function(t,n,e){},a0b1:function(t,n,e){"use strict";e("9376")},b1b7:function(t,n,e){"use strict";e("2487")},b75e:function(t,n,e){"use strict";e("b78e")},b77c:function(t,n,e){"use strict";e("52fe")},b78e:function(t,n,e){},b99a:function(t,n,e){"use strict";e("2b08")},bafb:function(t,n,e){t.exports=e.p+"static/img/4.e580020d.jpg"},bd86:function(t,n,e){"use strict";e("ddfb")},c83a:function(t,n,e){e("2c66"),e("249d"),e("40e9"),e("907a"),e("986a"),e("1d02"),e("3c5d"),e("6ce5"),e("2834"),e("4ea1"),e("0643"),e("4e3e"),function(n,e){t.exports=e()}(0,(function(){return function(t){var n={};function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t["default"]}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=4)}([function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setMatrixArrayType=o,n.toRadian=a,n.equals=s;var r=n.EPSILON=1e-6;n.ARRAY_TYPE="undefined"!==typeof Float32Array?Float32Array:Array,n.RANDOM=Math.random;function o(t){n.ARRAY_TYPE=t}var i=Math.PI/180;function a(t){return t*i}function s(t,n){return Math.abs(t-n)<=r*Math.max(1,Math.abs(t),Math.abs(n))}},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.fromMat4=s,n.clone=c,n.copy=l,n.fromValues=d,n.set=h,n.identity=u,n.transpose=p,n.invert=v,n.adjoint=f,n.determinant=_,n.multiply=m,n.translate=b,n.rotate=g,n.scale=x,n.fromTranslation=A,n.fromRotation=w,n.fromScaling=M,n.fromMat2d=O,n.fromQuat=y,n.normalFromMat4=T,n.projection=S,n.str=E,n.frob=D,n.add=R,n.subtract=V,n.multiplyScalar=P,n.multiplyScalarAndAdd=I,n.exactEquals=N,n.equals=C;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function s(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t}function c(t){var n=new o.ARRAY_TYPE(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n}function l(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t}function d(t,n,e,r,i,a,s,c,l){var d=new o.ARRAY_TYPE(9);return d[0]=t,d[1]=n,d[2]=e,d[3]=r,d[4]=i,d[5]=a,d[6]=s,d[7]=c,d[8]=l,d}function h(t,n,e,r,o,i,a,s,c,l){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t[4]=i,t[5]=a,t[6]=s,t[7]=c,t[8]=l,t}function u(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function p(t,n){if(t===n){var e=n[1],r=n[2],o=n[5];t[1]=n[3],t[2]=n[6],t[3]=e,t[5]=n[7],t[6]=r,t[7]=o}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t}function v(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],d=n[8],h=d*a-s*l,u=-d*i+s*c,p=l*i-a*c,v=e*h+r*u+o*p;return v?(v=1/v,t[0]=h*v,t[1]=(-d*r+o*l)*v,t[2]=(s*r-o*a)*v,t[3]=u*v,t[4]=(d*e-o*c)*v,t[5]=(-s*e+o*i)*v,t[6]=p*v,t[7]=(-l*e+r*c)*v,t[8]=(a*e-r*i)*v,t):null}function f(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],d=n[8];return t[0]=a*d-s*l,t[1]=o*l-r*d,t[2]=r*s-o*a,t[3]=s*c-i*d,t[4]=e*d-o*c,t[5]=o*i-e*s,t[6]=i*l-a*c,t[7]=r*c-e*l,t[8]=e*a-r*i,t}function _(t){var n=t[0],e=t[1],r=t[2],o=t[3],i=t[4],a=t[5],s=t[6],c=t[7],l=t[8];return n*(l*i-a*c)+e*(-l*o+a*s)+r*(c*o-i*s)}function m(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],d=n[7],h=n[8],u=e[0],p=e[1],v=e[2],f=e[3],_=e[4],m=e[5],b=e[6],g=e[7],x=e[8];return t[0]=u*r+p*a+v*l,t[1]=u*o+p*s+v*d,t[2]=u*i+p*c+v*h,t[3]=f*r+_*a+m*l,t[4]=f*o+_*s+m*d,t[5]=f*i+_*c+m*h,t[6]=b*r+g*a+x*l,t[7]=b*o+g*s+x*d,t[8]=b*i+g*c+x*h,t}function b(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],d=n[7],h=n[8],u=e[0],p=e[1];return t[0]=r,t[1]=o,t[2]=i,t[3]=a,t[4]=s,t[5]=c,t[6]=u*r+p*a+l,t[7]=u*o+p*s+d,t[8]=u*i+p*c+h,t}function g(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],d=n[7],h=n[8],u=Math.sin(e),p=Math.cos(e);return t[0]=p*r+u*a,t[1]=p*o+u*s,t[2]=p*i+u*c,t[3]=p*a-u*r,t[4]=p*s-u*o,t[5]=p*c-u*i,t[6]=l,t[7]=d,t[8]=h,t}function x(t,n,e){var r=e[0],o=e[1];return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=o*n[3],t[4]=o*n[4],t[5]=o*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t}function A(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t}function w(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=0,t[3]=-e,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function M(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function O(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t}function y(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e+e,s=r+r,c=o+o,l=e*a,d=r*a,h=r*s,u=o*a,p=o*s,v=o*c,f=i*a,_=i*s,m=i*c;return t[0]=1-h-v,t[3]=d-m,t[6]=u+_,t[1]=d+m,t[4]=1-l-v,t[7]=p-f,t[2]=u-_,t[5]=p+f,t[8]=1-l-h,t}function T(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],d=n[8],h=n[9],u=n[10],p=n[11],v=n[12],f=n[13],_=n[14],m=n[15],b=e*s-r*a,g=e*c-o*a,x=e*l-i*a,A=r*c-o*s,w=r*l-i*s,M=o*l-i*c,O=d*f-h*v,y=d*_-u*v,T=d*m-p*v,S=h*_-u*f,E=h*m-p*f,D=u*m-p*_,R=b*D-g*E+x*S+A*T-w*y+M*O;return R?(R=1/R,t[0]=(s*D-c*E+l*S)*R,t[1]=(c*T-a*D-l*y)*R,t[2]=(a*E-s*T+l*O)*R,t[3]=(o*E-r*D-i*S)*R,t[4]=(e*D-o*T+i*y)*R,t[5]=(r*T-e*E-i*O)*R,t[6]=(f*M-_*w+m*A)*R,t[7]=(_*x-v*M-m*g)*R,t[8]=(v*w-f*x+m*b)*R,t):null}function S(t,n,e){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/e,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t}function E(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"}function D(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))}function R(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t[4]=n[4]+e[4],t[5]=n[5]+e[5],t[6]=n[6]+e[6],t[7]=n[7]+e[7],t[8]=n[8]+e[8],t}function V(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t[4]=n[4]-e[4],t[5]=n[5]-e[5],t[6]=n[6]-e[6],t[7]=n[7]-e[7],t[8]=n[8]-e[8],t}function P(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*e,t}function I(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t[4]=n[4]+e[4]*r,t[5]=n[5]+e[5]*r,t[6]=n[6]+e[6]*r,t[7]=n[7]+e[7]*r,t[8]=n[8]+e[8]*r,t}function N(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]}function C(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=t[4],c=t[5],l=t[6],d=t[7],h=t[8],u=n[0],p=n[1],v=n[2],f=n[3],_=n[4],m=n[5],b=n[6],g=n[7],x=n[8];return Math.abs(e-u)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(u))&&Math.abs(r-p)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(p))&&Math.abs(i-v)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(v))&&Math.abs(a-f)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(f))&&Math.abs(s-_)<=o.EPSILON*Math.max(1,Math.abs(s),Math.abs(_))&&Math.abs(c-m)<=o.EPSILON*Math.max(1,Math.abs(c),Math.abs(m))&&Math.abs(l-b)<=o.EPSILON*Math.max(1,Math.abs(l),Math.abs(b))&&Math.abs(d-g)<=o.EPSILON*Math.max(1,Math.abs(d),Math.abs(g))&&Math.abs(h-x)<=o.EPSILON*Math.max(1,Math.abs(h),Math.abs(x))}n.mul=m,n.sub=V},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=a,n.clone=s,n.length=c,n.fromValues=l,n.copy=d,n.set=h,n.add=u,n.subtract=p,n.multiply=v,n.divide=f,n.ceil=_,n.floor=m,n.min=b,n.max=g,n.round=x,n.scale=A,n.scaleAndAdd=w,n.distance=M,n.squaredDistance=O,n.squaredLength=y,n.negate=T,n.inverse=S,n.normalize=E,n.dot=D,n.cross=R,n.lerp=V,n.hermite=P,n.bezier=I,n.random=N,n.transformMat4=C,n.transformMat3=L,n.transformQuat=j,n.rotateX=B,n.rotateY=F,n.rotateZ=k,n.angle=U,n.str=W,n.exactEquals=H,n.equals=G;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t}function s(t){var n=new o.ARRAY_TYPE(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n}function c(t){var n=t[0],e=t[1],r=t[2];return Math.sqrt(n*n+e*e+r*r)}function l(t,n,e){var r=new o.ARRAY_TYPE(3);return r[0]=t,r[1]=n,r[2]=e,r}function d(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t}function h(t,n,e,r){return t[0]=n,t[1]=e,t[2]=r,t}function u(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t}function p(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t}function v(t,n,e){return t[0]=n[0]*e[0],t[1]=n[1]*e[1],t[2]=n[2]*e[2],t}function f(t,n,e){return t[0]=n[0]/e[0],t[1]=n[1]/e[1],t[2]=n[2]/e[2],t}function _(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t}function m(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t}function b(t,n,e){return t[0]=Math.min(n[0],e[0]),t[1]=Math.min(n[1],e[1]),t[2]=Math.min(n[2],e[2]),t}function g(t,n,e){return t[0]=Math.max(n[0],e[0]),t[1]=Math.max(n[1],e[1]),t[2]=Math.max(n[2],e[2]),t}function x(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t}function A(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t}function w(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t}function M(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2];return Math.sqrt(e*e+r*r+o*o)}function O(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2];return e*e+r*r+o*o}function y(t){var n=t[0],e=t[1],r=t[2];return n*n+e*e+r*r}function T(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t}function S(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t}function E(t,n){var e=n[0],r=n[1],o=n[2],i=e*e+r*r+o*o;return i>0&&(i=1/Math.sqrt(i),t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i),t}function D(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function R(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[0],s=e[1],c=e[2];return t[0]=o*c-i*s,t[1]=i*a-r*c,t[2]=r*s-o*a,t}function V(t,n,e,r){var o=n[0],i=n[1],a=n[2];return t[0]=o+r*(e[0]-o),t[1]=i+r*(e[1]-i),t[2]=a+r*(e[2]-a),t}function P(t,n,e,r,o,i){var a=i*i,s=a*(2*i-3)+1,c=a*(i-2)+i,l=a*(i-1),d=a*(3-2*i);return t[0]=n[0]*s+e[0]*c+r[0]*l+o[0]*d,t[1]=n[1]*s+e[1]*c+r[1]*l+o[1]*d,t[2]=n[2]*s+e[2]*c+r[2]*l+o[2]*d,t}function I(t,n,e,r,o,i){var a=1-i,s=a*a,c=i*i,l=s*a,d=3*i*s,h=3*c*a,u=c*i;return t[0]=n[0]*l+e[0]*d+r[0]*h+o[0]*u,t[1]=n[1]*l+e[1]*d+r[1]*h+o[1]*u,t[2]=n[2]*l+e[2]*d+r[2]*h+o[2]*u,t}function N(t,n){n=n||1;var e=2*o.RANDOM()*Math.PI,r=2*o.RANDOM()-1,i=Math.sqrt(1-r*r)*n;return t[0]=Math.cos(e)*i,t[1]=Math.sin(e)*i,t[2]=r*n,t}function C(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[3]*r+e[7]*o+e[11]*i+e[15];return a=a||1,t[0]=(e[0]*r+e[4]*o+e[8]*i+e[12])/a,t[1]=(e[1]*r+e[5]*o+e[9]*i+e[13])/a,t[2]=(e[2]*r+e[6]*o+e[10]*i+e[14])/a,t}function L(t,n,e){var r=n[0],o=n[1],i=n[2];return t[0]=r*e[0]+o*e[3]+i*e[6],t[1]=r*e[1]+o*e[4]+i*e[7],t[2]=r*e[2]+o*e[5]+i*e[8],t}function j(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[0],s=e[1],c=e[2],l=e[3],d=l*r+s*i-c*o,h=l*o+c*r-a*i,u=l*i+a*o-s*r,p=-a*r-s*o-c*i;return t[0]=d*l+p*-a+h*-c-u*-s,t[1]=h*l+p*-s+u*-a-d*-c,t[2]=u*l+p*-c+d*-s-h*-a,t}function B(t,n,e,r){var o=[],i=[];return o[0]=n[0]-e[0],o[1]=n[1]-e[1],o[2]=n[2]-e[2],i[0]=o[0],i[1]=o[1]*Math.cos(r)-o[2]*Math.sin(r),i[2]=o[1]*Math.sin(r)+o[2]*Math.cos(r),t[0]=i[0]+e[0],t[1]=i[1]+e[1],t[2]=i[2]+e[2],t}function F(t,n,e,r){var o=[],i=[];return o[0]=n[0]-e[0],o[1]=n[1]-e[1],o[2]=n[2]-e[2],i[0]=o[2]*Math.sin(r)+o[0]*Math.cos(r),i[1]=o[1],i[2]=o[2]*Math.cos(r)-o[0]*Math.sin(r),t[0]=i[0]+e[0],t[1]=i[1]+e[1],t[2]=i[2]+e[2],t}function k(t,n,e,r){var o=[],i=[];return o[0]=n[0]-e[0],o[1]=n[1]-e[1],o[2]=n[2]-e[2],i[0]=o[0]*Math.cos(r)-o[1]*Math.sin(r),i[1]=o[0]*Math.sin(r)+o[1]*Math.cos(r),i[2]=o[2],t[0]=i[0]+e[0],t[1]=i[1]+e[1],t[2]=i[2]+e[2],t}function U(t,n){var e=l(t[0],t[1],t[2]),r=l(n[0],n[1],n[2]);E(e,e),E(r,r);var o=D(e,r);return o>1?0:o<-1?Math.PI:Math.acos(o)}function W(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"}function H(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]}function G(t,n){var e=t[0],r=t[1],i=t[2],a=n[0],s=n[1],c=n[2];return Math.abs(e-a)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(a))&&Math.abs(r-s)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(i-c)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(c))}n.sub=p,n.mul=v,n.div=f,n.dist=M,n.sqrDist=O,n.len=c,n.sqrLen=y,n.forEach=function(){var t=a();return function(n,e,r,o,i,a){var s=void 0,c=void 0;for(e||(e=3),r||(r=0),c=o?Math.min(o*e+r,n.length):n.length,s=r;s<c;s+=e)t[0]=n[s],t[1]=n[s+1],t[2]=n[s+2],i(t,t,a),n[s]=t[0],n[s+1]=t[1],n[s+2]=t[2];return n}}()},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=a,n.clone=s,n.fromValues=c,n.copy=l,n.set=d,n.add=h,n.subtract=u,n.multiply=p,n.divide=v,n.ceil=f,n.floor=_,n.min=m,n.max=b,n.round=g,n.scale=x,n.scaleAndAdd=A,n.distance=w,n.squaredDistance=M,n.length=O,n.squaredLength=y,n.negate=T,n.inverse=S,n.normalize=E,n.dot=D,n.lerp=R,n.random=V,n.transformMat4=P,n.transformQuat=I,n.str=N,n.exactEquals=C,n.equals=L;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}function s(t){var n=new o.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function c(t,n,e,r){var i=new o.ARRAY_TYPE(4);return i[0]=t,i[1]=n,i[2]=e,i[3]=r,i}function l(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function d(t,n,e,r,o){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t}function h(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t}function u(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t}function p(t,n,e){return t[0]=n[0]*e[0],t[1]=n[1]*e[1],t[2]=n[2]*e[2],t[3]=n[3]*e[3],t}function v(t,n,e){return t[0]=n[0]/e[0],t[1]=n[1]/e[1],t[2]=n[2]/e[2],t[3]=n[3]/e[3],t}function f(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t}function _(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t}function m(t,n,e){return t[0]=Math.min(n[0],e[0]),t[1]=Math.min(n[1],e[1]),t[2]=Math.min(n[2],e[2]),t[3]=Math.min(n[3],e[3]),t}function b(t,n,e){return t[0]=Math.max(n[0],e[0]),t[1]=Math.max(n[1],e[1]),t[2]=Math.max(n[2],e[2]),t[3]=Math.max(n[3],e[3]),t}function g(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t}function x(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t}function A(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t}function w(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2],i=n[3]-t[3];return Math.sqrt(e*e+r*r+o*o+i*i)}function M(t,n){var e=n[0]-t[0],r=n[1]-t[1],o=n[2]-t[2],i=n[3]-t[3];return e*e+r*r+o*o+i*i}function O(t){var n=t[0],e=t[1],r=t[2],o=t[3];return Math.sqrt(n*n+e*e+r*r+o*o)}function y(t){var n=t[0],e=t[1],r=t[2],o=t[3];return n*n+e*e+r*r+o*o}function T(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t}function S(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t}function E(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e*e+r*r+o*o+i*i;return a>0&&(a=1/Math.sqrt(a),t[0]=e*a,t[1]=r*a,t[2]=o*a,t[3]=i*a),t}function D(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]}function R(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=n[3];return t[0]=o+r*(e[0]-o),t[1]=i+r*(e[1]-i),t[2]=a+r*(e[2]-a),t[3]=s+r*(e[3]-s),t}function V(t,n){return n=n||1,t[0]=o.RANDOM(),t[1]=o.RANDOM(),t[2]=o.RANDOM(),t[3]=o.RANDOM(),E(t,t),x(t,t,n),t}function P(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3];return t[0]=e[0]*r+e[4]*o+e[8]*i+e[12]*a,t[1]=e[1]*r+e[5]*o+e[9]*i+e[13]*a,t[2]=e[2]*r+e[6]*o+e[10]*i+e[14]*a,t[3]=e[3]*r+e[7]*o+e[11]*i+e[15]*a,t}function I(t,n,e){var r=n[0],o=n[1],i=n[2],a=e[0],s=e[1],c=e[2],l=e[3],d=l*r+s*i-c*o,h=l*o+c*r-a*i,u=l*i+a*o-s*r,p=-a*r-s*o-c*i;return t[0]=d*l+p*-a+h*-c-u*-s,t[1]=h*l+p*-s+u*-a-d*-c,t[2]=u*l+p*-c+d*-s-h*-a,t[3]=n[3],t}function N(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function C(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function L(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=n[0],c=n[1],l=n[2],d=n[3];return Math.abs(e-s)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(r-c)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(i-l)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(a-d)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(d))}n.sub=u,n.mul=p,n.div=v,n.dist=w,n.sqrDist=M,n.len=O,n.sqrLen=y,n.forEach=function(){var t=a();return function(n,e,r,o,i,a){var s=void 0,c=void 0;for(e||(e=4),r||(r=0),c=o?Math.min(o*e+r,n.length):n.length,s=r;s<c;s+=e)t[0]=n[s],t[1]=n[s+1],t[2]=n[s+2],t[3]=n[s+3],i(t,t,a),n[s]=t[0],n[s+1]=t[1],n[s+2]=t[2],n[s+3]=t[3];return n}}()},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.vec4=n.vec3=n.vec2=n.quat=n.mat4=n.mat3=n.mat2d=n.mat2=n.glMatrix=void 0;var r=e(0),o=A(r),i=e(5),a=A(i),s=e(6),c=A(s),l=e(1),d=A(l),h=e(7),u=A(h),p=e(8),v=A(p),f=e(9),_=A(f),m=e(2),b=A(m),g=e(3),x=A(g);function A(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}n.glMatrix=o,n.mat2=a,n.mat2d=c,n.mat3=d,n.mat4=u,n.quat=v,n.vec2=_,n.vec3=b,n.vec4=x},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.clone=s,n.copy=c,n.identity=l,n.fromValues=d,n.set=h,n.transpose=u,n.invert=p,n.adjoint=v,n.determinant=f,n.multiply=_,n.rotate=m,n.scale=b,n.fromRotation=g,n.fromScaling=x,n.str=A,n.frob=w,n.LDU=M,n.add=O,n.subtract=y,n.exactEquals=T,n.equals=S,n.multiplyScalar=E,n.multiplyScalarAndAdd=D;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function s(t){var n=new o.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function c(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function l(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function d(t,n,e,r){var i=new o.ARRAY_TYPE(4);return i[0]=t,i[1]=n,i[2]=e,i[3]=r,i}function h(t,n,e,r,o){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t}function u(t,n){if(t===n){var e=n[1];t[1]=n[2],t[2]=e}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t}function p(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e*i-o*r;return a?(a=1/a,t[0]=i*a,t[1]=-r*a,t[2]=-o*a,t[3]=e*a,t):null}function v(t,n){var e=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=e,t}function f(t){return t[0]*t[3]-t[2]*t[1]}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],c=e[1],l=e[2],d=e[3];return t[0]=r*s+i*c,t[1]=o*s+a*c,t[2]=r*l+i*d,t[3]=o*l+a*d,t}function m(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c+i*s,t[1]=o*c+a*s,t[2]=r*-s+i*c,t[3]=o*-s+a*c,t}function b(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],c=e[1];return t[0]=r*s,t[1]=o*s,t[2]=i*c,t[3]=a*c,t}function g(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=-e,t[3]=r,t}function x(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t}function A(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function w(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))}function M(t,n,e,r){return t[2]=r[2]/r[0],e[0]=r[0],e[1]=r[1],e[3]=r[3]-t[2]*e[1],[t,n,e]}function O(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t}function y(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t}function T(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function S(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=n[0],c=n[1],l=n[2],d=n[3];return Math.abs(e-s)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(r-c)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(i-l)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(a-d)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(d))}function E(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t}function D(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t}n.mul=_,n.sub=y},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.clone=s,n.copy=c,n.identity=l,n.fromValues=d,n.set=h,n.invert=u,n.determinant=p,n.multiply=v,n.rotate=f,n.scale=_,n.translate=m,n.fromRotation=b,n.fromScaling=g,n.fromTranslation=x,n.str=A,n.frob=w,n.add=M,n.subtract=O,n.multiplyScalar=y,n.multiplyScalarAndAdd=T,n.exactEquals=S,n.equals=E;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function s(t){var n=new o.ARRAY_TYPE(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n}function c(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t}function l(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function d(t,n,e,r,i,a){var s=new o.ARRAY_TYPE(6);return s[0]=t,s[1]=n,s[2]=e,s[3]=r,s[4]=i,s[5]=a,s}function h(t,n,e,r,o,i,a){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t[4]=i,t[5]=a,t}function u(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=e*i-r*o;return c?(c=1/c,t[0]=i*c,t[1]=-r*c,t[2]=-o*c,t[3]=e*c,t[4]=(o*s-i*a)*c,t[5]=(r*a-e*s)*c,t):null}function p(t){return t[0]*t[3]-t[1]*t[2]}function v(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=e[0],d=e[1],h=e[2],u=e[3],p=e[4],v=e[5];return t[0]=r*l+i*d,t[1]=o*l+a*d,t[2]=r*h+i*u,t[3]=o*h+a*u,t[4]=r*p+i*v+s,t[5]=o*p+a*v+c,t}function f(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=Math.sin(e),d=Math.cos(e);return t[0]=r*d+i*l,t[1]=o*d+a*l,t[2]=r*-l+i*d,t[3]=o*-l+a*d,t[4]=s,t[5]=c,t}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=e[0],d=e[1];return t[0]=r*l,t[1]=o*l,t[2]=i*d,t[3]=a*d,t[4]=s,t[5]=c,t}function m(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=e[0],d=e[1];return t[0]=r,t[1]=o,t[2]=i,t[3]=a,t[4]=r*l+i*d+s,t[5]=o*l+a*d+c,t}function b(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=-e,t[3]=r,t[4]=0,t[5]=0,t}function g(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t}function x(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t}function A(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"}function w(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)}function M(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t[4]=n[4]+e[4],t[5]=n[5]+e[5],t}function O(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t[4]=n[4]-e[4],t[5]=n[5]-e[5],t}function y(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t[4]=n[4]*e,t[5]=n[5]*e,t}function T(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t[4]=n[4]+e[4]*r,t[5]=n[5]+e[5]*r,t}function S(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]}function E(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=t[4],c=t[5],l=n[0],d=n[1],h=n[2],u=n[3],p=n[4],v=n[5];return Math.abs(e-l)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(l))&&Math.abs(r-d)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(d))&&Math.abs(i-h)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(h))&&Math.abs(a-u)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(u))&&Math.abs(s-p)<=o.EPSILON*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(c-v)<=o.EPSILON*Math.max(1,Math.abs(c),Math.abs(v))}n.mul=v,n.sub=O},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=a,n.clone=s,n.copy=c,n.fromValues=l,n.set=d,n.identity=h,n.transpose=u,n.invert=p,n.adjoint=v,n.determinant=f,n.multiply=_,n.translate=m,n.scale=b,n.rotate=g,n.rotateX=x,n.rotateY=A,n.rotateZ=w,n.fromTranslation=M,n.fromScaling=O,n.fromRotation=y,n.fromXRotation=T,n.fromYRotation=S,n.fromZRotation=E,n.fromRotationTranslation=D,n.getTranslation=R,n.getScaling=V,n.getRotation=P,n.fromRotationTranslationScale=I,n.fromRotationTranslationScaleOrigin=N,n.fromQuat=C,n.frustum=L,n.perspective=j,n.perspectiveFromFieldOfView=B,n.ortho=F,n.lookAt=k,n.targetTo=U,n.str=W,n.frob=H,n.add=G,n.subtract=Y,n.multiplyScalar=q,n.multiplyScalarAndAdd=z,n.exactEquals=X,n.equals=J;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function s(t){var n=new o.ARRAY_TYPE(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n}function c(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}function l(t,n,e,r,i,a,s,c,l,d,h,u,p,v,f,_){var m=new o.ARRAY_TYPE(16);return m[0]=t,m[1]=n,m[2]=e,m[3]=r,m[4]=i,m[5]=a,m[6]=s,m[7]=c,m[8]=l,m[9]=d,m[10]=h,m[11]=u,m[12]=p,m[13]=v,m[14]=f,m[15]=_,m}function d(t,n,e,r,o,i,a,s,c,l,d,h,u,p,v,f,_){return t[0]=n,t[1]=e,t[2]=r,t[3]=o,t[4]=i,t[5]=a,t[6]=s,t[7]=c,t[8]=l,t[9]=d,t[10]=h,t[11]=u,t[12]=p,t[13]=v,t[14]=f,t[15]=_,t}function h(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function u(t,n){if(t===n){var e=n[1],r=n[2],o=n[3],i=n[6],a=n[7],s=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=e,t[6]=n[9],t[7]=n[13],t[8]=r,t[9]=i,t[11]=n[14],t[12]=o,t[13]=a,t[14]=s}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t}function p(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],d=n[8],h=n[9],u=n[10],p=n[11],v=n[12],f=n[13],_=n[14],m=n[15],b=e*s-r*a,g=e*c-o*a,x=e*l-i*a,A=r*c-o*s,w=r*l-i*s,M=o*l-i*c,O=d*f-h*v,y=d*_-u*v,T=d*m-p*v,S=h*_-u*f,E=h*m-p*f,D=u*m-p*_,R=b*D-g*E+x*S+A*T-w*y+M*O;return R?(R=1/R,t[0]=(s*D-c*E+l*S)*R,t[1]=(o*E-r*D-i*S)*R,t[2]=(f*M-_*w+m*A)*R,t[3]=(u*w-h*M-p*A)*R,t[4]=(c*T-a*D-l*y)*R,t[5]=(e*D-o*T+i*y)*R,t[6]=(_*x-v*M-m*g)*R,t[7]=(d*M-u*x+p*g)*R,t[8]=(a*E-s*T+l*O)*R,t[9]=(r*T-e*E-i*O)*R,t[10]=(v*w-f*x+m*b)*R,t[11]=(h*x-d*w-p*b)*R,t[12]=(s*y-a*S-c*O)*R,t[13]=(e*S-r*y+o*O)*R,t[14]=(f*g-v*A-_*b)*R,t[15]=(d*A-h*g+u*b)*R,t):null}function v(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=n[4],s=n[5],c=n[6],l=n[7],d=n[8],h=n[9],u=n[10],p=n[11],v=n[12],f=n[13],_=n[14],m=n[15];return t[0]=s*(u*m-p*_)-h*(c*m-l*_)+f*(c*p-l*u),t[1]=-(r*(u*m-p*_)-h*(o*m-i*_)+f*(o*p-i*u)),t[2]=r*(c*m-l*_)-s*(o*m-i*_)+f*(o*l-i*c),t[3]=-(r*(c*p-l*u)-s*(o*p-i*u)+h*(o*l-i*c)),t[4]=-(a*(u*m-p*_)-d*(c*m-l*_)+v*(c*p-l*u)),t[5]=e*(u*m-p*_)-d*(o*m-i*_)+v*(o*p-i*u),t[6]=-(e*(c*m-l*_)-a*(o*m-i*_)+v*(o*l-i*c)),t[7]=e*(c*p-l*u)-a*(o*p-i*u)+d*(o*l-i*c),t[8]=a*(h*m-p*f)-d*(s*m-l*f)+v*(s*p-l*h),t[9]=-(e*(h*m-p*f)-d*(r*m-i*f)+v*(r*p-i*h)),t[10]=e*(s*m-l*f)-a*(r*m-i*f)+v*(r*l-i*s),t[11]=-(e*(s*p-l*h)-a*(r*p-i*h)+d*(r*l-i*s)),t[12]=-(a*(h*_-u*f)-d*(s*_-c*f)+v*(s*u-c*h)),t[13]=e*(h*_-u*f)-d*(r*_-o*f)+v*(r*u-o*h),t[14]=-(e*(s*_-c*f)-a*(r*_-o*f)+v*(r*c-o*s)),t[15]=e*(s*u-c*h)-a*(r*u-o*h)+d*(r*c-o*s),t}function f(t){var n=t[0],e=t[1],r=t[2],o=t[3],i=t[4],a=t[5],s=t[6],c=t[7],l=t[8],d=t[9],h=t[10],u=t[11],p=t[12],v=t[13],f=t[14],_=t[15],m=n*a-e*i,b=n*s-r*i,g=n*c-o*i,x=e*s-r*a,A=e*c-o*a,w=r*c-o*s,M=l*v-d*p,O=l*f-h*p,y=l*_-u*p,T=d*f-h*v,S=d*_-u*v,E=h*_-u*f;return m*E-b*S+g*T+x*y-A*O+w*M}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=n[4],c=n[5],l=n[6],d=n[7],h=n[8],u=n[9],p=n[10],v=n[11],f=n[12],_=n[13],m=n[14],b=n[15],g=e[0],x=e[1],A=e[2],w=e[3];return t[0]=g*r+x*s+A*h+w*f,t[1]=g*o+x*c+A*u+w*_,t[2]=g*i+x*l+A*p+w*m,t[3]=g*a+x*d+A*v+w*b,g=e[4],x=e[5],A=e[6],w=e[7],t[4]=g*r+x*s+A*h+w*f,t[5]=g*o+x*c+A*u+w*_,t[6]=g*i+x*l+A*p+w*m,t[7]=g*a+x*d+A*v+w*b,g=e[8],x=e[9],A=e[10],w=e[11],t[8]=g*r+x*s+A*h+w*f,t[9]=g*o+x*c+A*u+w*_,t[10]=g*i+x*l+A*p+w*m,t[11]=g*a+x*d+A*v+w*b,g=e[12],x=e[13],A=e[14],w=e[15],t[12]=g*r+x*s+A*h+w*f,t[13]=g*o+x*c+A*u+w*_,t[14]=g*i+x*l+A*p+w*m,t[15]=g*a+x*d+A*v+w*b,t}function m(t,n,e){var r=e[0],o=e[1],i=e[2],a=void 0,s=void 0,c=void 0,l=void 0,d=void 0,h=void 0,u=void 0,p=void 0,v=void 0,f=void 0,_=void 0,m=void 0;return n===t?(t[12]=n[0]*r+n[4]*o+n[8]*i+n[12],t[13]=n[1]*r+n[5]*o+n[9]*i+n[13],t[14]=n[2]*r+n[6]*o+n[10]*i+n[14],t[15]=n[3]*r+n[7]*o+n[11]*i+n[15]):(a=n[0],s=n[1],c=n[2],l=n[3],d=n[4],h=n[5],u=n[6],p=n[7],v=n[8],f=n[9],_=n[10],m=n[11],t[0]=a,t[1]=s,t[2]=c,t[3]=l,t[4]=d,t[5]=h,t[6]=u,t[7]=p,t[8]=v,t[9]=f,t[10]=_,t[11]=m,t[12]=a*r+d*o+v*i+n[12],t[13]=s*r+h*o+f*i+n[13],t[14]=c*r+u*o+_*i+n[14],t[15]=l*r+p*o+m*i+n[15]),t}function b(t,n,e){var r=e[0],o=e[1],i=e[2];return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*o,t[5]=n[5]*o,t[6]=n[6]*o,t[7]=n[7]*o,t[8]=n[8]*i,t[9]=n[9]*i,t[10]=n[10]*i,t[11]=n[11]*i,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}function g(t,n,e,r){var i=r[0],a=r[1],s=r[2],c=Math.sqrt(i*i+a*a+s*s),l=void 0,d=void 0,h=void 0,u=void 0,p=void 0,v=void 0,f=void 0,_=void 0,m=void 0,b=void 0,g=void 0,x=void 0,A=void 0,w=void 0,M=void 0,O=void 0,y=void 0,T=void 0,S=void 0,E=void 0,D=void 0,R=void 0,V=void 0,P=void 0;return Math.abs(c)<o.EPSILON?null:(c=1/c,i*=c,a*=c,s*=c,l=Math.sin(e),d=Math.cos(e),h=1-d,u=n[0],p=n[1],v=n[2],f=n[3],_=n[4],m=n[5],b=n[6],g=n[7],x=n[8],A=n[9],w=n[10],M=n[11],O=i*i*h+d,y=a*i*h+s*l,T=s*i*h-a*l,S=i*a*h-s*l,E=a*a*h+d,D=s*a*h+i*l,R=i*s*h+a*l,V=a*s*h-i*l,P=s*s*h+d,t[0]=u*O+_*y+x*T,t[1]=p*O+m*y+A*T,t[2]=v*O+b*y+w*T,t[3]=f*O+g*y+M*T,t[4]=u*S+_*E+x*D,t[5]=p*S+m*E+A*D,t[6]=v*S+b*E+w*D,t[7]=f*S+g*E+M*D,t[8]=u*R+_*V+x*P,t[9]=p*R+m*V+A*P,t[10]=v*R+b*V+w*P,t[11]=f*R+g*V+M*P,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t)}function x(t,n,e){var r=Math.sin(e),o=Math.cos(e),i=n[4],a=n[5],s=n[6],c=n[7],l=n[8],d=n[9],h=n[10],u=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=i*o+l*r,t[5]=a*o+d*r,t[6]=s*o+h*r,t[7]=c*o+u*r,t[8]=l*o-i*r,t[9]=d*o-a*r,t[10]=h*o-s*r,t[11]=u*o-c*r,t}function A(t,n,e){var r=Math.sin(e),o=Math.cos(e),i=n[0],a=n[1],s=n[2],c=n[3],l=n[8],d=n[9],h=n[10],u=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=i*o-l*r,t[1]=a*o-d*r,t[2]=s*o-h*r,t[3]=c*o-u*r,t[8]=i*r+l*o,t[9]=a*r+d*o,t[10]=s*r+h*o,t[11]=c*r+u*o,t}function w(t,n,e){var r=Math.sin(e),o=Math.cos(e),i=n[0],a=n[1],s=n[2],c=n[3],l=n[4],d=n[5],h=n[6],u=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=i*o+l*r,t[1]=a*o+d*r,t[2]=s*o+h*r,t[3]=c*o+u*r,t[4]=l*o-i*r,t[5]=d*o-a*r,t[6]=h*o-s*r,t[7]=u*o-c*r,t}function M(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function O(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function y(t,n,e){var r=e[0],i=e[1],a=e[2],s=Math.sqrt(r*r+i*i+a*a),c=void 0,l=void 0,d=void 0;return Math.abs(s)<o.EPSILON?null:(s=1/s,r*=s,i*=s,a*=s,c=Math.sin(n),l=Math.cos(n),d=1-l,t[0]=r*r*d+l,t[1]=i*r*d+a*c,t[2]=a*r*d-i*c,t[3]=0,t[4]=r*i*d-a*c,t[5]=i*i*d+l,t[6]=a*i*d+r*c,t[7]=0,t[8]=r*a*d+i*c,t[9]=i*a*d-r*c,t[10]=a*a*d+l,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function T(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=e,t[7]=0,t[8]=0,t[9]=-e,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function S(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=0,t[2]=-e,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=e,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function E(t,n){var e=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=e,t[2]=0,t[3]=0,t[4]=-e,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function D(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=r+r,c=o+o,l=i+i,d=r*s,h=r*c,u=r*l,p=o*c,v=o*l,f=i*l,_=a*s,m=a*c,b=a*l;return t[0]=1-(p+f),t[1]=h+b,t[2]=u-m,t[3]=0,t[4]=h-b,t[5]=1-(d+f),t[6]=v+_,t[7]=0,t[8]=u+m,t[9]=v-_,t[10]=1-(d+p),t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function R(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function V(t,n){var e=n[0],r=n[1],o=n[2],i=n[4],a=n[5],s=n[6],c=n[8],l=n[9],d=n[10];return t[0]=Math.sqrt(e*e+r*r+o*o),t[1]=Math.sqrt(i*i+a*a+s*s),t[2]=Math.sqrt(c*c+l*l+d*d),t}function P(t,n){var e=n[0]+n[5]+n[10],r=0;return e>0?(r=2*Math.sqrt(e+1),t[3]=.25*r,t[0]=(n[6]-n[9])/r,t[1]=(n[8]-n[2])/r,t[2]=(n[1]-n[4])/r):n[0]>n[5]&n[0]>n[10]?(r=2*Math.sqrt(1+n[0]-n[5]-n[10]),t[3]=(n[6]-n[9])/r,t[0]=.25*r,t[1]=(n[1]+n[4])/r,t[2]=(n[8]+n[2])/r):n[5]>n[10]?(r=2*Math.sqrt(1+n[5]-n[0]-n[10]),t[3]=(n[8]-n[2])/r,t[0]=(n[1]+n[4])/r,t[1]=.25*r,t[2]=(n[6]+n[9])/r):(r=2*Math.sqrt(1+n[10]-n[0]-n[5]),t[3]=(n[1]-n[4])/r,t[0]=(n[8]+n[2])/r,t[1]=(n[6]+n[9])/r,t[2]=.25*r),t}function I(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=n[3],c=o+o,l=i+i,d=a+a,h=o*c,u=o*l,p=o*d,v=i*l,f=i*d,_=a*d,m=s*c,b=s*l,g=s*d,x=r[0],A=r[1],w=r[2];return t[0]=(1-(v+_))*x,t[1]=(u+g)*x,t[2]=(p-b)*x,t[3]=0,t[4]=(u-g)*A,t[5]=(1-(h+_))*A,t[6]=(f+m)*A,t[7]=0,t[8]=(p+b)*w,t[9]=(f-m)*w,t[10]=(1-(h+v))*w,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function N(t,n,e,r,o){var i=n[0],a=n[1],s=n[2],c=n[3],l=i+i,d=a+a,h=s+s,u=i*l,p=i*d,v=i*h,f=a*d,_=a*h,m=s*h,b=c*l,g=c*d,x=c*h,A=r[0],w=r[1],M=r[2],O=o[0],y=o[1],T=o[2];return t[0]=(1-(f+m))*A,t[1]=(p+x)*A,t[2]=(v-g)*A,t[3]=0,t[4]=(p-x)*w,t[5]=(1-(u+m))*w,t[6]=(_+b)*w,t[7]=0,t[8]=(v+g)*M,t[9]=(_-b)*M,t[10]=(1-(u+f))*M,t[11]=0,t[12]=e[0]+O-(t[0]*O+t[4]*y+t[8]*T),t[13]=e[1]+y-(t[1]*O+t[5]*y+t[9]*T),t[14]=e[2]+T-(t[2]*O+t[6]*y+t[10]*T),t[15]=1,t}function C(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e+e,s=r+r,c=o+o,l=e*a,d=r*a,h=r*s,u=o*a,p=o*s,v=o*c,f=i*a,_=i*s,m=i*c;return t[0]=1-h-v,t[1]=d+m,t[2]=u-_,t[3]=0,t[4]=d-m,t[5]=1-l-v,t[6]=p+f,t[7]=0,t[8]=u+_,t[9]=p-f,t[10]=1-l-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function L(t,n,e,r,o,i,a){var s=1/(e-n),c=1/(o-r),l=1/(i-a);return t[0]=2*i*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*i*c,t[6]=0,t[7]=0,t[8]=(e+n)*s,t[9]=(o+r)*c,t[10]=(a+i)*l,t[11]=-1,t[12]=0,t[13]=0,t[14]=a*i*2*l,t[15]=0,t}function j(t,n,e,r,o){var i=1/Math.tan(n/2),a=1/(r-o);return t[0]=i/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(o+r)*a,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*o*r*a,t[15]=0,t}function B(t,n,e,r){var o=Math.tan(n.upDegrees*Math.PI/180),i=Math.tan(n.downDegrees*Math.PI/180),a=Math.tan(n.leftDegrees*Math.PI/180),s=Math.tan(n.rightDegrees*Math.PI/180),c=2/(a+s),l=2/(o+i);return t[0]=c,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=l,t[6]=0,t[7]=0,t[8]=-(a-s)*c*.5,t[9]=(o-i)*l*.5,t[10]=r/(e-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*e/(e-r),t[15]=0,t}function F(t,n,e,r,o,i,a){var s=1/(n-e),c=1/(r-o),l=1/(i-a);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*l,t[11]=0,t[12]=(n+e)*s,t[13]=(o+r)*c,t[14]=(a+i)*l,t[15]=1,t}function k(t,n,e,r){var i=void 0,a=void 0,s=void 0,c=void 0,l=void 0,d=void 0,h=void 0,u=void 0,p=void 0,v=void 0,f=n[0],_=n[1],m=n[2],b=r[0],g=r[1],x=r[2],A=e[0],w=e[1],M=e[2];return Math.abs(f-A)<o.EPSILON&&Math.abs(_-w)<o.EPSILON&&Math.abs(m-M)<o.EPSILON?mat4.identity(t):(h=f-A,u=_-w,p=m-M,v=1/Math.sqrt(h*h+u*u+p*p),h*=v,u*=v,p*=v,i=g*p-x*u,a=x*h-b*p,s=b*u-g*h,v=Math.sqrt(i*i+a*a+s*s),v?(v=1/v,i*=v,a*=v,s*=v):(i=0,a=0,s=0),c=u*s-p*a,l=p*i-h*s,d=h*a-u*i,v=Math.sqrt(c*c+l*l+d*d),v?(v=1/v,c*=v,l*=v,d*=v):(c=0,l=0,d=0),t[0]=i,t[1]=c,t[2]=h,t[3]=0,t[4]=a,t[5]=l,t[6]=u,t[7]=0,t[8]=s,t[9]=d,t[10]=p,t[11]=0,t[12]=-(i*f+a*_+s*m),t[13]=-(c*f+l*_+d*m),t[14]=-(h*f+u*_+p*m),t[15]=1,t)}function U(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=r[0],c=r[1],l=r[2],d=o-e[0],h=i-e[1],u=a-e[2],p=d*d+h*h+u*u;p>0&&(p=1/Math.sqrt(p),d*=p,h*=p,u*=p);var v=c*u-l*h,f=l*d-s*u,_=s*h-c*d;return t[0]=v,t[1]=f,t[2]=_,t[3]=0,t[4]=h*_-u*f,t[5]=u*v-d*_,t[6]=d*f-h*v,t[7]=0,t[8]=d,t[9]=h,t[10]=u,t[11]=0,t[12]=o,t[13]=i,t[14]=a,t[15]=1,t}function W(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"}function H(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))}function G(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t[3]=n[3]+e[3],t[4]=n[4]+e[4],t[5]=n[5]+e[5],t[6]=n[6]+e[6],t[7]=n[7]+e[7],t[8]=n[8]+e[8],t[9]=n[9]+e[9],t[10]=n[10]+e[10],t[11]=n[11]+e[11],t[12]=n[12]+e[12],t[13]=n[13]+e[13],t[14]=n[14]+e[14],t[15]=n[15]+e[15],t}function Y(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t[3]=n[3]-e[3],t[4]=n[4]-e[4],t[5]=n[5]-e[5],t[6]=n[6]-e[6],t[7]=n[7]-e[7],t[8]=n[8]-e[8],t[9]=n[9]-e[9],t[10]=n[10]-e[10],t[11]=n[11]-e[11],t[12]=n[12]-e[12],t[13]=n[13]-e[13],t[14]=n[14]-e[14],t[15]=n[15]-e[15],t}function q(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*e,t[9]=n[9]*e,t[10]=n[10]*e,t[11]=n[11]*e,t[12]=n[12]*e,t[13]=n[13]*e,t[14]=n[14]*e,t[15]=n[15]*e,t}function z(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t[2]=n[2]+e[2]*r,t[3]=n[3]+e[3]*r,t[4]=n[4]+e[4]*r,t[5]=n[5]+e[5]*r,t[6]=n[6]+e[6]*r,t[7]=n[7]+e[7]*r,t[8]=n[8]+e[8]*r,t[9]=n[9]+e[9]*r,t[10]=n[10]+e[10]*r,t[11]=n[11]+e[11]*r,t[12]=n[12]+e[12]*r,t[13]=n[13]+e[13]*r,t[14]=n[14]+e[14]*r,t[15]=n[15]+e[15]*r,t}function X(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]}function J(t,n){var e=t[0],r=t[1],i=t[2],a=t[3],s=t[4],c=t[5],l=t[6],d=t[7],h=t[8],u=t[9],p=t[10],v=t[11],f=t[12],_=t[13],m=t[14],b=t[15],g=n[0],x=n[1],A=n[2],w=n[3],M=n[4],O=n[5],y=n[6],T=n[7],S=n[8],E=n[9],D=n[10],R=n[11],V=n[12],P=n[13],I=n[14],N=n[15];return Math.abs(e-g)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(g))&&Math.abs(r-x)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(x))&&Math.abs(i-A)<=o.EPSILON*Math.max(1,Math.abs(i),Math.abs(A))&&Math.abs(a-w)<=o.EPSILON*Math.max(1,Math.abs(a),Math.abs(w))&&Math.abs(s-M)<=o.EPSILON*Math.max(1,Math.abs(s),Math.abs(M))&&Math.abs(c-O)<=o.EPSILON*Math.max(1,Math.abs(c),Math.abs(O))&&Math.abs(l-y)<=o.EPSILON*Math.max(1,Math.abs(l),Math.abs(y))&&Math.abs(d-T)<=o.EPSILON*Math.max(1,Math.abs(d),Math.abs(T))&&Math.abs(h-S)<=o.EPSILON*Math.max(1,Math.abs(h),Math.abs(S))&&Math.abs(u-E)<=o.EPSILON*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(p-D)<=o.EPSILON*Math.max(1,Math.abs(p),Math.abs(D))&&Math.abs(v-R)<=o.EPSILON*Math.max(1,Math.abs(v),Math.abs(R))&&Math.abs(f-V)<=o.EPSILON*Math.max(1,Math.abs(f),Math.abs(V))&&Math.abs(_-P)<=o.EPSILON*Math.max(1,Math.abs(_),Math.abs(P))&&Math.abs(m-I)<=o.EPSILON*Math.max(1,Math.abs(m),Math.abs(I))&&Math.abs(b-N)<=o.EPSILON*Math.max(1,Math.abs(b),Math.abs(N))}n.mul=_,n.sub=Y},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setAxes=n.sqlerp=n.rotationTo=n.equals=n.exactEquals=n.normalize=n.sqrLen=n.squaredLength=n.len=n.length=n.lerp=n.dot=n.scale=n.mul=n.add=n.set=n.copy=n.fromValues=n.clone=void 0,n.create=u,n.identity=p,n.setAxisAngle=v,n.getAxisAngle=f,n.multiply=_,n.rotateX=m,n.rotateY=b,n.rotateZ=g,n.calculateW=x,n.slerp=A,n.invert=w,n.conjugate=M,n.fromMat3=O,n.fromEuler=y,n.str=T;var r=e(0),o=h(r),i=e(1),a=h(i),s=e(2),c=h(s),l=e(3),d=h(l);function h(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function u(){var t=new o.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function p(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function v(t,n,e){e*=.5;var r=Math.sin(e);return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=Math.cos(e),t}function f(t,n){var e=2*Math.acos(n[3]),r=Math.sin(e/2);return 0!=r?(t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r):(t[0]=1,t[1]=0,t[2]=0),e}function _(t,n,e){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],c=e[1],l=e[2],d=e[3];return t[0]=r*d+a*s+o*l-i*c,t[1]=o*d+a*c+i*s-r*l,t[2]=i*d+a*l+r*c-o*s,t[3]=a*d-r*s-o*c-i*l,t}function m(t,n,e){e*=.5;var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c+a*s,t[1]=o*c+i*s,t[2]=i*c-o*s,t[3]=a*c-r*s,t}function b(t,n,e){e*=.5;var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c-i*s,t[1]=o*c+a*s,t[2]=i*c+r*s,t[3]=a*c-o*s,t}function g(t,n,e){e*=.5;var r=n[0],o=n[1],i=n[2],a=n[3],s=Math.sin(e),c=Math.cos(e);return t[0]=r*c+o*s,t[1]=o*c-r*s,t[2]=i*c+a*s,t[3]=a*c-i*s,t}function x(t,n){var e=n[0],r=n[1],o=n[2];return t[0]=e,t[1]=r,t[2]=o,t[3]=Math.sqrt(Math.abs(1-e*e-r*r-o*o)),t}function A(t,n,e,r){var o=n[0],i=n[1],a=n[2],s=n[3],c=e[0],l=e[1],d=e[2],h=e[3],u=void 0,p=void 0,v=void 0,f=void 0,_=void 0;return p=o*c+i*l+a*d+s*h,p<0&&(p=-p,c=-c,l=-l,d=-d,h=-h),1-p>1e-6?(u=Math.acos(p),v=Math.sin(u),f=Math.sin((1-r)*u)/v,_=Math.sin(r*u)/v):(f=1-r,_=r),t[0]=f*o+_*c,t[1]=f*i+_*l,t[2]=f*a+_*d,t[3]=f*s+_*h,t}function w(t,n){var e=n[0],r=n[1],o=n[2],i=n[3],a=e*e+r*r+o*o+i*i,s=a?1/a:0;return t[0]=-e*s,t[1]=-r*s,t[2]=-o*s,t[3]=i*s,t}function M(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t}function O(t,n){var e=n[0]+n[4]+n[8],r=void 0;if(e>0)r=Math.sqrt(e+1),t[3]=.5*r,r=.5/r,t[0]=(n[5]-n[7])*r,t[1]=(n[6]-n[2])*r,t[2]=(n[1]-n[3])*r;else{var o=0;n[4]>n[0]&&(o=1),n[8]>n[3*o+o]&&(o=2);var i=(o+1)%3,a=(o+2)%3;r=Math.sqrt(n[3*o+o]-n[3*i+i]-n[3*a+a]+1),t[o]=.5*r,r=.5/r,t[3]=(n[3*i+a]-n[3*a+i])*r,t[i]=(n[3*i+o]+n[3*o+i])*r,t[a]=(n[3*a+o]+n[3*o+a])*r}return t}function y(t,n,e,r){var o=.5*Math.PI/180;n*=o,e*=o,r*=o;var i=Math.sin(n),a=Math.cos(n),s=Math.sin(e),c=Math.cos(e),l=Math.sin(r),d=Math.cos(r);return t[0]=i*c*d-a*s*l,t[1]=a*s*d+i*c*l,t[2]=a*c*l-i*s*d,t[3]=a*c*d+i*s*l,t}function T(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}n.clone=d.clone,n.fromValues=d.fromValues,n.copy=d.copy,n.set=d.set,n.add=d.add,n.mul=_,n.scale=d.scale,n.dot=d.dot,n.lerp=d.lerp;var S=n.length=d.length,E=(n.len=S,n.squaredLength=d.squaredLength),D=(n.sqrLen=E,n.normalize=d.normalize);n.exactEquals=d.exactEquals,n.equals=d.equals,n.rotationTo=function(){var t=c.create(),n=c.fromValues(1,0,0),e=c.fromValues(0,1,0);return function(r,o,i){var a=c.dot(o,i);return a<-.999999?(c.cross(t,n,o),c.len(t)<1e-6&&c.cross(t,e,o),c.normalize(t,t),v(r,t,Math.PI),r):a>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(c.cross(t,o,i),r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=1+a,D(r,r))}}(),n.sqlerp=function(){var t=u(),n=u();return function(e,r,o,i,a,s){return A(t,r,a,s),A(n,o,i,s),A(e,t,n,2*s*(1-s)),e}}(),n.setAxes=function(){var t=a.create();return function(n,e,r,o){return t[0]=r[0],t[3]=r[1],t[6]=r[2],t[1]=o[0],t[4]=o[1],t[7]=o[2],t[2]=-e[0],t[5]=-e[1],t[8]=-e[2],D(n,O(n,t))}}()},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.sqrDist=n.dist=n.div=n.mul=n.sub=n.len=void 0,n.create=a,n.clone=s,n.fromValues=c,n.copy=l,n.set=d,n.add=h,n.subtract=u,n.multiply=p,n.divide=v,n.ceil=f,n.floor=_,n.min=m,n.max=b,n.round=g,n.scale=x,n.scaleAndAdd=A,n.distance=w,n.squaredDistance=M,n.length=O,n.squaredLength=y,n.negate=T,n.inverse=S,n.normalize=E,n.dot=D,n.cross=R,n.lerp=V,n.random=P,n.transformMat2=I,n.transformMat2d=N,n.transformMat3=C,n.transformMat4=L,n.str=j,n.exactEquals=B,n.equals=F;var r=e(0),o=i(r);function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function a(){var t=new o.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t}function s(t){var n=new o.ARRAY_TYPE(2);return n[0]=t[0],n[1]=t[1],n}function c(t,n){var e=new o.ARRAY_TYPE(2);return e[0]=t,e[1]=n,e}function l(t,n){return t[0]=n[0],t[1]=n[1],t}function d(t,n,e){return t[0]=n,t[1]=e,t}function h(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t}function u(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t}function p(t,n,e){return t[0]=n[0]*e[0],t[1]=n[1]*e[1],t}function v(t,n,e){return t[0]=n[0]/e[0],t[1]=n[1]/e[1],t}function f(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t}function _(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t}function m(t,n,e){return t[0]=Math.min(n[0],e[0]),t[1]=Math.min(n[1],e[1]),t}function b(t,n,e){return t[0]=Math.max(n[0],e[0]),t[1]=Math.max(n[1],e[1]),t}function g(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t}function x(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t}function A(t,n,e,r){return t[0]=n[0]+e[0]*r,t[1]=n[1]+e[1]*r,t}function w(t,n){var e=n[0]-t[0],r=n[1]-t[1];return Math.sqrt(e*e+r*r)}function M(t,n){var e=n[0]-t[0],r=n[1]-t[1];return e*e+r*r}function O(t){var n=t[0],e=t[1];return Math.sqrt(n*n+e*e)}function y(t){var n=t[0],e=t[1];return n*n+e*e}function T(t,n){return t[0]=-n[0],t[1]=-n[1],t}function S(t,n){return t[0]=1/n[0],t[1]=1/n[1],t}function E(t,n){var e=n[0],r=n[1],o=e*e+r*r;return o>0&&(o=1/Math.sqrt(o),t[0]=n[0]*o,t[1]=n[1]*o),t}function D(t,n){return t[0]*n[0]+t[1]*n[1]}function R(t,n,e){var r=n[0]*e[1]-n[1]*e[0];return t[0]=t[1]=0,t[2]=r,t}function V(t,n,e,r){var o=n[0],i=n[1];return t[0]=o+r*(e[0]-o),t[1]=i+r*(e[1]-i),t}function P(t,n){n=n||1;var e=2*o.RANDOM()*Math.PI;return t[0]=Math.cos(e)*n,t[1]=Math.sin(e)*n,t}function I(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[2]*o,t[1]=e[1]*r+e[3]*o,t}function N(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[2]*o+e[4],t[1]=e[1]*r+e[3]*o+e[5],t}function C(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[3]*o+e[6],t[1]=e[1]*r+e[4]*o+e[7],t}function L(t,n,e){var r=n[0],o=n[1];return t[0]=e[0]*r+e[4]*o+e[12],t[1]=e[1]*r+e[5]*o+e[13],t}function j(t){return"vec2("+t[0]+", "+t[1]+")"}function B(t,n){return t[0]===n[0]&&t[1]===n[1]}function F(t,n){var e=t[0],r=t[1],i=n[0],a=n[1];return Math.abs(e-i)<=o.EPSILON*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(r-a)<=o.EPSILON*Math.max(1,Math.abs(r),Math.abs(a))}n.len=O,n.sub=u,n.mul=p,n.div=v,n.dist=w,n.sqrDist=M,n.sqrLen=y,n.forEach=function(){var t=a();return function(n,e,r,o,i,a){var s=void 0,c=void 0;for(e||(e=2),r||(r=0),c=o?Math.min(o*e+r,n.length):n.length,s=r;s<c;s+=e)t[0]=n[s],t[1]=n[s+1],i(t,t,a),n[s]=t[0],n[s+1]=t[1];return n}}()}])}))},cdd0:function(t,n,e){},ce21:function(t){t.exports=JSON.parse("{}")},cff6:function(t,n,e){t.exports=e.p+"static/img/coord2.d710514a.png"},d733:function(t,n,e){"use strict";e("3d36")},d960:function(t,n,e){},ddfb:function(t,n,e){},de67:function(t,n,e){t.exports=e.p+"static/img/matrix2.c2c586e0.png"},e277:function(t,n,e){"use strict";e("1be7")},e891:function(t,n,e){"use strict";e("9c9c")},f992:function(t,n,e){}});
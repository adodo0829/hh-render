(function(t){function e(e){for(var r,a,s=e[0],c=e[1],h=e[2],d=0,l=[];d<s.length;d++)a=s[d],Object.prototype.hasOwnProperty.call(i,a)&&i[a]&&l.push(i[a][0]),i[a]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(t[r]=c[r]);u&&u(e);while(l.length)l.shift()();return o.push.apply(o,h||[]),n()}function n(){for(var t,e=0;e<o.length;e++){for(var n=o[e],r=!0,s=1;s<n.length;s++){var c=n[s];0!==i[c]&&(r=!1)}r&&(o.splice(e--,1),t=a(a.s=n[0]))}return t}var r={},i={app:0},o=[];function a(e){if(r[e])return r[e].exports;var n=r[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,a),n.l=!0,n.exports}a.m=t,a.c=r,a.d=function(t,e,n){a.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},a.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},a.t=function(t,e){if(1&e&&(t=a(t)),8&e)return t;if(4&e&&"object"===typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(a.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)a.d(n,r,function(e){return t[e]}.bind(null,r));return n},a.n=function(t){var e=t&&t.__esModule?function(){return t["default"]}:function(){return t};return a.d(e,"a",e),e},a.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},a.p="/hh-render/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=e,s=s.slice();for(var h=0;h<s.length;h++)e(s[h]);var u=c;o.push([0,"chunk-vendors"]),n()})({0:function(t,e,n){t.exports=n("56d7")},"0721":function(t,e,n){},"0b6d":function(t,e,n){t.exports=n.p+"static/img/matrix1.bb4340c6.png"},"0f9f":function(t,e,n){"use strict";n("859d")},"11d9":function(t,e,n){t.exports=n.p+"static/img/3.5c73f25e.jpg"},"1aa6":function(t,e,n){t.exports=n.p+"static/img/matrix.57e09dd0.png"},3260:function(t,e,n){t.exports=n.p+"static/img/vector1.73452b9b.png"},"34a5":function(t,e,n){t.exports=n.p+"static/img/coord1.5b2ba5f4.png"},"3d36":function(t,e,n){},"405a":function(t,e,n){t.exports=n.p+"static/img/2.5debf06e.jpg"},"43a8":function(t,e,n){"use strict";n("5f8a")},"56d7":function(t,e,n){"use strict";n.r(e);var r=n("2b0e"),i=function(){var t=this,e=t._self._c;return e("div",{attrs:{id:"app"}},[e("section",{attrs:{id:"nav"}},t._l(t.routeList,(function(n){return e("router-link",{key:n.path,attrs:{to:n.path}},[t._v(t._s(n.name))])})),1),e("section",{attrs:{id:"content"}},[e("router-view")],1)])},o=[],a=(n("0643"),n("2382"),{name:"App",components:{},data(){return{routeList:[]}},mounted(){this.init()},methods:{init(){const{options:t}=this.$router;let e=t.routes.filter(t=>"/"!==t.path);this.routeList=e}}}),s=a,c=(n("a396"),n("2877")),h=Object(c["a"])(s,i,o,!1,null,null,null),u=h.exports,d=n("8c4f"),l=function(){var t=this;t._self._c;return t._m(0)},v=[function(){var t=this,e=t._self._c;return e("div",{staticClass:"home"},[e("p",[t._v("GLSL ES 3.00")]),t._v(" 游戏引擎 https://github.com/ThisisGame/cpp-game-engine-book "),e("pre",[e("h3",[t._v("基本结构")]),t._v("\n预处理器指令：\n#version 300 es：指定着色器语言的版本。\n变量类型：\n\n基本数据类型：float, int, bool, vec2, vec3, vec4, mat2, mat3, mat4, sampler2D 等。\n限定词：in, out, inout（仅在函数参数中使用）。\n主函数：\n\nvoid main()：着色器程序的入口点。\n\n"),e("h3",[t._v("输入和输出")]),t._v("\nin：用于顶点着色器的输入和片段着色器的输出。\nout：用于顶点着色器的输出和片段着色器的输入。\n\n"),e("h3",[t._v("Uniforms")]),t._v("\nUniform变量：\n用于在应用程序和着色器之间传递数据。\n声明方式：uniform type name;\n\nuniform 用来修饰统一变量。\nGPU是并行的，Shader是执行在GPU上的程序。\n当我们需要绘制3个顶点，GPU将3个顶点数据，分摊到3个GPU逻辑单元并行处理，每个逻辑单元处理的不同的顶点坐标数据，称之为属性变量。\n每个逻辑单元也会需要一些相同的数据，这些相同的数据，称之为统一变量。\nuniform mat4 u_mvp;\n\n"),e("p",[t._v("es2.0语法")]),t._v("\nattribute 表示这个变量，每执行一次Shader，都需要被赋值\nattribute vec3 a_pos;\nattribute vec4 a_color;\n输出变量由varying关键字修饰，用于从顶点着色器，传递数据到片段着色器\nvarying vec4 v_color;\n\n"),e("h3",[t._v("布局限定词")]),t._v("\n位置：\nlayout(location = N)：指定变量在属性数组中的位置。\n接口块：\n使用in和out关键字定义块，用于组织和传递复杂的数据结构。\n\n"),e("h3",[t._v("构造函数")]),t._v("\n支持多种构造函数，例如：vec4(float x, float y, float z, float w)。\n\n"),e("h3",[t._v("控制流")]),t._v("\n条件语句：if, else。\n循环语句：for, while。\n\n"),e("h3",[t._v("函数")]),t._v("\n支持用户定义函数。\n内置函数：如sin, cos, pow等。\n\n"),e("h3",[t._v("精度限定词")]),t._v("\n精度限定词：\nhighp, mediump, lowp：指定变量或uniform的精度。\n\n"),e("h3",[t._v("纹理采样和处理")]),t._v("\n纹理函数：\ntexture, texture2D, textureCube等。\n\n"),e("h3",[t._v("构造几何形状")]),t._v("\n几何着色器：\n可以定义几何着色器来处理几何图形的顶点。\n\n"),e("h3",[t._v("变换反馈：")]),t._v("\n允许着色器将数据直接输出到缓冲区。\n    ")]),e("div",[t._v("内置函数")]),e("pre",[t._v("\nGLSL ES 3.00支持的内置函数非常丰富，涵盖了数学运算、几何函数、矩阵操作、纹理查询等多个方面。\n以下是一些主要的内置函数类别及其部分代表函数：\n\n### 1. 角度和三角函数\n- `radians(d)`：将角度转换为弧度。\n- `degrees(r)`：将弧度转换为角度。\n- `sin(x)`：正弦函数。\n- `cos(x)`：余弦函数。\n- `tan(x)`：正切函数。\n- `asin(x)`：反正弦函数。\n- `acos(x)`：反余弦函数。\n- `atan(x)`：反正切函数。\n- `atan(x, y)`：双参数反正切函数。\n\n### 2. 指数函数\n- `pow(x, y)`：幂函数。\n- `exp(x)`：指数函数。\n- `log(x)`：自然对数。\n- `exp2(x)`：以2为底的指数函数。\n- `log2(x)`：以2为底的对数。\n\n### 3. 通用函数\n- `abs(x)`：绝对值。\n- `sign(x)`：符号函数。\n- `floor(x)`：向下取整。\n- `ceil(x)`：向上取整。\n- `fract(x)`：取小数部分。\n- `mod(x, y)`：取模。\n- `min(x, y)`：最小值。\n- `max(x, y)`：最大值。\n- `clamp(x, minVal, maxVal)`：将x限制在[minVal, maxVal]之间。\n- `mix(x, y, a)`：线性插值。\n- `step(edge, x)`：阶梯函数。\n- `smoothstep(edge0, edge1, x)`：平滑阶梯函数。\n\n### 4. 浮点数打包和解包函数\n- `packHalf2x16(v)`：将两个16位半精度浮点数打包成一个32位无符号整数。\n- `unpackHalf2x16(v)`：将一个32位无符号整数解包成两个16位半精度浮点数。\n\n### 5. 几何函数\n- `length(v)`：向量v的长度。\n- `distance(p0, p1)`：两点之间的距离。\n- `dot(x, y)`：向量x和y的点积。\n- `cross(x, y)`：向量x和y的叉积。\n- `normalize(v)`：向量v的单位向量。\n- `faceforward(N, I, Nref)`：根据法线N和参考向量Nref调整向量I的方向。\n- `reflect(I, N)`：向量I关于法线N的反射。\n- `refract(I, N, eta)`：向量I在法线N上的折射，其中eta是折射率。\n\n### 6. 矩阵函数\n- 矩阵的构造函数，如`mat2`, `mat3`, `mat4`。\n- `matrixCompMult(x, y)`：矩阵逐元素乘法。\n- `outerProduct(a, b)`：计算两个向量的外积。\n- `transpose(m)`：矩阵转置。\n- `inverse(m)`：矩阵求逆。\n\n### 7. 向量关系函数\n- `lessThan(x, y)`：逐元素比较x和y是否小于。\n- `greaterThan(x, y)`：逐元素比较x和y是否大于。\n- `equal(x, y)`：逐元素比较x和y是否相等。\n- `notEqual(x, y)`：逐元素比较x和y是否不相等。\n\n### 8. 纹理查询函数\n- `texture(sampler, P)`：从纹理采样器sampler中获取纹理坐标P处的颜色。\n- `textureLod(sampler, P, lod)`：从纹理采样器sampler中获取指定层次lod处的纹理坐标P处的颜色。\n- `textureProj(sampler, P)`：进行投影纹理采样。\n- `textureGrad(sampler, P, dPdx, dPdy)`：使用显式梯度进行纹理采样。\n    ")]),e("h3",[t._v("顶点着色器")]),e("p",[e("pre",[t._v("void main()\n{\n    gl_Position = vec4(vPos, 1.0);\n}\n\t\t")]),t._v(" 每个Shader都有入口函数 main()，顶点Shader主要工作就是：计算坐标。 得到坐标计算结果后，传给内置变量 gl_Position。 ")]),e("p",[t._v("在线测试 https://thebookofshaders.com/edit.php")]),e("pre",[t._v("  export const vertexString = `\n    #version 300 es\n    // 指定currVertexAndRatio变量在顶点属性数组中的位置是1\n\tlayout(location=1) in vec4 currVertexAndRatio;\t\t\t// 顶点坐标和变形系数\n\tlayout(location=2) in vec4 prevVertexAndRatio;\n\tlayout(location=3) in vec4 nextVertexAndRatio;\n\tlayout(location=4) in vec4 uvAndEdgeOffsetRatio;\t\t// UV\n\tlayout(location=5) in vec4 vertexAndEdgeOffsetValueAndNotFollowViewport;\t// 顶点形变  边形变值  是否不跟随视口\n\tlayout(location=6) in vec4 UVRect;\t\t\t\t\t\t// UVRect\n\tlayout(location=7) in vec4 backgroundColor;\t\t\t\t// 背景色\n\tlayout(location=8) in vec4 translationAndRotation;\t\t// 形变\n\tlayout(location=9) in vec4 isTextAndBorderWidthAndDashedAndScale;\t\t// 是否渲染文字 以及 文字边框粗细 以及物体边框虚线 缩放\n\tlayout(location=10) in vec4 textBorderColor;\t\t\t// 文字边框颜色\n\tlayout(location=11) in vec4 opacityAndDisplayAndVpScaleAndVpTrans;\t\t\t// 透明度 是否显示 是否跟随视口缩放 是否跟随视口平移\n    \n    // out是从顶点着色器传递到片段着色器（用于处理像素颜色）的数据\n\tout vec2 vTexCoord;\t\t\t\t// UV\n\tout vec4 vBgColor;\n\tout float vIsText;\n\tout float vTextBorderWidth;\n\tout vec4 vTextBorderColor;\n\tout float vHasTexture;\n\tout vec4 vPos;\n\tout float vNotBorder;\n\tout float vBorderDashed;\n\tout float vOpacity;\n\tout float vDisplay;\n\n  // 应用程序和着色器之间传递传递参数\n\tuniform vec2 uConversionVec2;\t//坐标转换\n\tuniform vec2 uViewportTranslation;\t//视口平移\n\tuniform vec2 uViewportScale;\t\t//视口缩放\n\tuniform float uViewportRotation;\t//视口旋转\n\tuniform vec4 uOpacity;\t\t\t\t//全局透明度\n\n\tmat4 getScaleMatrix(vec2 scale) {\n\t\treturn mat4(\n\t\t\tscale.x, 0.0, 0.0, 0.0,\n\t\t\t0.0, scale.y, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getRotationMatrix(float radian) {\n\t\tfloat cost = cos(radian);\n\t\tfloat sint = sin(radian);\n\t\treturn mat4(\n\t\t\tcost, -sint, 0.0, 0.0,\n\t\t\tsint, cost, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getTranslationMatrix(vec2 translation) {\n\t\treturn mat4(\n\t\t\t1.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\ttranslation.x, translation.y, 0.0, 1.0\n\t\t);\n\t}\n\n    // 找到两个向量夹角平分线上的一个特定点，这个点距离每个向量的端点都是 offset 距离\n\tvec2 getIntersectionVertex(\n\t\tin vec2 v1,\n\t\tin vec2 v2,\n\t\tin float offset\n\t) {\n\t\tvec4 vv1 = vec4(v1, 0.0, 1.0);\n\t\tvec4 vv2 = vec4(v2, 0.0, 1.0);\n\t\t// 向量夹角\n\t\tvec2 mid = normalize(normalize(v1) + normalize(v2));\n\t\tfloat theta = acos(dot(v1, v2) / (length(v1) * length(v2)));\n\t\t// 右手法则，判断夹角正负\n\t\tvec3 c = cross(vv1.xyz, vv2.xyz);\n\t\tfloat l = offset / sin(theta * 0.5);\n\t\treturn mid * l * (- sign(c.z));\n\t}\n\n    // 将一个点按照给定的比率和值进行偏移，用于创建动画、调整对象位置\n\tvec2 getVertex(\n\t\tin vec2 origin,\n\t\tin vec2 offsetRatio,\n\t\tin vec2 offsetValue\n\t) {\n\t\tvec2 offset = offsetRatio * offsetValue;\n\t\treturn origin + offset;\n\t}\n   \n\tvec2 getFollowViewport() {\n\t\tfloat outViewportStatus = vertexAndEdgeOffsetValueAndNotFollowViewport.w;  // 跟随视口状态\t\n\t\tvec3 f = vec3(outViewportStatus - 1.0, outViewportStatus - 2.0, outViewportStatus - 3.0);\n\t\tf = step(vec3(0.5, 0.5, 0.5), abs(f));\n\t\treturn vec2(f.x * f.z, f.y * f.z);\n\t}\n\n\t// 获取缩放矢量\n\tvec2 getScaleVec(float scale, vec2 followViewport, vec2 notFollowViewport) {\n\t\tvec2 scaleVec = vec2(scale, scale);\n\t\tvec2 isVpScale = vec2(1.0, 1.0) - opacityAndDisplayAndVpScaleAndVpTrans.zz;\n\t\tvec2 dscaleVec = vec2(1.0, 1.0) / uViewportScale * scaleVec * isVpScale + scaleVec * (1.0-isVpScale);\n\t\treturn dscaleVec * followViewport + scaleVec * notFollowViewport;\n\t}\n\n\tvoid main(void) {\n\t\tvec2 pv = getVertex(prevVertexAndRatio.xy, prevVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 cv = getVertex(currVertexAndRatio.xy, currVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 nv = getVertex(nextVertexAndRatio.xy, nextVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 pe = pv - cv;\n\t\tvec2 ne = nv - cv;\n\n\t\t// 判断是否需要乘视口矩阵\n\t\tvec2 followViewport = getFollowViewport();\n\t\tvec2 notFollowViewport = vec2(1.0, 1.0) - followViewport;\n\n\t\t// 各种矩阵\n\t\tmat4 rotationMatrix = getRotationMatrix(translationAndRotation.z);\n\t\t// 缩放矩阵，如果设置了脱离视口，则需要计算一个反向缩放矩阵\n\t\tmat4 scaleMatrix = getScaleMatrix(getScaleVec(isTextAndBorderWidthAndDashedAndScale.w, followViewport, notFollowViewport));\n\t\tmat4 transMat = getTranslationMatrix(translationAndRotation.xy);\n\t\tmat4 converMat = getScaleMatrix(uConversionVec2.xy);\n\t\t// 视口矩阵\n\t\tmat4 vpScaleMatrix = getScaleMatrix(uViewportScale);\n\t\tmat4 vpTranslationMatrix = getTranslationMatrix(uViewportTranslation);\n\t\tmat4 vpRotationMatrix = getRotationMatrix(uViewportRotation);\n\t\tmat4 vpMat = vpTranslationMatrix * vpScaleMatrix * converMat * vpRotationMatrix;\n\n\t\t// 求相邻两边交点向量\n\t\tvec2 intersection = getIntersectionVertex(pe, ne, vertexAndEdgeOffsetValueAndNotFollowViewport.z * uvAndEdgeOffsetRatio.z);\n\n\t\tvec4 posOrigin = transMat * scaleMatrix * rotationMatrix * vec4(cv, 0.0, 1.0);\n\t\tvec4 posBorder = rotationMatrix * vec4(intersection, 0.0, 0.0);\n\t\tposBorder = converMat * vec4(vec2(vpRotationMatrix * posBorder) * followViewport + posBorder.xy * notFollowViewport, 0, 0);\n\t\tposOrigin = vec4(vec2(vpMat * posOrigin) * followViewport + vec2(converMat * posOrigin) * notFollowViewport, 0.0, 1.0);\n\n\t\tgl_Position = posOrigin + posBorder;\n\n\t\t// out\n\t\t// 如果材质宽度为0 则标志为无材质\n\t\tvHasTexture = step(0.0, UVRect.z);\n\t\tvTexCoord = uvAndEdgeOffsetRatio.xy * UVRect.zw + UVRect.xy;\n\t\tvBgColor = backgroundColor;\n\t\tvIsText = isTextAndBorderWidthAndDashedAndScale.x;\n\t\tvTextBorderWidth = isTextAndBorderWidthAndDashedAndScale.y;\n\t\tvTextBorderColor = textBorderColor;\n\t\tvNotBorder = step(vertexAndEdgeOffsetValueAndNotFollowViewport.z, 0.0);\n\n\t\tvPos = rotationMatrix * vec4(cv, 0.0, 1.0); // 用于边框渲染计算\n\t\tvPos = vec4(vec2(vpRotationMatrix * vPos) * followViewport + vPos.xy * notFollowViewport, 0.0, 1.0);\n\n\t\tvBorderDashed = isTextAndBorderWidthAndDashedAndScale.z;\n\t\tvOpacity = opacityAndDisplayAndVpScaleAndVpTrans.x * uOpacity.x;\n\t\tvDisplay = opacityAndDisplayAndVpScaleAndVpTrans.y;\n\t}\n`;\n")]),e("h3",[t._v("片段着色器")]),e("pre",[t._v("片段着色器(像素着色器)的功能就是：输出颜色；\nvarying vec4 v_color;\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n\n片段着色器(像素着色器)也是并行的，不过执行的次数不是顶点个数，而是屏幕像素个数。\n假如绘制一个960x540的长方形，每一个像素点的颜色，都是通过执行一次片段着色器来得到，那么GPU需要执行960x540次\n\n顶点数越多，顶点着色器执行次数越多。\n屏幕分辨率越高，片段着色器执行次数越多。\n这里可以推出手游常见的两种优化方式：减少顶点、降低分辨率\n\n绘制一个200x200 左右大小的正方形\n正方形四个顶点，顶点着色器只需要执行4次，而面对200x200个像素，片段着色器，需要执行200x200次。\n只有正方形四个顶点的那四个像素，才能直接从顶点着色器拿到颜色数据，那中间的像素颜色数据从哪里来？\n\n插值\n中间的像素颜色，都是插值得到的。\n\n左上角顶点颜色是红色，右上角顶点颜色是蓝色，可以看到中间颜色是由红色、蓝色插值混合而成。\n\n注意：所有从顶点着色器输出到片段着色器的数据，都会插值\n\nexport const fragmentString = `\n  #version 300 es\n\tprecision mediump float;\n\tuniform sampler2D uSampler;\n\t// uniform vec2 uConversionVec2;\t// 坐标转换\n\tin vec2 vTexCoord; // 从顶点着色器传入的纹理坐标\n\tin vec4 vBgColor; // 从顶点着色器传入的背景颜色\n\tin float vIsText;\n\tin float vTextBorderWidth;\n\tin vec4 vTextBorderColor;\n\tin float vHasTexture;\n\tin vec4 vPos;\n\tin float vNotBorder;\n\tin float vBorderDashed;\n\tin float vOpacity;\n\tin float vDisplay;\n\tout vec4 fragColor; // 片段着色器的输出颜色，将被用于最终的像素颜色\n\n    // 确定一个片段是否应该被渲染为虚线边框的一部分\n\tfloat inBorderDashed() {\n\t\t// 是否绘制虚线\n\t\tfloat hasDashed = 1.0 - step(vBorderDashed, 0.0);\n\t\tvec2 fw = fwidth(vPos.xy);\n\t\tfloat k = fw.y * (1.0/fw.x);\n\t\t// 如果k在 0.95 和 1.05 之间\n\t\tfloat c1 = step(0.95, k) * step(k, 1.05);\n\t\t// 如果 c1 == 0.1 则 c2 = 0.0 否则 c2 = 1.0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 如果 c1 条件成立 则 gl_FragCoord.x 否则 ...\n\t\tfloat d = gl_FragCoord.x * c1 + (step(1.0, k) * gl_FragCoord.y + step(k, 1.0) * gl_FragCoord.x) * c2;\n\t\treturn step(mod(floor( d * (1.0/vBorderDashed) ), 2.0), 0.0) * hasDashed;\n\t}\n\n\tvec4 drawText(vec4 texture) {\n\t\t// 文字边框是否大于0\n\t\tfloat c1 = step(0.1, vTextBorderWidth);\n\t\t// 文字边框是否小于等于0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 第一个插值阶梯\n\t\tfloat start = max(0.0, 0.5 - vTextBorderWidth * 0.1);\n\t\t// 边框插值系数\n\t\tfloat r1 = smoothstep(start, start + 0.2, texture.r) * c1;\n\t\t// 文字插值系数\n\t\tfloat r2 = smoothstep(0.5, 0.85, texture.r);\n\n\t\treturn vec4(mix(vTextBorderColor.rgb, vBgColor.rgb, r2), r2+(1.0-r2)*r1);\n\t}\n\n\tvec4 drawNormal(vec4 texture, vec4 bgColor) {\n\t\tfloat a1 = texture.a * vHasTexture;\n\t\tfloat a2 = bgColor.a;\n\t\treturn vec4(mix(bgColor.rgb, texture.rgb, a1), a1+(1.0-a1)*a2);\n\t}\n\n\tvoid main(void) {\n        // 丢弃不显示的片段\n\t\tif(vDisplay == 0.0 || vOpacity == 0.0) {\n\t\t\tdiscard;\n\t\t\treturn;\n\t\t}\n\n\t\t// ib == 0.0 则正常渲染， ib == 1.0 则渲染反色\n\t\tfloat ib = inBorderDashed();\n\t\tvec4 bgColor = vec4(vBgColor.rgb * (1.0 - ib) + (vec3(1.0, 1.0, 1.0) - vBgColor.rgb) * ib, vBgColor.a);\n\n\t\t// 材质\n\t\tvec4 tColor = texture(uSampler, vTexCoord);\n\t\t// 绘制字体\n\t\tvec4 textColor = drawText(tColor);\n\t\t// 绘制普通对象\n\t\tvec4 normalColor = drawNormal(tColor, bgColor);\n\n\t\tvec4 color = vIsText * textColor + (1.0 - vIsText) * normalColor;\n\t\tcolor.a *= vOpacity;\n\t\tfragColor = color;\n\t}\n`;\n")]),e("div",[e("h3",[t._v("贴图显示逻辑")]),e("pre",[t._v("顶点色能做到的效果有限，所以有另一套机制:UV坐标。\nUV坐标指的是顶点对应在图片的哪个位置，仍旧拿上面的效果举例，4个顶点(左下、右下、右上、左上)分别和图片的4个角对应，那么UV坐标就是下面这样:\n\nstatic const glm::vec3 Positions[6] =\n{\n    //第一个三角形\n    { -1.0f, -1.0f, 0.0f},//左下\n    {  1.0f, -1.0f, 0.0f},//右下\n    {  1.0f,  1.0f, 0.0f},//右上\n    //第二个三角形\n    {  1.0f,  1.0f, 0.0f},//右上\n    { -1.0f,  1.0f, 0.0f},//左上\n    { -1.0f, -1.0f, 0.0f} //左下\n};\nstatic const glm::vec2 UVs[6] = \n{\n    //第一个三角形\n    {  0.0f,  0.0f},//左下\n    {  1.0f,  0.0f},//右下\n    {  1.0f,  1.0f},//右上\n    //第二个三角形\n    {  1.0f,  1.0f},//右上\n    {  0.0f,  1.0f},//左上\n    {  0.0f,  0.0f} //左下\n}\n\nUV坐标范围是[0,1]；顶点坐标和图片对应起来的操作，一般叫做UV映射\n\t")])]),e("section",[e("pre",[t._v("CPU与GPU的通信方式：\n\nCPU和GPU是一种CS模式，即客户端-服务器模式。\n客户端不能直接访问服务器资源，客户端想对服务器资源进行操作，只能通过网络协议交互，由服务器进行操作。\nCPU就是客户端，GPU就是服务器。\n\n上传图片数据到显卡分为几步\n1   glGenTextures\t通知显卡创建纹理对象，返回句柄;\n2\tglBindTexture\t将纹理绑定到特定纹理目标;\n3\tglTexImage2D\t将图片rgb数据上传到GPU;\n\n上面的API都是阻塞式的。\n所以在游戏中，需要减小图片尺寸减少上传时间，需要打包图集减少上传次数\n\n")])]),e("pre",[t._v("引擎主循环每执行一次，都需要上传顶点数据到GPU\n在实际项目中是不可行的，游戏同屏顶点数普遍超过10w，每一帧都上传10w顶点数据到GPU，想想都可怕。\n\n针对性的优化有2点：\n1.减少上传数据量---- 顶点索引\n2.在GPU上缓存数据---- 缓冲区对象\n\n\n顶点坐标数据是一个数组，那么顶点索引就是这个数组的index; 将顶点坐标去重，然后新建数组存储下标\n一个顶点，包含了顶点坐标、顶点颜色、UV坐标这三个数据\n使用顶点索引(kVertexIndexVector)进行绘制，需要引入新的API - glDrawElements\n\nglDrawElements 通过顶点索引进行绘制，大幅度减少了上传到GPU的数据，但是仍然是每一帧都上传一次。\n是否可以将数据缓存在GPU，这样只需要上传一次即可？ OpenGL引入了Buffer Object，即缓冲区对象;\n顶点数据上传到GPU之后，就缓存起来，后续渲染直接从显存获取,\n\n使用缓冲区对象进行绘制分为以下步骤：\n创建VBO(顶点缓冲区对象) 和 EBO(索引缓冲区对象)，并上传数据\n将Shader变量和缓冲区对象进行关联\n使用EBO绘制\n")]),e("p",[t._v(" openGL3.0 ")]),e("pre",[t._v("从 #version 110 升级为 #version 330\n增加了顶点数组对象(Vertex Array Object，简称VAO)\n使用关键字in 替代 attribute\n使用关键字out 替代varying\n采样函数从texture2D变为texture\n片段着色器的输出，可以使用关键字out指定自定义变量。\n\n顶点着色器\n#version 330 core\nuniform mat4 u_mvp;\nlayout(location = 0) in  vec3 a_pos;\nlayout(location = 1) in  vec4 a_color;\nout vec4 v_color;\nvoid main()\n{\n    gl_Position = u_mvp * vec4(a_pos, 1.0);\n    v_color = a_color;\n};\n\n片段着色器\n#version 330 core\nin vec4 v_color;\nlayout(location = 0) out vec4 o_fragColor;\nvoid main()\n{\n    o_fragColor = v_color;\n}\n\n顶点数组对象(Vertex Array Object，简称VAO)可以减少OpenGL API的调用次数。\nVAO就像一个容器，在GPU端记录了一次绘制的顶点的状态。\n\n每次绘制时，需要绑定VBO、EBO，这就调用了2次API\n//指定当前使用的VBO\nglBindBuffer(GL_ARRAY_BUFFER, kVBO);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, kEBO);\n\n// 生成一个VAO\nglGenVertexArrays(1,kVAO);\nglBindVertexArray(kVAO);\n{\n    //指定当前使用的VBO\n    glBindBuffer(GL_ARRAY_BUFFER, kVBO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, kEBO);\n}\nglBindBuffer(GL_ARRAY_BUFFER, 0);\n\n在绘制的时候只要绑定VAO\nglBindVertexArray(kVAO);\n{\n    glDrawElements(GL_TRIANGLES,36,GL_UNSIGNED_SHORT,0);//使用顶点索引进行绘制，最后的0表示数据偏移量。\n}\nglBindVertexArray(0);\n\n将非动态的内容，都可以设置到VAO里面\n\n"),e("h3",[t._v("Mesh")]),t._v("\n"),e("p",[t._v("模型就是指Mesh")]),t._v("\nmesh包含一些列顶点数据，静态模型\n\n相机的作用就是提供View、Projection这两个矩阵，MeshRenderer拿到这两个矩阵和模型世界坐标相乘得到mvp，传入GPU。\n多相机渲染，就是要遍历多个相机，用当前 index 相机的View、Projection矩阵，提供给MeshRenderer拿去做计算\n\n所谓材质，就是一系列属性的集合。\n模型材质，是渲染这个模型所需要的一系列属性的集合，例如指定贴图、颜色。\n物理材质，就是物体用于物理计算所需要的一系列属性的集合，例如摩擦系数、弹性系数\n\n")])])}],f={name:"Home",components:{}},_=f,p=(n("d12e"),Object(c["a"])(_,l,v,!1,null,"67b0523a",null)),b=p.exports,g=function(){var t=this;t._self._c;return t._m(0)},A=[function(){var t=this,e=t._self._c;return e("div",{staticClass:"wrapper"},[e("h3",[t._v("坐标系")]),e("img",{attrs:{width:"400px",src:n("34a5"),alt:""}}),e("p",[t._v("xyz")]),e("pre",[t._v("坐标系是描述物体或点的位置和方向的一种数学工具。它由坐标轴和原点组成，通常用于二维或三维空间中。\n\n坐标轴是一条直线，其上有等距离的点，用来表示某个方向上的距离。在二维坐标系中，通常有两条垂直的坐标轴，即水平轴和垂直轴；在三维坐标系中，则需要增加一条竖直的轴。这些轴通常用 x、y 和 z 表示，并通过原点相交。\n\n位置可以用一组数字（称为坐标）来描述。在二维坐标系中，每个点都有一个唯一的坐标，由它在水平轴和垂直轴上的位置确定。在三维坐标系中，每个点由它在三个轴上的位置确定。\n\n坐标系不仅可以用来描述物体或点在空间中的位置和方向，还可以用于计算距离、角度、速度、加速度等物理量。它在数学、物理、工程、计算机科学等领域都有广泛应用。\n\n## 二维笛卡尔坐标系\n\n笛卡尔坐标系由两条互相垂直的直线，即 x 轴和 y 轴组成\n\n在平面直角坐标系中，每个点都可以通过一对有序实数(x, y)来表示。其中，x 坐标表示点到 y 轴的水平距离；y 坐标表示点到 x 轴的竖直距离。通常情况下，x 轴向右为正方向，y 轴向上为正方向。\n\n参考系不一样，最终造成二者的坐标表示内容也是不一样的，其实这点可以类推我们在图形学中讲到的物体坐标系。每个物体都有自己单独的坐标系，这样就会造成标准不统一，难以在统一的条件下进行控制多个物体。\n\n## 三维笛卡尔坐标系\n\nx、y、z 分别表示点到 yz 平面、xz 平面和 xy 平面的距离。通常情况下，x 轴向右为正方向，y 轴向上为正方向，z 轴向前为正方向。三维笛卡尔坐标系广泛应用于各种领域，如数学、物理、工程、计算机图形学等。\n在计算机图形学中，三维坐标系被用来描述三维物体的位置、大小和形状等属性，是实现三维渲染、动画和虚拟现实等技术的基础。\n\n### 基向量\n\n在线性代数中，三个轴（在一维和二维情况下分别为一个或两个）构成了我们所说的该坐标系的基础。基向量是一组线性独立的向量，它们以线性组合表示给定向量空间（坐标系）中的每个向量。更改基向量或更改坐标系是数学和图形管道中的常见操作。\n\n基向量是一个矩阵或向量空间中的一组线性无关向量，可以通过它们来表示该空间中的任何向量。基向量集通常被称为基。\n在二维空间中，通常使用两个向量作为基向量。在三维空间中，则通常使用三个向量作为基向量。这些基向量被选为互相垂直且长度为 1，因此它们可以用来描述空间中的任何向量。\n更一般地说，在 n 维向量空间中，需要 n 个线性无关的基向量才能表示该空间中的所有向量。这些基向量通常被写成列向量的形式，并排列成一个矩阵，这个矩阵就被称为基矩阵。\n\n## 左手坐标系与右手坐标系\n\n"),e("img",{attrs:{width:"400px",src:n("8a76"),alt:""}}),t._v("\n\n坐标系标准\n\n当 x 轴指向右侧，y 轴指向上方时，如果 z 轴指向远离你，则为左手坐标系。如果它指向你的方向，则为右手坐标系。\n\n- 左手：远离你\n- 右手：朝你\n\n坐标系的惯用手性在从多边形面的边计算的法线方向中也起着重要作用。\n例如，如果方向为右手，则其折点按逆时针顺序指定的面将朝前。\n\n## 物体坐标系（模型坐标系、身体坐标系、个体坐标系）\n\n物体坐标系是三维空间中的一个坐标系，用于描述物体在三维空间中的位置和方向。通常情况下，物体坐标系的原点被定义为物体的质心或几何中心，并且其轴线会根据物体的形状而确定。\n\n物体坐标系是和特定物体相关联的坐标系。每个物体都有它们独立的坐标系。\n\n结合实现的例子给大家举例子，比如此刻你要去北京天安门玩耍，高德导航会告诉你“向左转，向右转”。此时是以你个人为中心，也就等同于我们所讲的物体坐标系下的运动。\n\n有时候你行走的方向相反了，或者你偏移了很大角度，高德地图一般会提示你“您的方向偏移，请向南出发”此时他的意思就是在世界坐标系下进行的提醒，此刻你的目的地和你本身都是放在世界坐标系下去衡量的。\n\n**在计算机图形学中，物体坐标系通常被用来描述三维模型的位置、旋转和缩放状态。当需要对三维模型进行变换时，可以通过对其物体坐标系进行变换来实现**\n例如，通过对物体坐标系进行平移变换，可以将模型沿着某个轴线上移动一定距离；通过对物体坐标系进行旋转变换，可以将模型绕某个轴线旋转一定角度。\n\n## 世界坐标系（全局坐标系、宇宙坐标系）\n\n世界坐标系有很多名字，它类同于笛卡尔坐标系，只是它具有了物理属性，赋予了它在实际中的例子。\n上面我们提到其实每个物体都有自己的坐标系，但是实际我们在日常应用中，我们需要将各个坐标系进行统一化，在一个相同的约束下进行计算。所以世界坐标系就产生了，每个物体相对于世界坐标系都有自己的坐标。\n我们经常在小学学习地理的时候，老师告诉我们更具地球经纬度就可以获取到你的位置，所以人类根据这个基本原理，设定了 WGS 84 坐标系。学地理或者学 GIS 的同学一定对这个概念很清楚。实际上相对于地球来说，世界坐标系在球体的质心。\n\n世界坐标系是一个特殊的坐标系，它建立了描述其他坐标系所需要的参考框架。\n从另一方面说，能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系来描述世界坐标系。在世界坐标系里面的任何一个东西，我们都能用世界坐标表示。\n\n## 惯性坐标系\n\n惯性坐标系实际上是世界坐标系与物体坐标系的中间模块，为了方便二者转换，引入了一种新的坐标系，称作惯性坐标系。惯性坐标系的原点和物体坐标系的原点重合，惯性坐标系的轴平行于世界标系的轴\n\n- 为什么引入惯性坐标系\n  因为从物体标系转换到惯性标系只需旋转；\n  从惯性标系转换到界坐标系只需要平移。\n\n## 嵌套坐标系\n\n所谓的“嵌套坐标系”实际上是世界坐标系和物体坐标系的综合，\n比如举个例子，你仍然要去北京天安门游玩，在去的路上你相对地球来说，你的位置不断发生位移，这就属于在世界坐标系的坐标变换，\n\n在去天安门游玩的路上，你在路上吸了口烟，吐了口吐沫。这两个动作实际上是相对于你本身而言的，也就是物体坐标系。在实际程序开发中，我们应用嵌套坐标系的例子很多，比如我们在做人物奔跑、漫游、行走、坐下等连续式动画的时候\n\n## 相机坐标系\n"),e("img",{attrs:{width:"400px",src:n("cff6"),alt:""}}),t._v("\n\n相机坐标系可以想象成你本人的观察视角。\n\n摄像机坐标系能被看作是一种特殊的“物体”坐标系，该“物体”坐标系就定义在摄像机的屏幕可视区域。\n摄像机坐标系中，摄像机在原点，x 轴向右，z 轴向前(朝向屏幕内或摄像机方向)，y 轴向上(不是世界的上方而是摄像机本身的上方)。\n\n## 投影坐标系（裁减坐标系）\n\n投影坐标系，也称为裁减坐标系，是计算机图形学中一个重要的概念。\n在三维图形学中，我们通常使用三维对象描述场景。然而，在实际应用中，我们需要在二维屏幕上显示这些场景。因此，必须将三维场景中的点映射到二维投影平面上。这个过程就需要用到投影坐标系。\n\n投影坐标系一般分为正交投影和透视投影。\n\n## 屏幕坐标系\n\n屏幕坐标系是计算机图形学中用于表示屏幕上的像素位置的坐标系。\n它通常是一个以左上角为原点（0,0）的二维直角坐标系，其中水平方向向右为正方向，垂直方向向下为正方向。\n在屏幕坐标系中，每个像素都可以由其 x 和 y 坐标确定。\n例如，屏幕上的某个像素可能具有坐标 (100, 200)，这意味着它距离屏幕左侧 100 个像素，距离屏幕顶部 200 个像素。\n\n## 坐标系转换\n\n其实坐标系转换是同一个事物在不同坐标系下的表现形式。两个不同坐标的转换过程被称为“坐标系转换”。\n\nhttps://www.bilibili.com/video/BV1HU4y1e7JS/?vd_source=01ae3fc576acbf5bd3e59f3307bb594f\n\n    ")])])}],m={name:"Home",components:{}},x=m,M=(n("b75e"),Object(c["a"])(x,g,A,!1,null,"444e43a2",null)),O=M.exports,w=function(){var t=this;t._self._c;return t._m(0)},T=[function(){var t=this,e=t._self._c;return e("div",{staticClass:"wrapper"},[e("h2",[t._v("点&向量")]),e("img",{attrs:{width:"400px",src:n("3260"),alt:""}}),e("h3",[t._v("点")]),t._v(" 点是最基础的几何形状了吧。点是三维空间中的一个位置 vec3 a= vec3(0.5,0.5,1); // 函数用来表示一个在 z 轴上面的点 "),e("h3",[t._v("向量")]),e("pre",[t._v("物理层面：大小，方向的箭头，起点 》终点\n计算机层面：坐标系中的点坐标 x，y\n\n二维空间中， 原点 -> 终点\n[1\n2]\n\n三维空间\n[1\n2\n3]\n\n### 向量加法\n\n各坐标轴的分量相加，平移\n数乘，缩放\n\n## 2.向量坐标\n\n坐标轴看着标量\n\n基向量：坐标系中单位长度为 1\na = bW + vV\n二维向量 a 都可以看做基向量 v，w 的线性组合\nv 和 w 全部的向量组合为 张成的空间\n")]),e("h3",[t._v("向量desc")]),e("pre",[t._v("\n向量又称为矢量，具体定义我们不再过多介绍。但向量可以在 CG 中可以用数字数组表示。这个数字数组可以假定任何所需的长度，有时也称为数学中的元组\n\n元组是数学中的一个概念，它指的是有序数对或者有序 n 元组。元组的形式可以表示为 (a1, a2, ..., an)，其中每个元素 ai 可以是任意数值类型，也可以是其他数据类型。在数学中，元组通常用于描述多个变量之间的关系或者属性。例如，一个二维平面上的点可以表示为一个含有两个元素的元组 (x, y)\n\n在计算机图形学中，向量可以表示空间中的位置或方向。CG 中提供了很多方法来操控这些向量，变换这些向量的方法我们称为线性变换: 线性变换是指一种将一个向量空间中的向量映射到另一个向量空间中的操作。线性变换在向量空间中有着广泛的应用，包括矩阵乘法、旋转、缩放、投影等等\n\n### 行向量与列向量\n\n行向量: directX 就是行向量\n行向量是一个 1 × n 的矩阵，其中 n 是元素的数量。例如：\nA=[a₁,a₂,...,aₙ]\n\n列向量: opengl 就是列向量\n列向量是一个 n × 1 的矩阵，其中 n 是元素的数量。例如：\nb=[\n1,\n2,\n3\n]\n\n```js\n/**\n * 向量通常指一个有长度有方向的量。向量使所有的移动和空间行为更容易理解和在代码中实现。\n * 向量可以相加，缩放，旋转，指向某物体。\n * 在javascript中，一个方向和长度(即向量)在二维空间中可以用横坐标x和纵坐标y表示。\n */\n\nconst EPSILON = 0.00000001;\nconst areEqual = (one, other, epsilon = EPSILON) => Math.abs(one - other) < epsilon;\n\n// 向量由一系列数值构成，每维数值都是向量的一个分量\n// 1.方向\n// 2.长度\n// const length = Math.sqrt(x * x + y * y);\n\n// ** 角是以弧度( radian )为单位，不是角度( degree ) **\n// 1弧度是弧长和半径相等的弧，圆的周长：2*Math.PI*R(R为半径)，圆的弧度：2*Math.PI\n//弧度转角度\nconst toDegrees = (radians) => (radians * 180) / Math.PI;\n//角度转弧度\nconst toRadians = (degrees) => (degrees * Math.PI) / 180;\n\n// ======= 向量的运算 =======\nclass Vector {\n  constructor(...vectors) {\n    this.vectors = vectors; // [1, 2]\n  }\n\n  // 向量加：返回一个新向量\n  // 1.向量相加\n  // 将向量看成一个运动，从原点出发，向v方向移动长度∣v∣后，再向w方向移动长度∣w∣后，就等于直接向 v+w方向移动长度∣v+w∣\n  add({ vectors }) {\n    return new Vector(...vectors.map((v, index) => this.vectors[index] + v));\n  }\n  // 向量减：返回一个新向量\n  subtract({ vectors }) {\n    return new Vector(...vectors.map((v, index) => this.vectors[index] - v));\n  }\n  // 对一个向量进行缩放，缩放比例可为任意数值 α ∈ R。缩放时，对所有向量分量都乘以缩放因子 α。\n  // 当 α > 1 时，向量会变得更长；\n  // 当 0 ≤ α ≤ 1 时，向量会变得更短。\n  // 如果 α 是负数，缩放后的向量将会指向原向量的反方向。\n  // 乘法\n  scaleBy(number) {\n    return new Vector(...this.vectors.map((v) => v * number));\n  }\n  // 向量长度可由勾股定理导出\n  length() {\n    return Math.hypot(...this.vectors);\n  }\n  // 点积\n  // 点积可以计算出两个向量的相似程度。点积方法接收两个向量作为输入，并输出一个数值。\n  // 两个向量的点积等于它们各自对应分量的乘积之和。\n  // a*b = |a|*|b|*con0\n  // 计算投影， 分解， 方向\n  // https://docs.pingcode.com/ask/38308.html\n  dotProduct({ otherVectors }) {\n    return otherVectors.reduce(\n      (acc, ov, index) => acc + ov * this.vectors[index],\n      0\n    );\n  }\n  // 在我们观察几个向量间的方向关系前，需要先实现一种将向量长度归一化为 1 的方法\n  // 归一化向量，该方向的单位向量\n  normalize() {\n    return this.scaleBy(1 / this.length());\n  }\n  // 如果两个归一化后的向量的点积结果等于 1，则意味着这两个向量的方向相同。\n  haveSameDirectionWith(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, 1);\n  }\n  // = -1， 反向\n  haveOppositeDirectionTo(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, -1);\n  }\n  // = 0， 垂直\n  isPerpendicularTo(other) {\n    const dotProduct = this.normalize().dotProduct(other.normalize());\n    return areEqual(dotProduct, 0);\n  }\n  // 叉积\n  // 叉积仅对三维向量适用，它会产生垂直于两个输入向量的向量\n  // 只适用于 3 维向量， 计算法向量， 计算三维坐标系\n  // |a*b| = |a||b|sin0\n  // 用来判断方向，两个向量的左右关系， 是否在三角形内外\n  crossProduct({ others }) {\n    return new Vector(\n      this.vectors[1] * others[2] - this.vectors[2] * others[1],\n      this.vectors[2] * others[0] - this.vectors[0] * others[2],\n      this.vectors[0] * others[1] - this.vectors[1] * others[0]\n    );\n  }\n\n  // 计算夹角\n  angleBetween(other) {\n    return toDegrees(\n      Math.acos(this.dotProduct(other) / (this.length() * other.length()))\n    );\n  }\n\n  // 当需要将一个向量的方向指向反向时，我们可以对这个向量进行 -1 缩放\n  negate() {\n    return this.scaleBy(-1);\n  }\n\n  // 投影\n  // 在向量other上的投影\n  projectOn(other) {\n    // other的单位向量\n    const otherStandardVect = other.normalize();\n    // other的单位向量和one的点乘值\n    const sv = this.dotProduct(otherStandardVect);\n    return otherStandardVect.scaleBy(sv);\n  }\n\n  // 为了判断两个向量是否相等，可以对它们对应的分量使用 areEqual 函数\n  equalTo({ components }) {\n    return components.every((component, index) =>\n      areEqual(component, this.vectors[index])\n    );\n  }\n\n  // 单位向量与基底\n}\n```\n\n## 法线\n\n法线（Normal）是指垂直于曲面或多边形表面的向量。法线通常被用来计算光照和阴影，以及决定物体表面如何反射光线\n\n## 向量的基\n\n对于任何二维的向量点 C\n[1,\n2]\n\nC = Ai + Bj, i 和 j 为基向量\n基可以变化\n\n## 线性相关\n\n## 向量张成的空间\n\n由基向量组合的所有向量形成的空间\n\n    ")])])}],E={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},R=E,V=(n("d733"),Object(c["a"])(R,w,T,!1,null,"f7343104",null)),y=V.exports,S=function(){var t=this;t._self._c;return t._m(0)},D=[function(){var t=this,e=t._self._c;return e("div",{staticClass:"wrapper"},[e("h2",[t._v("矩阵")]),e("img",{attrs:{width:"600px",src:n("1aa6"),alt:""}}),e("h3",[t._v("矩阵本质")]),e("img",{attrs:{width:"400px",src:n("0b6d"),alt:""}}),e("img",{attrs:{width:"400px",src:n("de67"),alt:""}}),e("pre",[t._v("        矩阵如同线性变换 =》一种空间变换\n\n- 线性变换\n  输入向量 =》 输出向量\n\n从输入向输出移动，理解为一种运动\n\n所有的输入点 经过变换 到达输出点\n\n线性变换：1.原点不变， 2.直线还是线\n- 变换基向量即可\n\nn阶矩阵列 可以理解为 变换基\n\n矩阵 * 向量 =》新向量\n    ")]),e("h3",[t._v("# 矩阵 matrix")]),e("pre",[t._v("\n由 `m*n 个数排成的 m 行 n 列的数表称为 m 行 n 列的矩阵，简称 m*n` 矩阵;\n行数与列数都等于 n 的矩阵称为 n 阶矩阵或 n 阶方阵\n\n线性变换\n\n- 原点不变，直线性不变\n\nVin \\* Mat = Vout\n\n向量乘矩阵： 变换得到一个新向量\nx[] + y[] = v\n\n## 秩\n\n矩阵秩是矩阵理论中的一个重要概念，它描述了矩阵所包含的线性无关向量的个数\n\n矩阵秩的通俗易懂定义是：一个矩阵的秩就是它所包含的线性无关列向量（或行向量）的最大数量。\n可以简单地理解为一个矩阵中不重复的列向量（或行向量）的数量\n\nhttps://www.zhihu.com/question/21605094\n`「秩」是图像经过矩阵变换之后的空间维度 `\n\n秩」是列空间的维度; 首先看下什么是列空间\n\n```js\nconst m = [1, 2\n           2, 1]\n\n// 所以，列空间就是矩阵的列向量 ai + bj 来表示的空间。\n\n```\n\n## 奇异矩阵\n\n奇异矩阵是线性代数的概念，就是该矩阵的秩不是满秩。\n\n首先，看这个矩阵是不是方阵（即行数和列数相等的矩阵，若行数和列数不相等，那就谈不上奇异矩阵和非奇异矩阵）。如是方阵，再看此矩阵的行列式|A|是否等于 0，若等于 0，称矩阵 A 为奇异矩阵；若不等于 0，称矩阵 A 为非奇异矩阵。\n\n## 逆矩阵\n\n逆矩阵是指对于一个给定的方阵 A，如果存在一个方阵 B 使得 A 乘以 B 等于 B 乘以 A 等于单位矩阵 I，则称方阵 B 为 A 的逆矩阵，记作\nA−1\n其中，我们上面讲到单位矩阵指的是对角线上所有元素都为 1，其余元素都为 0 的方阵。\n\n要求一个矩阵 A 的逆矩阵，需要保证以下两个条件都满足：\n\n- 矩阵 A 必须是一个方阵。只有方阵才具有逆矩阵。\n- 矩阵 A 必须是可逆的。即行列式不为 0。\n\n## 转置\n\n考虑一个 RXC 矩阵 M。M 的转置记作 MT，是一个 RXC 矩阵，它的列由 M 的行组成。可以从另一方面理解，MT=M，即沿着矩阵的对角线翻折。如下面这个例子\n\n对于任意矩阵 M，(MT)T=M 。从另一方面来说，将一个矩阵转置后，再转置一次，便会得到原矩阵。\n这条法则对向量也适用,对于任意对角矩阵 D，都有 DT =D，包括单位矩阵 I 也如此。\n\n    ")])])}],N={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},I=N,P=(n("0f9f"),Object(c["a"])(I,S,D,!1,null,"24b2cdae",null)),C=P.exports,L=function(){var t=this,e=t._self._c;return e("div",[e("h2",[t._v("测试图形api")]),e("div",{staticClass:"api-wrapper"},[e("div",[e("span",[t._v("箭头mesh")]),e("input",{directives:[{name:"model",rawName:"v-model",value:t.arrowType,expression:"arrowType"}],attrs:{type:"radio",value:"1"},domProps:{checked:t._q(t.arrowType,"1")},on:{change:function(e){t.arrowType="1"}}}),t._v(" 单向 "),e("input",{directives:[{name:"model",rawName:"v-model",value:t.arrowType,expression:"arrowType"}],attrs:{type:"radio",value:"2"},domProps:{checked:t._q(t.arrowType,"2")},on:{change:function(e){t.arrowType="2"}}}),t._v(" 双向 "),e("button",{on:{click:t.handleDrawArrow}},[t._v("绘制箭头mesh")])]),e("div",[e("span",[t._v("矩形mesh")]),e("button",{on:{click:t.handleDrawRect}},[t._v("绘制矩形mesh")])]),e("div",[t._v("清除 "),e("button",{on:{click:t.handleClear}},[t._v("清除上下文")])]),e("div",[e("h3",[t._v("视口操作")]),e("div",[t._v(" 偏移： x："),e("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOffsetX,expression:"vpOffsetX"}],domProps:{value:t.vpOffsetX},on:{input:function(e){e.target.composing||(t.vpOffsetX=e.target.value)}}}),t._v(" y："),e("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOffsetY,expression:"vpOffsetY"}],domProps:{value:t.vpOffsetY},on:{input:function(e){e.target.composing||(t.vpOffsetY=e.target.value)}}})]),e("div",[t._v(" 缩放原点： x："),e("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOx,expression:"vpOx"}],domProps:{value:t.vpOx},on:{input:function(e){e.target.composing||(t.vpOx=e.target.value)}}}),t._v(" y："),e("input",{directives:[{name:"model",rawName:"v-model",value:t.vpOy,expression:"vpOy"}],domProps:{value:t.vpOy},on:{input:function(e){e.target.composing||(t.vpOy=e.target.value)}}})]),e("div",[t._v(" 缩放比率(0.05-2)："),e("input",{directives:[{name:"model",rawName:"v-model",value:t.vpScaleRatio,expression:"vpScaleRatio"}],domProps:{value:t.vpScaleRatio},on:{input:function(e){e.target.composing||(t.vpScaleRatio=e.target.value)}}}),e("button",{on:{click:t.handleSetVp}},[t._v("设置视口")])])])]),e("canvas",{attrs:{id:"canvas",width:"600px",height:"600px"}})])},B=[],j=(n("a573"),n("ade3"));n("d9e2"),n("14d9"),n("2c66"),n("249d"),n("40e9"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("4e3e");const U="#version 300 es\n\tlayout(location=1) in vec4 currVertexAndRatio;\t\t\t // 指定currVertexAndRatio变量在顶点属性数组中的位置是1 // 顶点坐标和变形系数\n\tlayout(location=2) in vec4 prevVertexAndRatio;\n\tlayout(location=3) in vec4 nextVertexAndRatio;\n\tlayout(location=4) in vec4 uvAndEdgeOffsetRatio;\t\t// UV\n\tlayout(location=5) in vec4 vertexAndEdgeOffsetValueAndNotFollowViewport;\t// 顶点形变  边形变值  是否不跟随视口\n\tlayout(location=6) in vec4 UVRect;\t\t\t\t\t\t// UVRect\n\tlayout(location=7) in vec4 backgroundColor;\t\t\t\t// 背景色\n\tlayout(location=8) in vec4 translationAndRotation;\t\t// 形变\n\tlayout(location=9) in vec4 isTextAndBorderWidthAndDashedAndScale;\t\t// 是否渲染文字 以及 文字边框粗细 以及物体边框虚线 缩放\n\tlayout(location=10) in vec4 textBorderColor;\t\t\t// 文字边框颜色\n\tlayout(location=11) in vec4 opacityAndDisplayAndVpScaleAndVpTrans;\t\t\t// 透明度 是否显示 是否跟随视口缩放 是否跟随视口平移\n    \n\tout vec2 vTexCoord;\t\t\t\t// UV  // out是从顶点着色器传递到片段着色器（用于处理像素颜色）的数据\n\tout vec4 vBgColor;\n\tout float vIsText;\n\tout float vTextBorderWidth;\n\tout vec4 vTextBorderColor;\n\tout float vHasTexture;\n\tout vec4 vPos;\n\tout float vNotBorder;\n\tout float vBorderDashed;\n\tout float vOpacity;\n\tout float vDisplay;\n\n    // 应用程序和着色器之间传递传递参数\n\tuniform vec2 uConversionVec2;\t//坐标转换\n\tuniform vec2 uViewportTranslation;\t//视口平移\n\tuniform vec2 uViewportScale;\t\t//视口缩放\n\tuniform float uViewportRotation;\t//视口旋转\n\tuniform vec4 uOpacity;\t\t\t\t//全局透明度\n\n\tmat4 getScaleMatrix(vec2 scale) {\n\t\treturn mat4(\n\t\t\tscale.x, 0.0, 0.0, 0.0,\n\t\t\t0.0, scale.y, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getRotationMatrix(float radian) {\n\t\tfloat cost = cos(radian);\n\t\tfloat sint = sin(radian);\n\t\treturn mat4(\n\t\t\tcost, -sint, 0.0, 0.0,\n\t\t\tsint, cost, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t}\n\n\tmat4 getTranslationMatrix(vec2 translation) {\n\t\treturn mat4(\n\t\t\t1.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\ttranslation.x, translation.y, 0.0, 1.0\n\t\t);\n\t}\n\n    // 找到两个向量夹角平分线上的一个特定点，这个点距离每个向量的端点都是 offset 距离\n\tvec2 getIntersectionVertex(\n\t\tin vec2 v1,\n\t\tin vec2 v2,\n\t\tin float offset\n\t) {\n\t\tvec4 vv1 = vec4(v1, 0.0, 1.0);\n\t\tvec4 vv2 = vec4(v2, 0.0, 1.0);\n\t\t// 向量夹角\n\t\tvec2 mid = normalize(normalize(v1) + normalize(v2));\n\t\tfloat theta = acos(dot(v1, v2) / (length(v1) * length(v2)));\n\t\t// 右手法则，判断夹角正负\n\t\tvec3 c = cross(vv1.xyz, vv2.xyz);\n\t\tfloat l = offset / sin(theta * 0.5);\n\t\treturn mid * l * (- sign(c.z));\n\t}\n\n    // 将一个点按照给定的比率和值进行偏移，用于创建动画、调整对象位置\n\tvec2 getVertex(\n\t\tin vec2 origin,\n\t\tin vec2 offsetRatio,\n\t\tin vec2 offsetValue\n\t) {\n\t\tvec2 offset = offsetRatio * offsetValue;\n\t\treturn origin + offset;\n\t}\n   \n\tvec2 getFollowViewport() {\n\t\tfloat outViewportStatus = vertexAndEdgeOffsetValueAndNotFollowViewport.w;  // 跟随视口状态\t\n\t\tvec3 f = vec3(outViewportStatus - 1.0, outViewportStatus - 2.0, outViewportStatus - 3.0);\n\t\tf = step(vec3(0.5, 0.5, 0.5), abs(f));\n\t\treturn vec2(f.x * f.z, f.y * f.z);\n\t}\n\n\t// 获取缩放矢量\n\tvec2 getScaleVec(float scale, vec2 followViewport, vec2 notFollowViewport) {\n\t\tvec2 scaleVec = vec2(scale, scale);\n\t\tvec2 isVpScale = vec2(1.0, 1.0) - opacityAndDisplayAndVpScaleAndVpTrans.zz;\n\t\tvec2 dscaleVec = vec2(1.0, 1.0) / uViewportScale * scaleVec * isVpScale + scaleVec * (1.0-isVpScale);\n\t\treturn dscaleVec * followViewport + scaleVec * notFollowViewport;\n\t}\n\n\tvoid main(void) {\n\t\tvec2 pv = getVertex(prevVertexAndRatio.xy, prevVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 cv = getVertex(currVertexAndRatio.xy, currVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 nv = getVertex(nextVertexAndRatio.xy, nextVertexAndRatio.zw, vertexAndEdgeOffsetValueAndNotFollowViewport.xy);\n\t\tvec2 pe = pv - cv;\n\t\tvec2 ne = nv - cv;\n\n\t\t// 判断是否需要乘视口矩阵\n\t\tvec2 followViewport = getFollowViewport();\n\t\tvec2 notFollowViewport = vec2(1.0, 1.0) - followViewport;\n\n\t\t// 各种矩阵\n\t\tmat4 rotationMatrix = getRotationMatrix(translationAndRotation.z);\n\t\t// 缩放矩阵，如果设置了脱离视口，则需要计算一个反向缩放矩阵\n\t\tmat4 scaleMatrix = getScaleMatrix(getScaleVec(isTextAndBorderWidthAndDashedAndScale.w, followViewport, notFollowViewport));\n\t\tmat4 transMat = getTranslationMatrix(translationAndRotation.xy);\n\t\tmat4 converMat = getScaleMatrix(uConversionVec2.xy);\n\t\t// 视口矩阵\n\t\tmat4 vpScaleMatrix = getScaleMatrix(uViewportScale);\n\t\tmat4 vpTranslationMatrix = getTranslationMatrix(uViewportTranslation);\n\t\tmat4 vpRotationMatrix = getRotationMatrix(uViewportRotation);\n\t\tmat4 vpMat = vpTranslationMatrix * vpScaleMatrix * converMat * vpRotationMatrix;\n\n\t\t// 求相邻两边交点向量\n\t\tvec2 intersection = getIntersectionVertex(pe, ne, vertexAndEdgeOffsetValueAndNotFollowViewport.z * uvAndEdgeOffsetRatio.z);\n\n\t\tvec4 posOrigin = transMat * scaleMatrix * rotationMatrix * vec4(cv, 0.0, 1.0);\n\t\tvec4 posBorder = rotationMatrix * vec4(intersection, 0.0, 0.0);\n\t\tposBorder = converMat * vec4(vec2(vpRotationMatrix * posBorder) * followViewport + posBorder.xy * notFollowViewport, 0, 0);\n\t\tposOrigin = vec4(vec2(vpMat * posOrigin) * followViewport + vec2(converMat * posOrigin) * notFollowViewport, 0.0, 1.0);\n\n\t\tgl_Position = posOrigin + posBorder;\n\n\t\t// out\n\t\t// 如果材质宽度为0 则标志为无材质\n\t\tvHasTexture = step(0.0, UVRect.z);\n\t\tvTexCoord = uvAndEdgeOffsetRatio.xy * UVRect.zw + UVRect.xy;\n\t\tvBgColor = backgroundColor;\n\t\tvIsText = isTextAndBorderWidthAndDashedAndScale.x;\n\t\tvTextBorderWidth = isTextAndBorderWidthAndDashedAndScale.y;\n\t\tvTextBorderColor = textBorderColor;\n\t\tvNotBorder = step(vertexAndEdgeOffsetValueAndNotFollowViewport.z, 0.0);\n\n\t\tvPos = rotationMatrix * vec4(cv, 0.0, 1.0); // 用于边框渲染计算\n\t\tvPos = vec4(vec2(vpRotationMatrix * vPos) * followViewport + vPos.xy * notFollowViewport, 0.0, 1.0);\n\n\t\tvBorderDashed = isTextAndBorderWidthAndDashedAndScale.z;\n\t\tvOpacity = opacityAndDisplayAndVpScaleAndVpTrans.x * uOpacity.x;\n\t\tvDisplay = opacityAndDisplayAndVpScaleAndVpTrans.y;\n\t}\n",F=" #version 300 es\n\tprecision mediump float;\n\tuniform sampler2D uSampler;\n\t// uniform vec2 uConversionVec2;\t// 坐标转换\n\tin vec2 vTexCoord; // 从顶点着色器传入的纹理坐标\n\tin vec4 vBgColor; // 从顶点着色器传入的背景颜色\n\tin float vIsText;\n\tin float vTextBorderWidth;\n\tin vec4 vTextBorderColor;\n\tin float vHasTexture;\n\tin vec4 vPos;\n\tin float vNotBorder;\n\tin float vBorderDashed;\n\tin float vOpacity;\n\tin float vDisplay;\n\tout vec4 fragColor; // 片段着色器的输出颜色，将被用于最终的像素颜色\n\n    // 确定一个片段是否应该被渲染为虚线边框的一部分\n\tfloat inBorderDashed() {\n\t\t// 是否绘制虚线\n\t\tfloat hasDashed = 1.0 - step(vBorderDashed, 0.0);\n\t\tvec2 fw = fwidth(vPos.xy);\n\t\tfloat k = fw.y * (1.0/fw.x);\n\t\t// 如果k在 0.95 和 1.05 之间\n\t\tfloat c1 = step(0.95, k) * step(k, 1.05);\n\t\t// 如果 c1 == 0.1 则 c2 = 0.0 否则 c2 = 1.0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 如果 c1 条件成立 则 gl_FragCoord.x 否则 ...\n\t\tfloat d = gl_FragCoord.x * c1 + (step(1.0, k) * gl_FragCoord.y + step(k, 1.0) * gl_FragCoord.x) * c2;\n\t\treturn step(mod(floor( d * (1.0/vBorderDashed) ), 2.0), 0.0) * hasDashed;\n\t}\n\n\tvec4 drawText(vec4 texture) {\n\t\t// 文字边框是否大于0\n\t\tfloat c1 = step(0.1, vTextBorderWidth);\n\t\t// 文字边框是否小于等于0\n\t\tfloat c2 = 1.0 - c1;\n\t\t// 第一个插值阶梯\n\t\tfloat start = max(0.0, 0.5 - vTextBorderWidth * 0.1);\n\t\t// 边框插值系数\n\t\tfloat r1 = smoothstep(start, start + 0.2, texture.r) * c1;\n\t\t// 文字插值系数\n\t\tfloat r2 = smoothstep(0.5, 0.85, texture.r);\n\n\t\treturn vec4(mix(vTextBorderColor.rgb, vBgColor.rgb, r2), r2+(1.0-r2)*r1);\n\t}\n\n\tvec4 drawNormal(vec4 texture, vec4 bgColor) {\n\t\tfloat a1 = texture.a * vHasTexture;\n\t\tfloat a2 = bgColor.a;\n\t\treturn vec4(mix(bgColor.rgb, texture.rgb, a1), a1+(1.0-a1)*a2);\n\t}\n\n\tvoid main(void) {\n        // 丢弃不显示的片段\n\t\tif(vDisplay == 0.0 || vOpacity == 0.0) {\n\t\t\tdiscard;\n\t\t\treturn;\n\t\t}\n\n\t\t// ib == 0.0 则正常渲染， ib == 1.0 则渲染反色\n\t\tfloat ib = inBorderDashed();\n\t\tvec4 bgColor = vec4(vBgColor.rgb * (1.0 - ib) + (vec3(1.0, 1.0, 1.0) - vBgColor.rgb) * ib, vBgColor.a);\n\n\t\t// 材质\n\t\tvec4 tColor = texture(uSampler, vTexCoord);\n\t\t// 绘制字体\n\t\tvec4 textColor = drawText(tColor);\n\t\t// 绘制普通对象\n\t\tvec4 normalColor = drawNormal(tColor, bgColor);\n\n\t\tvec4 color = vIsText * textColor + (1.0 - vIsText) * normalColor;\n\t\tcolor.a *= vOpacity;\n\t\tfragColor = color;\n\t}\n";var Y=n("25a5");function W(t,e){for(var n=t[0],r=t[1],i=!1,o=e.length/2,a=0,s=o-1;a<o;s=a,a++){var c=e[2*a],h=e[2*a+1],u=e[2*s],d=e[2*s+1];if(c===n&&h===r||u===n&&d===r){i=!0;break}if(h<r&&d>=r||h>=r&&d<r){var l=c+(r-h)*(u-c)/(d-h);if(l===n){i=!0;break}l>n&&(i=!i)}}return i}class G{constructor(){Object(j["a"])(this,"_sobj",void 0),Object(j["a"])(this,"_buffer",void 0),this._sobj=new Y(200),this._buffer=new Map}objToItem(t){return Object.assign(t.bounds,{id:t.id})}insert(t){if(!t)return void console.log("Searcher: ","Can not insert.",t);const e=t.bounds;if(!((e.minX-e.maxX)*(e.minY-e.maxY)))return void console.log("Searcher: ","Can not insert, width or height equals 0.");const n=t.id,r=this._buffer.get(n);r&&this.remove(n),this._sobj.insert(this.objToItem(t)),this._buffer.set(t.id,t)}remove(t){let e=this._buffer.get(t);e&&(this._sobj.remove(this.objToItem(e)),this._buffer.delete(e.id))}search(t,e,n=0,r=0){let i=this._sobj.search({minX:t,minY:e,maxX:n+t,maxY:r+e}).map(t=>this._buffer.get(t.id));return 0==n&&0==r&&(i=i.filter(n=>W([t,e],n.vertexes))),i}}class k{constructor(t){Object(j["a"])(this,"_srh",void 0),Object(j["a"])(this,"_sable",!1),Object(j["a"])(this,"_expandRadius",0),this._srh=t}set searchable(t){t!=this._sable&&(this._sable=t,!0===t?this.registToSearcher():this.deregistToSearcher())}get searchable(){return this._sable}set expandRadius(t){this._expandRadius!=t&&(this._expandRadius=t,this._sable&&this.registToSearcher())}get expandRadius(){return this._expandRadius}get id(){return""}getVertexPositions(t=0){return[]}registToSearcher(){const t=this.getVertexPositions(this._expandRadius),e=t.filter((t,e)=>e%2==0),n=t.filter((t,e)=>e%2!=0),r={id:this.id,bounds:{minX:Math.min.apply(null,e),maxX:Math.max.apply(null,e),minY:Math.min.apply(null,n),maxY:Math.max.apply(null,n)},vertexes:t};this._srh.insert(r)}deregistToSearcher(){this._srh.remove(this.id)}}class z{constructor(t=0,e=0){Object(j["a"])(this,"root",void 0),Object(j["a"])(this,"mw",void 0),Object(j["a"])(this,"mh",void 0),this.mw=t,this.mh=e}fit(t){var e,n,r,i=t.length,o=i>0?t[0].w:0,a=i>0?t[0].h:0;for(this.root={x:0,y:0,w:o,h:a},e=0;e<i;e++)r=t[e],(n=this.findNode(this.root,r.w,r.h))?r.fit=this.splitNode(n,r.w,r.h):r.fit=this.growNode(r.w,r.h);return t}findNode(t,e,n){return t.used?this.findNode(t.right,e,n)||this.findNode(t.down,e,n):e<=t.w&&n<=t.h?t:null}splitNode(t,e,n){return t.used=!0,t.down={x:t.x,y:t.y+n,w:t.w,h:t.h-n},t.right={x:t.x+e,y:t.y,w:t.w-e,h:n},t}growNode(t,e){if(!(this.root.w+t>this.mw||this.root.h+e>this.mh)){var n=t<=this.root.w,r=e<=this.root.h,i=r&&this.root.h>=this.root.w+t,o=n&&this.root.w>=this.root.h+e;return i?this.growRight(t,e):o?this.growDown(t,e):r?this.growRight(t,e):n?this.growDown(t,e):null}console.error("Texture too large.")}growRight(t,e){this.root={used:!0,x:0,y:0,w:this.root.w+t,h:this.root.h,down:this.root,right:{x:this.root.w,y:0,w:t,h:this.root.h}};let n=this.findNode(this.root,t,e);return n?this.splitNode(n,t,e):null}growDown(t,e){this.root={used:!0,x:0,y:0,w:this.root.w,h:this.root.h+e,down:{x:0,y:this.root.h,w:this.root.w,h:e},right:this.root};let n=this.findNode(this.root,t,e);return n?this.splitNode(n,t,e):null}}var q=n("f0e6");class H{constructor(){Object(j["a"])(this,"eventList",{})}dispatchEvent(t,...e){let n=this.eventList[t];n&&n.forEach(t=>{t[0].apply(t[1],e)})}addEventListener(t,e,n){let r=this.eventList[t];r||(r=[],this.eventList[t]=r),r.push([e,n])}removeEventListener(t,e,n){var r=this.eventList[t];if(r)for(var i=r.length,o=i-1;o>=0;o--)r[o][0]==e&&r[o][1]==n&&r.splice(o,1);r&&0==r.length&&(this.eventList[t]=null,delete this.eventList[t])}}const X={MAX_WIDTH:Math.pow(2,11),MAX_HEIGHT:Math.pow(2,11)},K={fontSize:Math.pow(2,7),fontFamily:"Sans-serif",fontWeight:"normal"},Z=Math.pow(2,1);class J{constructor(t){Object(j["a"])(this,"gl",void 0),Object(j["a"])(this,"packer",void 0),Object(j["a"])(this,"blocks",[]),Object(j["a"])(this,"fontMaps",new Map),Object(j["a"])(this,"texture",void 0),this.gl=t;const e=t,n=X.MAX_WIDTH,r=X.MAX_HEIGHT;this.packer=new z(n,r),this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,1),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.texStorage2D(e.TEXTURE_2D,1,e.RGBA8,n,r)}getOriginTexture(){return this.texture}createTexture(t,e,n){t||(t=new Uint8Array(e*n*4),t.fill(0));const r=new $;return r.index=this.blocks.length,this.blocks.push({w:e+Z,h:n+Z,data:{source:t,texture:r}}),this.updateToGL(),r}getFontTexture(t){const e=t.substr(0,1);return""==e?null:(this.fontMaps.has(e)||(this.embedFont(e),this.updateToGL()),this.fontMaps.get(t))}getFontTextures(){return this.fontMaps}embedFont(t){const e=new q(K.fontSize,K.fontSize/8,K.fontSize/3,null,K.fontFamily,K.fontWeight),n=e.size;for(let r=0;r<t.length;r++){let i=t[r];const o=this.fontMaps.get(i);if(o&&o instanceof $)continue;const a=e.draw(i,n);let s=new $;s.index=this.blocks.length,this.blocks.push({w:n+Z,h:n+Z,data:{source:a,texture:s}}),this.fontMaps.set(i,s)}}updateToGL(){this.gl,this.blocks;this.packer.fit(this.blocks);const t=this.blocks.map((t,e)=>t.data.texture).filter(t=>0==t.isReady);t.forEach(t=>this.updateTextureToGL(t))}updateTextureToGL(t){const e=t.index,n=this.blocks[e],r=this.gl,i=Z,o=.5*i,a=n.fit.x+o,s=n.fit.y+o,c=n.w-i,h=n.h-i;t.update(a,s,c,h),r.texSubImage2D(r.TEXTURE_2D,0,a,s,c,h,r.RGBA,r.UNSIGNED_BYTE,n.data.source),t.isReady=!0}copyToTexture(t,e=0,n=0){const r=t.index,i=this.blocks[r],o=this.gl,a=Z,s=.5*a,c=i.fit.x+s,h=i.fit.y+s,u=i.w-a,d=i.h-a;o.copyTexSubImage2D(o.TEXTURE_2D,0,c,h,e,n,u,d)}}const Q={UPDATE:"update"};class $ extends H{constructor(){super(),Object(j["a"])(this,"u",0),Object(j["a"])(this,"v",0),Object(j["a"])(this,"width",0),Object(j["a"])(this,"height",0),Object(j["a"])(this,"index",0),Object(j["a"])(this,"isReady",!1)}update(t,e,n,r,i=-1){const o=X.MAX_WIDTH,a=X.MAX_HEIGHT;this.u=t/o,this.v=e/a,this.width=n/o,this.height=r/a,i>=0&&(this.index=i),this.dispatchEvent(Q.UPDATE,this)}}var tt=n("c83a");tt["vec2"];const et=tt["vec3"];const nt={NONE:0,DISPLAY:1};function rt(t){return new Promise((e,n)=>{const r=new Image;r.onload=()=>e(r),r.src=t})}function it(t){return Promise.all(t.map(t=>rt(t)))}class ot{static createId(){return this.num++,this.num.toString()}}function at(t,e,n,r){const i=et.normalize(et.create(),t),o=et.normalize(et.create(),e);let a=et.add(et.create(),i,o);a=et.normalize(a,a);let s=Math.acos(et.dot(t,e)/(et.length(t)*et.length(e))),c=et.cross(et.create(),i,o),h=Math.sign(c[2]),u=r/Math.sin(.5*s);return a.map((t,e)=>t*u*h+n[e])}function st(t,e,n){return t.map((t,r)=>t+e[r]*n[r])}function ct(t,e,n){return Math.min(e,Math.max(t,n))}Object(j["a"])(ot,"num",0);const ht=tt["mat4"],ut=(tt["vec2"],tt["vec3"]),dt=window.devicePixelRatio,lt={TRANSLATION_CHANGE:"translationChange",SCALE_CHANGE:"scaleChange",SIZE_CHANGE:"sizeChange",ROTATION_CHANGE:"rotationChange"};class vt extends H{constructor(t){super(),Object(j["a"])(this,"_engine",void 0),Object(j["a"])(this,"_gl",void 0),Object(j["a"])(this,"_cvec2",new Float32Array(2)),Object(j["a"])(this,"_vpScaleVec2",new Float32Array(2)),Object(j["a"])(this,"_vpTranslationVec2",new Float32Array(2)),Object(j["a"])(this,"_vpRotation",0),Object(j["a"])(this,"_bgColor",[0,0,0,1]),Object(j["a"])(this,"_vpWidth",void 0),Object(j["a"])(this,"_vpHeight",void 0),Object(j["a"])(this,"tempMat4",ht.create()),Object(j["a"])(this,"tempVec3",ut.create()),Object(j["a"])(this,"scaleMin",.05),Object(j["a"])(this,"scaleMax",2),Object(j["a"])(this,"cvMatIsModified",!0),Object(j["a"])(this,"vpScaleIsModified",!0),Object(j["a"])(this,"vpTranslationIsModified",!0),Object(j["a"])(this,"vpRotationIsModified",!0),this._gl=t.gl,this._engine=t;const e=this._gl.canvas;this.setViewportSize(e.width,e.height),this.reset()}setBackgroundColor(t){this._bgColor=t,this._gl.clearColor.apply(this._gl,t.map(t=>t/255))}getBackgroundColor(){return this._bgColor}setViewportSize(t,e,n=!0){this._vpWidth=t,this._vpHeight=e;const r=this._gl,i=t*dt,o=e*dt;if(r.viewport(0,0,i,o),this._cvec2.set([1/t*2,1/e*2]),this.cvMatIsModified=!0,n){const n=r.canvas;n.width=i,n.height=o,n.style.width=t+"px",n.style.height=e+"px"}this.dispatchEvent(lt.SIZE_CHANGE)}getViewportSize(){return[this._vpWidth,this._vpHeight]}scaleOrigin(t,e,n,r=!0){t=ct(this.scaleMin,this.scaleMax,t);const i=this._vpScaleVec2,o=this._engine.sizeRatio,a=(this.scale-t)*o,s=t/this.scale;i[0]*=s,i[1]*=s;const c=Math.cos(this._vpRotation),h=Math.sin(this._vpRotation);let u=e*c+n*h,d=n*c-e*h;this.translate(u*a,d*a,r),this.vpScaleIsModified=!0,r&&this.dispatchEvent(lt.SCALE_CHANGE)}translate(t,e,n=!0){const r=this._vpWidth,i=this._vpHeight;this._vpTranslationVec2[0]+=t/r*2,this._vpTranslationVec2[1]+=e/i*2,this.vpTranslationIsModified=!0,n&&this.dispatchEvent(lt.TRANSLATION_CHANGE)}rotate(t,e=!0){this._vpWidth,this._vpHeight;this._vpRotation+=t,this.vpRotationIsModified=!0,e&&this.dispatchEvent(lt.ROTATION_CHANGE)}reset(t=!0){this._gl,this._vpWidth,this._vpHeight;this._vpTranslationVec2.set([-1,-1]),this._vpScaleVec2.set([1,1]),this._vpRotation=0,this.vpTranslationIsModified=!0,this.vpScaleIsModified=!0,this.vpRotationIsModified=!0,t&&(this.dispatchEvent(lt.SCALE_CHANGE),this.dispatchEvent(lt.TRANSLATION_CHANGE),this.dispatchEvent(lt.ROTATION_CHANGE))}resetTranslationAndScale(t,e,n=1,r=0,i=0,o=!0){const a=this._engine.sizeRatio;this.reset(!1),this.translate(t*a,e*a,!1),this.scaleOrigin(n,r,i,!1),o&&(this.dispatchEvent(lt.SCALE_CHANGE),this.dispatchEvent(lt.TRANSLATION_CHANGE),this.dispatchEvent(lt.ROTATION_CHANGE))}get scale(){return this._vpScaleVec2[0]}get translation(){const t=this._vpTranslationVec2,e=this._engine.sizeRatio,n=this.scale*e;return[(t[0]+1)*this._vpWidth*.5/n,(t[1]+1)*this._vpHeight*.5/n]}set scaleRange(t){this.scaleMin=t[0],this.scaleMax=t[1]}get scaleRange(){return[this.scaleMin,this.scaleMax]}changeCoordinateFromScreen(t,e){const n=this.tempVec3,r=this.tempMat4,i=this._engine;ht.identity(r),n.set([this._vpTranslationVec2[0],this._vpTranslationVec2[1],0]),ht.translate(r,r,n),n.set([this._vpScaleVec2[0]*i.sizeRatio,this._vpScaleVec2[1]*i.sizeRatio,1]),ht.scale(r,r,n),n.set([this._cvec2[0],this._cvec2[1],1]),ht.scale(r,r,n),ht.rotateZ(r,r,-this._vpRotation),ht.invert(r,r);const o=this._vpWidth/2,a=this._vpHeight/2;return n.set([t/o-1,-e/a+1,0]),ut.transformMat4(n,n,r),n.subarray(0,2)}get cvec2(){return this._cvec2}get vpScaleVec2(){return this._vpScaleVec2}get vpTranslationVec2(){return this._vpTranslationVec2}get vpRotation(){return this._vpRotation}}tt["glMatrix"].setMatrixArrayType(Float32Array);class ft{constructor(t){if(Object(j["a"])(this,"_gl",void 0),Object(j["a"])(this,"_prg",void 0),Object(j["a"])(this,"_searcher",void 0),Object(j["a"])(this,"_tf",void 0),Object(j["a"])(this,"_vp",void 0),Object(j["a"])(this,"_unitList",void 0),Object(j["a"])(this,"_vpScaleLocal",void 0),Object(j["a"])(this,"_vpTranslationLocal",void 0),Object(j["a"])(this,"_vecLocal",void 0),Object(j["a"])(this,"_vpRotationLocal",void 0),Object(j["a"])(this,"_sizeRatio",1),Object(j["a"])(this,"isDebug",!0),Object(j["a"])(this,"canRending",!0),this._gl=t.getContext("webgl2",{alpha:!1,premultiplyAlpha:!1,antialias:!0}),!this._gl)throw Error("not support WebGL2");this._unitList=[],this._searcher=new G,this._tf=new J(this._gl),this._vp=new vt(this),this.initPrg(),window["unitlist"]=this._unitList}get gl(){return this._gl}get prg(){return this._prg}get searcher(){return this._searcher}get textureFactroy(){return this._tf}get viewport(){return this._vp}get sizeRatio(){return this._sizeRatio}set sizeRatio(t){this._sizeRatio=t,this._vp.vpScaleIsModified=!0}initPrg(){let t=this.gl;const e=this.loadShader(t,t.VERTEX_SHADER,U),n=this.loadShader(t,t.FRAGMENT_SHADER,F);this._prg=t.createProgram(),t.attachShader(this._prg,e),t.attachShader(this._prg,n),t.linkProgram(this._prg),t.getProgramParameter(this._prg,t.LINK_STATUS)||alert("Could not initialise shaders"),t.useProgram(this._prg),t.enable(t.BLEND),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_DST_COLOR),this._vpScaleLocal=t.getUniformLocation(this._prg,"uViewportScale"),this._vpTranslationLocal=t.getUniformLocation(this._prg,"uViewportTranslation"),this._vpRotationLocal=t.getUniformLocation(this._prg,"uViewportRotation"),this._vecLocal=t.getUniformLocation(this._prg,"uConversionVec2")}loadShader(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)?r:(alert("An error occurred compiling the shaders: "+t.getShaderInfoLog(r)),t.deleteShader(r),null)}render(){this.canRending&&(this.draw(),window.requestAnimationFrame(()=>this.render()))}draw(t=null,e=!1){const n=this.gl,r=this.updateViewport(),i=this.updateConversionVec();let o=!1,a=[];const s=this._unitList;a=t&&t.length>0?t.map(t=>s[t]):s,a.forEach(t=>{t.forEach(t=>{t.updateToGL()&&(o=!0)})}),(e||r||i||o)&&(n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),a.forEach(t=>{t.filter(t=>t.display==nt.DISPLAY).forEach(t=>{t.updateUniform(),t.draw()})}))}updateViewport(){const t=this.gl;let e=!1;return this._vp.vpScaleIsModified&&(t.uniform2fv(this._vpScaleLocal,this._vp.vpScaleVec2.map(t=>t*this._sizeRatio)),this._vp.vpScaleIsModified=!1,e=!0),this._vp.vpTranslationIsModified&&(t.uniform2fv(this._vpTranslationLocal,this._vp.vpTranslationVec2),this._vp.vpTranslationIsModified=!1,e=!0),this._vp.vpRotationIsModified&&(t.uniform1f(this._vpRotationLocal,this._vp.vpRotation),this._vp.vpRotationIsModified=!1,e=!0),e}updateConversionVec(){if(this._vp.cvMatIsModified){const t=this.gl;return t.uniform2fv(this._vecLocal,this._vp.cvec2),this._vp.cvMatIsModified=!1,!0}return!1}registVAO(t,e=0){return this._unitList[e]||(this._unitList[e]=[]),this._unitList[e].push(t),t}unRegistVAO(t,e=0){if(e>=this._unitList.length)return;const n=this._unitList[e].indexOf(t);n<0||this._unitList[e].splice(n,1)}}const _t={TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class pt{constructor(t,e,n,r,i){Object(j["a"])(this,"_vertexes",void 0),Object(j["a"])(this,"_offsetRatios",void 0),Object(j["a"])(this,"_uv",void 0),Object(j["a"])(this,"_indeces",void 0),Object(j["a"])(this,"_primitiveMode",void 0),this._vertexes=e,this._offsetRatios=n,this._uv=r,this._indeces=i,this._primitiveMode=t}get currVertexes(){return this._vertexes}get prevVertexes(){let t=this._vertexes;return t.slice(-2).concat(t.slice(0,t.length-2))}get nextVertexes(){let t=this._vertexes;return t.slice(2).concat(t.slice(0,2))}get currOffsetRatios(){return this._offsetRatios}get prevOffsetRatios(){let t=this._offsetRatios;return t.slice(-2).concat(t.slice(0,t.length-2))}get nextOffsetRatios(){let t=this._offsetRatios;return t.slice(2).concat(t.slice(0,2))}get originMeshConfig(){let t=new Array(this._vertexes.length);return t.fill(0),{currVertexes:this.currVertexes,prevVertexes:this.prevVertexes,nextVertexes:this.nextVertexes,currOffsetRatios:this.currOffsetRatios,prevOffsetRatios:this.prevOffsetRatios,nextOffsetRatios:this.nextOffsetRatios,edgeOffsetRatios:t,indeces:this._indeces,uvs:this._uv,primitiveMode:this._primitiveMode}}get borderMeshConfig(){let t=this.currVertexes.length,e=this.currVertexes,n=this.prevVertexes,r=this.nextVertexes,i=this.currOffsetRatios,o=this.prevOffsetRatios,a=this.nextOffsetRatios,s=new Array(2*t),c=new Array;s.fill(0);let h=new Array(t/2);h.fill(0);let u=new Array(t/2);u.fill(1);let d=h.concat(u);t/=2;for(let l=0;l<t;l++)c[2*l]=l,c[2*l+1]=t+l;return c.push(c[0],c[1]),e=e.concat(e),n=n.concat(n),r=r.concat(r),i=i.concat(i),o=o.concat(o),a=a.concat(a),{currVertexes:e,prevVertexes:n,nextVertexes:r,currOffsetRatios:i,prevOffsetRatios:o,nextOffsetRatios:a,edgeOffsetRatios:d,indeces:c,uvs:s,primitiveMode:_t.TRIANGLE_STRIP}}}class bt extends pt{constructor(t=0,e=0){const n=[0,0,0,0,0,0,0,0];let r=[-.5,.5,-.5,-.5,.5,-.5,.5,.5];const i=[0,1,0,0,1,0,1,1],o=[0,1,3,2];r=r.map((n,r)=>r%2==0?n-t:n-e),super(_t.TRIANGLE_STRIP,n,r,i,o)}}class gt extends pt{constructor(t=20,e=20){const n=[-.2,0,.2,0,.2,0,.5,0,0,1,-.5,0,-.2,0].map((n,r)=>r%2==0?n*t:n*e),r=[0,0,0,0,0,1,0,1,0,1,0,1,0,1],i=new Array(n.length),o=[0,1,6,2,5,3,4];super(_t.TRIANGLE_STRIP,n,r,i,o)}}class At extends pt{constructor(t=20,e=20){const n=[0,0,.5,1,.2,1,.2,1,.5,1,0,2,-.5,1,-.2,1,-.2,1,-.5,1].map((n,r)=>r%2==0?n*t:n*e),r=[0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0],i=new Array(n.length),o=[0,1,9,2,8,3,7,4,6,5];super(_t.TRIANGLE_STRIP,n,r,i,o)}}const mt=3e3,xt=tt["mat4"],Mt=tt["vec3"],Ot={CURR_VERTEX_AND_RATIO:"currVertexAndRatio",NEXT_VERTEX_AND_RATIO:"nextVertexAndRatio",PREV_VERTEX_AND_RATIO:"prevVertexAndRatio",UV_AND_EDGE_OFFSET_RATIO:"uvAndEdgeOffsetRatio"};var wt=new Map;wt.set(Ot.CURR_VERTEX_AND_RATIO,4),wt.set(Ot.NEXT_VERTEX_AND_RATIO,4),wt.set(Ot.PREV_VERTEX_AND_RATIO,4),wt.set(Ot.UV_AND_EDGE_OFFSET_RATIO,4);const Tt={VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT:"vertexAndEdgeOffsetValueAndNotFollowViewport",BACKGROUND_COLOR:"backgroundColor",UV_RECT:"UVRect",TRANSLATION_AND_ROTATION:"translationAndRotation",IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE:"isTextAndBorderWidthAndDashedAndScale",TEXT_BORDER_COLOR:"textBorderColor",OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS:"opacityAndDisplayAndVpScaleAndVpTrans"};var Et=new Map;Et.set(Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,4),Et.set(Tt.BACKGROUND_COLOR,4),Et.set(Tt.UV_RECT,4),Et.set(Tt.TRANSLATION_AND_ROTATION,4),Et.set(Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,4),Et.set(Tt.TEXT_BORDER_COLOR,4),Et.set(Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,4);const Rt=[Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,Tt.BACKGROUND_COLOR,Tt.UV_RECT,Tt.TRANSLATION_AND_ROTATION,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,Tt.TEXT_BORDER_COLOR,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS],Vt={OPACITY:"uOpacity"},yt=[Vt.OPACITY];class St{constructor(t,e,n=0){Object(j["a"])(this,"_engine",void 0),Object(j["a"])(this,"idmap",void 0),Object(j["a"])(this,"idlist",void 0),Object(j["a"])(this,"_meshConfig",void 0),Object(j["a"])(this,"vao",void 0),Object(j["a"])(this,"instanceCount",0),Object(j["a"])(this,"instanceCountMax",0),Object(j["a"])(this,"instanceCountInited",0),Object(j["a"])(this,"attribBuffers",new Map),Object(j["a"])(this,"attribBufferDatas",new Map),Object(j["a"])(this,"attribIsModifieds",new Map),Object(j["a"])(this,"attribLocals",new Map),Object(j["a"])(this,"uniformLocals",new Map),Object(j["a"])(this,"uniformDatas",new Map),Object(j["a"])(this,"_display",nt.DISPLAY),Object(j["a"])(this,"displayIsModified",!1),this._engine=t,this._meshConfig=e;const r=t.gl,i=t.prg,o=Math.floor(n);this.instanceCountMax=o>0?o:mt,this.instanceCountInited=this.instanceCountMax,Rt.forEach(t=>{const e=new Float32Array(this.instanceCountMax*Et.get(t));this.attribBuffers.set(t,r.createBuffer()),this.attribBufferDatas.set(t,e),this.attribIsModifieds.set(t,!0),this.attribLocals.set(t,r.getAttribLocation(i,t))}),yt.forEach(t=>{this.uniformLocals.set(t,r.getUniformLocation(i,t)),this.uniformDatas.set(t,new Float32Array(4))}),this.uniformDatas.set(Vt.OPACITY,new Float32Array([1,0,0,0])),this.idmap=new Map,this.idlist=[]}regist(){const t=this._engine.gl,e=this._meshConfig,n=e.currVertexes,r=e.prevVertexes,i=e.nextVertexes,o=e.currOffsetRatios,a=e.prevOffsetRatios,s=e.nextOffsetRatios,c=n.length/2,h=[],u=[],d=[],l=[],v=e.uvs,f=e.edgeOffsetRatios;for(let _=0;_<c;_++)h.push(n[2*_],n[2*_+1],o[2*_],o[2*_+1]),u.push(r[2*_],r[2*_+1],a[2*_],a[2*_+1]),d.push(i[2*_],i[2*_+1],s[2*_],s[2*_+1]),l.push(v[2*_],v[2*_+1],f[_],0);return this.vao=t.createVertexArray(),t.bindVertexArray(this.vao),this.registAttribute(Ot.CURR_VERTEX_AND_RATIO,new Float32Array(h)),this.registAttribute(Ot.PREV_VERTEX_AND_RATIO,new Float32Array(u)),this.registAttribute(Ot.NEXT_VERTEX_AND_RATIO,new Float32Array(d)),this.registAttribute(Ot.UV_AND_EDGE_OFFSET_RATIO,new Float32Array(l)),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint32Array(this._meshConfig.indeces),t.STATIC_DRAW),t.bindVertexArray(null),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),this}updateToGL(){const t=this._engine.gl;let e=this.displayIsModified;return t.bindVertexArray(this.vao),Rt.forEach(t=>{!0===this.attribIsModifieds.get(t)&&(this.updateBufferToGL(t,this.attribBuffers.get(t),this.attribBufferDatas.get(t),Et.get(t)),this.attribIsModifieds.set(t,!1),e=!0)}),this.displayIsModified=!1,e}updateUniform(){const t=this.engine.gl;yt.forEach(e=>{t.uniform4fv(this.uniformLocals.get(e),this.uniformDatas.get(e))})}setAttribute(t,e,n,r=0){if(!t||""==t)return;const i=this.idmap.get(t),o=Et.get(e);let a;a=this.attribBufferDatas.get(e),this.attribIsModifieds.set(e,!0),a.set(n.slice(0,o-r),i*o+r)}getAttribute(t,e,n=0,r=0){const i=this.idmap.get(t),o=Et.get(e);let a;a=this.attribBufferDatas.get(e),this.attribIsModifieds.set(e,!0);const s=i*o+n;let c;return c=r>0?Math.min(s+r,(i+1)*o):(i+1)*o,Array.from(a.subarray(s,c))}add(){this.instanceCount==this.instanceCountMax&&this.grow();const t=this.createId(),e=this.instanceCount;return this.idmap.set(t,e),this.idlist[e]=t,this.instanceCount++,Rt.forEach(t=>this.attribIsModifieds.set(t,!0)),t}remove(t){const e=this.idmap.get(t),n=this.instanceCount;if(n<1||e<0||e>=n)return;Rt.forEach(e=>{this.removeAttributeBufferData(t,e),this.attribIsModifieds.set(e,!0)});const r=this.idlist[this.instanceCount-1];this.idmap.set(r,e),this.idlist[e]=r,this.idmap.delete(t),this.idlist.pop(),this.instanceCount--}clear(){if(this.instanceCountMax>this.instanceCountInited){const t=this.instanceCountMax/this.instanceCountInited;Rt.forEach(e=>{const n=this.attribBufferDatas.get(e).length;this.attribBufferDatas.set(e,new Float32Array(n/t))}),this.instanceCountMax=this.instanceCountInited}else this.attribBufferDatas.forEach(t=>t.fill(0));this.attribIsModifieds.forEach((t,e)=>this.attribIsModifieds.set(e,!0)),this.idmap.clear(),this.idlist=[],this.instanceCount=0}fill(t,e){this.attribBufferDatas.get(t).fill(e),this.attribIsModifieds.set(t,!0)}batchSet(t,e,n=0){const r=Et.get(t);if(r<=n)return;const i=this.attribBufferDatas.get(t),o=this.instanceCount,a=e.slice(0,r-n);let s=n;for(let c=0;c<o;c++)i.set(a,s),s+=r;this.attribIsModifieds.set(t,!0)}batchAdd(t,e,n=0){const r=Et.get(t);if(r<=n)return;const i=this.attribBufferDatas.get(t),o=this.instanceCount,a=e.slice(0,r-n),s=a.length;let c=n;for(let h=0;h<o;h++){for(let t=0;t<s;t++)i[c+t]+=a[t];c+=r}this.attribIsModifieds.set(t,!0)}destroy(){this.attribBuffers.clear(),this.attribBufferDatas.clear(),this.attribIsModifieds.clear(),this.idmap.clear(),this.idlist=[],this.instanceCount=0,this.vao=null}draw(){const t=this._engine.gl,e=this._meshConfig;t.bindVertexArray(this.vao),t.drawElementsInstanced(e.primitiveMode,e.indeces.length,t.UNSIGNED_INT,0,this.instanceCount)}set display(t){this._display=t}get display(){return this._display}set opacity(t){const e=Math.max(0,t),n=this.uniformDatas.get(Vt.OPACITY);n.set([e],0),this.displayIsModified=!0}get opacity(){return this.uniformDatas.get(Vt.OPACITY)[0]}get engine(){return this._engine}getVertexesPositionById(t,e=0){let n=this._meshConfig.currVertexes;const r=this._meshConfig.currOffsetRatios,i=this.getAttribute(t,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,0,2),o=this.getAttribute(t,Tt.TRANSLATION_AND_ROTATION,0,2),a=this.getAttribute(t,Tt.TRANSLATION_AND_ROTATION,2,1)[0],s=n.length/2;let c=xt.create();xt.fromZRotation(c,-a);let h=[];for(let d=0;d<s;d++){const t=Mt.fromValues(n[2*d],n[2*d+1],0),e=Mt.fromValues(r[2*d],r[2*d+1],0);let o=st(t,e,Mt.fromValues(i[0],i[1],0));h.push(o)}const u=[];for(let d=0;d<s;d++){let t=0==d?s-1:d-1,n=d==s-1?0:d+1;const r=h[t],i=h[d],a=h[n],l=r.map((t,e)=>t-i[e]),v=a.map((t,e)=>t-i[e]);let f=at(l,v,i,e);Mt.transformMat4(f,f,c),Mt.add(f,f,Mt.fromValues(o[0],o[1],0)),u.push(f[0],f[1])}return u}createId(){return ot.createId()}registAttribute(t,e){const n=this.engine.gl,r=this.engine.prg,i=n.createBuffer(),o=wt.get(t),a=n.getAttribLocation(r,t);n.bindBuffer(n.ARRAY_BUFFER,i),n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW),n.vertexAttribPointer(a,o,n.FLOAT,!1,0,0),n.enableVertexAttribArray(a)}updateBufferToGL(t,e,n,r,i=0){const o=this._engine.gl,a=(this._engine.prg,n.BYTES_PER_ELEMENT),s=this.attribLocals.get(t),c=this.instanceCount;o.bindBuffer(o.ARRAY_BUFFER,e),o.bufferData(o.ARRAY_BUFFER,n,o.DYNAMIC_DRAW,0,c*r),o.enableVertexAttribArray(s),o.vertexAttribPointer(s,r,o.FLOAT,!1,r*a,i*a),o.vertexAttribDivisor(s,1),o.bindBuffer(o.ARRAY_BUFFER,null)}removeAttributeBufferData(t,e){const n=this.idmap.get(t),r=this.attribBufferDatas.get(e),i=Et.get(e),o=Math.max(1,this.instanceCount-1),a=new Array(i);a.fill(0),r.set(r.slice(o*i,(o+1)*i),n*i),r.set(a,o*i)}grow(){Rt.forEach(t=>{let e=this.attribBufferDatas.get(t),n=new Float32Array(2*e.length);n.set(e),this.attribBufferDatas.set(t,n),e=null}),this.instanceCountMax*=2}}const Dt=window.devicePixelRatio,Nt={NONE:0,X:1,Y:2,BOTH:3};class It extends k{constructor(t,e){super(t.engine.searcher),Object(j["a"])(this,"_id",void 0),Object(j["a"])(this,"_originUnit",void 0),Object(j["a"])(this,"_borderUnit",void 0),Object(j["a"])(this,"_originId",void 0),Object(j["a"])(this,"_borderId",void 0),Object(j["a"])(this,"_isAdded",void 0),Object(j["a"])(this,"_isBorderAdded",void 0),Object(j["a"])(this,"_texture",void 0),Object(j["a"])(this,"_needReset",!1),Object(j["a"])(this,"_attribs",{translation:[0,0],rotation:0,scale:1,backgroundColor:[0,0,0,0],uv:null,vertexOffsetValue:[0,0],isText:!1,textBorderWidth:0,textBorderColor:[0,0,0,0],borderWidth:0,borderColor:[0,0,0,0],borderDashed:0,opacity:1,display:nt.DISPLAY,outViewportStatus:Nt.NONE,attachViewportScale:!0,attachViewportTranslation:!0}),Object(j["a"])(this,"_attriblist",["vertexOffsetValue","translation","rotation","scale","backgroundColor","uv","borderWidth","borderColor","borderDashed","isText","textBorderWidth","textBorderColor","opacity","display","outViewportStatus","attachViewportScale","attachViewportTranslation"]),this._originUnit=t,this._borderUnit=e,this._id=ot.createId()}get id(){return this._id}get engine(){return this._originUnit.engine}get isShown(){return this._isAdded}show(){return this._isAdded||(this._originId=this._originUnit.add(),this._isAdded=!0,this.updateStatus(),this.searchable&&this.registToSearcher()),this.borderWidth=this.borderWidth,this}hide(){return this._isAdded&&this._originUnit.remove(this._originId),this._isBorderAdded&&this._borderUnit.remove(this._borderId),this._isAdded=!1,this._isBorderAdded=!1,this._originId=null,this._borderId=null,this.deregistToSearcher(),this}set translation(t){this._isAdded&&this._originUnit.setAttribute(this._originId,Tt.TRANSLATION_AND_ROTATION,t,0),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,Tt.TRANSLATION_AND_ROTATION,t,0),this._attribs["translation"]=t,this.searchable&&this.registToSearcher()}get translation(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.TRANSLATION_AND_ROTATION,0,2):this._attribs["translation"]}set rotation(t){const e=[t];this._isAdded&&this._originUnit.setAttribute(this._originId,Tt.TRANSLATION_AND_ROTATION,e,2),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,Tt.TRANSLATION_AND_ROTATION,e,2),this._attribs["rotation"]=t,this.searchable&&this.registToSearcher()}get rotation(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.TRANSLATION_AND_ROTATION,2,1)[0]:this._attribs["rotation"]}set scale(t){const e=[t];this._isAdded&&this._originUnit.setAttribute(this._originId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,e,3),this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,e,3),this._attribs["scale"]=t,this.searchable&&this.registToSearcher()}get scale(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,3,1)[0]:this._attribs["scale"]}set backgroundColor(t){const e=t.map(t=>t/255);this._isAdded&&this._originUnit.setAttribute(this._originId,Tt.BACKGROUND_COLOR,e),this._attribs["backgroundColor"]=t}get backgroundColor(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.BACKGROUND_COLOR,0,4).map(t=>255*t):this._attribs["backgroundColor"]}set texture(t){if(null==t)return this._texture&&this._texture instanceof $&&(this._texture.removeEventListener(Q.UPDATE,this.changeUV,this),this._texture=null),void this.changeUV(null);if(!(t instanceof $))return;const e=this._texture,n=t;(this._needReset||e!=n)&&(e instanceof $&&e.removeEventListener(Q.UPDATE,this.changeUV,this),this._texture=t,this.changeUV(this._texture),this._texture.addEventListener(Q.UPDATE,this.changeUV,this))}set borderWidth(t){if(this._isBorderAdded&&t==this._attribs.borderWidth)return;this._attribs["borderWidth"]=t;const e=[t];this._isBorderAdded?t>0?this._borderUnit.setAttribute(this._borderId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,e,2):this.removeBorder():t>0&&this.addBorder()}get borderWidth(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,2,1)[0]:this._attribs["borderWidth"]}set borderColor(t){const e=t.map(t=>t/255);this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,Tt.BACKGROUND_COLOR,e),this._attribs["borderColor"]=t}get borderColor(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,Tt.BACKGROUND_COLOR,0,4).map(t=>255*t):this._attribs["borderColor"]}set borderDashed(t){this._isBorderAdded&&this._borderUnit.setAttribute(this._borderId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[t*Dt],2),this._attribs.borderDashed=t}get borderDashed(){return this._isBorderAdded?this._borderUnit.getAttribute(this._borderId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,2,1)[0]:this._attribs.borderDashed}set vertexOffsetValue(t){this._originUnit.setAttribute(this._originId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,t),this._borderUnit.setAttribute(this._borderId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,t),this._attribs["vertexOffsetValue"]=t,this.searchable&&this.registToSearcher()}get vertexOffsetValue(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,0,2):this._attribs["vertexOffsetValue"]}set size(t){this.vertexOffsetValue=t}get size(){return this.vertexOffsetValue}set isText(t){let e=t?1:0;const n=[e];this._originUnit.setAttribute(this._originId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,n,0),this._attribs["isText"]=t}get isText(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,0,1)[0]:this._attribs["isText"]}set textBorderWidth(t){const e=[t];this._originUnit.setAttribute(this._originId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,e,1),this._attribs["textBorderWidth"]=t}get textBorderWidth(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,1,1)[0]:this._attribs["textBorderWidth"]}set textBorderColor(t){this._originUnit.setAttribute(this._originId,Tt.TEXT_BORDER_COLOR,t.map(t=>t/255)),this._attribs["textBorderColor"]=t}get textBorderColor(){return this._attribs["textBorderColor"]}set opacity(t){const e=Math.max(0,t),n=[e];this._originUnit.setAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,0),this._borderUnit.setAttribute(this._borderId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,0),this._attribs["opacity"]=e}get opacity(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,0,1)[0]:this._attribs["opacity"]}set display(t){const e=[t];this._originUnit.setAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,1),this._borderUnit.setAttribute(this._borderId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,e,1),this._attribs["display"]=t}get display(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,1)[0]:this._attribs["display"]}set outViewportStatus(t){const e=[t];this._originUnit.setAttribute(this._originId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,e,3),this._borderUnit.setAttribute(this._borderId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,e,3),this._attribs["outViewportStatus"]=t}get outViewportStatus(){return this._isAdded?this._originUnit.getAttribute(this._originId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,3,1)[0]:this._attribs["outViewportStatus"]}set attachViewportScale(t){const e=t?1:0,n=[e];this._originUnit.setAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,2),this._borderUnit.setAttribute(this._borderId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,2),this._attribs["attachViewportScale"]=t}get attachViewportScale(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,2,1)[0]:this._attribs["attachViewportScale"]}set attachViewportTranslation(t){const e=t?1:0,n=[e];this._originUnit.setAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,3),this._borderUnit.setAttribute(this._borderId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,n,3),this._attribs["attachViewportTranslation"]=t}get attachViewportTranslation(){return this._isAdded?1==this._originUnit.getAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,3,1)[0]:this._attribs["attachViewportTranslation"]}getVertexPositions(t=0){return this._originUnit.getVertexesPositionById(this._originId,t)}changeUV(t){if(t&&t instanceof $){const e=[t.u,t.v,t.width,t.height];this._isAdded&&this._originUnit.setAttribute(this._originId,Tt.UV_RECT,e),this._attribs["uv"]=e}else this._isAdded&&this._originUnit.setAttribute(this._originId,Tt.UV_RECT,[0,0,0,0])}updateStatus(){this._needReset=!0;this._attriblist;const t=this._attribs;this._isAdded&&(this._originUnit.setAttribute(this._originId,Tt.TRANSLATION_AND_ROTATION,[t["translation"][0],t["translation"][1],t["rotation"]]),this._originUnit.setAttribute(this._originId,Tt.BACKGROUND_COLOR,t["backgroundColor"].map(t=>t/255)),this._originUnit.setAttribute(this._originId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[t["isText"]?1:0,0,0,t["scale"]]),this._originUnit.setAttribute(this._originId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,[t["opacity"],t["display"],t["attachViewportScale"]?1:0,t["attachViewportTranslation"]?1:0]),this._originUnit.setAttribute(this._originId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,[t["vertexOffsetValue"][0],t["vertexOffsetValue"][1],t["borderWidth"],t["outViewportStatus"]])),this.changeUV(this._texture),this._needReset=!1}addBorder(){this._isBorderAdded||(this._borderId=this._borderUnit.add(),this._borderUnit.setAttribute(this._borderId,Tt.TRANSLATION_AND_ROTATION,[this.translation[0],this.translation[1],this.rotation],0),this._borderUnit.setAttribute(this._borderId,Tt.VERTEX_AND_EDGE_OFFSET_VALUE_AND_NOT_FOLLOW_VIEWPORT,[this.vertexOffsetValue[0],this.vertexOffsetValue[1],this.borderWidth,this.outViewportStatus],0),this._borderUnit.setAttribute(this._borderId,Tt.BACKGROUND_COLOR,this.borderColor.map(t=>t/255),0),this._borderUnit.setAttribute(this._borderId,Tt.IS_TEXT_AND_BORDER_WIDTH_AND_DASHED_AND_SCALE,[this.borderDashed*Dt,this.scale],2),this._borderUnit.setAttribute(this._borderId,Tt.OPACITY_AND_DISPLAY_AND_VPSCALE_AND_VPTRANS,[this.opacity,this.display,this.attachViewportScale?1:0,this.attachViewportTranslation?1:0],0),this._isBorderAdded=!0)}removeBorder(){this._isBorderAdded&&(this._borderUnit.remove(this._borderId),this._borderId=void 0,this._isBorderAdded=!1)}}const Pt=tt["vec2"],Ct={ONE_WAY:1,TWO_WAY:2};class Lt extends k{constructor(t,e,n,r=0){super(t.engine.searcher),Object(j["a"])(this,"_type",Ct.ONE_WAY),Object(j["a"])(this,"_id",void 0),Object(j["a"])(this,"_height",void 0),Object(j["a"])(this,"_indent",void 0),Object(j["a"])(this,"_fromTo",[0,0,0,0]),Object(j["a"])(this,"_oneObj",void 0),Object(j["a"])(this,"_twoObj",void 0),Object(j["a"])(this,"_isShown",!1),this._id=ot.createId(),this._oneObj=t,this._twoObj=e,this._height=n,this._indent=r}get robj(){return this._type==Ct.ONE_WAY?this._oneObj:this._twoObj}get nobj(){return this._type==Ct.TWO_WAY?this._oneObj:this._twoObj}get id(){return this._id}get isShown(){return this._isShown}show(){return this._isShown||(this.robj.show(),this.nobj.hide(),this.setFromToAndWidth(),this._isShown=!0),this}hide(){return this._isShown?(this.robj.hide(),this._isShown=!1,this.deregistToSearcher(),this):this}get rid(){return this.robj.id}set fromTo(t){this._fromTo=t,this.setFromToAndWidth()}get fromTo(){return this._fromTo}set type(t){t!=this._type&&(this._type=t,this.nobj.hide(),this._isShown&&(this.robj.show(),this.borderWidth=this.nobj.borderWidth,this.borderColor=this.nobj.borderColor,this.borderDashed=this.nobj.borderDashed,this.opacity=this.nobj.opacity,this.display=this.nobj.display,this.backgroundColor=this.nobj.backgroundColor,this.outViewportStatus=this.nobj.outViewportStatus,this.attachViewportScale=this.nobj.attachViewportScale,this.attachViewportTranslation=this.nobj.attachViewportTranslation,this.setFromToAndWidth()))}get type(){return this._type}set backgroundColor(t){this.robj.backgroundColor=t}get backgroundColor(){return this.robj.backgroundColor}set borderWidth(t){this.robj.borderWidth=t}get borderWidth(){return this.robj.borderWidth}set borderColor(t){this.robj.borderColor=t}get borderColor(){return this.robj.borderColor}set borderDashed(t){this.robj.borderDashed=t}get borderDashed(){return this.robj.borderDashed}set opacity(t){this.robj.opacity=t}get opacity(){return this.robj.opacity}set display(t){this.robj.display=t}get display(){return this.robj.display}set outViewportStatus(t){this.robj.outViewportStatus=t}get outViewportStatus(){return this.robj.outViewportStatus}set attachViewportScale(t){this.robj.attachViewportScale=t}get attachViewportScale(){return this.robj.attachViewportScale}set attachViewportTranslation(t){this.robj.attachViewportTranslation=t}get attachViewportTranslation(){return this.robj.attachViewportTranslation}setFromToAndWidth(){const t=this._fromTo,e=this._indent,n=Pt.fromValues(t[0],t[1]),r=Pt.fromValues(t[2],t[3]),i=Pt.sub(Pt.create(),r,n),o=Pt.normalize(Pt.create(),i),a=Pt.len(i)-2*e,s=Pt.add(Pt.create(),o.map(t=>t*e),n),c=Math.atan2(i[0],i[1]);let h;h=this.type==Ct.ONE_WAY?Math.max(0,a-this._height):Math.max(0,a-2*this._height),this.robj.translation=s,this.robj.rotation=c,this.robj.vertexOffsetValue=[0,h],this.searchable&&this.registToSearcher()}getVertexPositions(t=0){return this.robj.getVertexPositions(t)}}class Bt{constructor(t,e,n=0,r=1,i=0){Object(j["a"])(this,"_engine",void 0),Object(j["a"])(this,"originUnit",void 0),Object(j["a"])(this,"borderUnit",void 0),Object(j["a"])(this,"originIdx",void 0),Object(j["a"])(this,"borderIdx",void 0),this._engine=t,this.originIdx=Math.floor(n),this.borderIdx=Math.floor(r),this.originUnit=new St(t,e.originMeshConfig,i).regist(),this.borderUnit=new St(t,e.borderMeshConfig,i).regist(),this.engine.registVAO(this.originUnit,this.originIdx),this.engine.registVAO(this.borderUnit,this.borderIdx)}instance(){return new It(this.originUnit,this.borderUnit)}destroy(){this.engine.unRegistVAO(this.originUnit,this.originIdx),this.engine.unRegistVAO(this.borderUnit,this.borderIdx),this.originUnit.destroy(),this.borderUnit.destroy(),this.originUnit=null,this.borderUnit=null}clear(){this.originUnit.clear(),this.borderUnit.clear()}set opacity(t){this.originUnit.opacity=t,this.borderUnit.opacity=t}set display(t){this.originUnit.display=t,this.borderUnit.display=t}set translate(t){this.originUnit.batchAdd(Tt.TRANSLATION_AND_ROTATION,t,0),this.borderUnit.batchAdd(Tt.TRANSLATION_AND_ROTATION,t,0)}get engine(){return this._engine}}class jt{constructor(t,e,n,r=0,i=0,o=1,a=0){Object(j["a"])(this,"_engine",void 0),Object(j["a"])(this,"og",void 0),Object(j["a"])(this,"tg",void 0),Object(j["a"])(this,"_height",void 0),Object(j["a"])(this,"_indent",void 0),this._engine=t,this.og=new Bt(t,new gt(e,n),i,o,a),this.tg=new Bt(t,new At(e,n),i,o,a),this._height=n,this._indent=r}instance(){return new Lt(this.og.instance(),this.tg.instance(),this._height,this._indent)}destroy(){this.og.destroy(),this.tg.destroy(),this.og=null,this.tg=null}clear(){this.og.clear(),this.tg.clear()}set translate(t){this.og.translate=t,this.tg.translate=t}set display(t){this.og.display=t,this.tg.display=t}set opacity(t){this.og.opacity=t,this.tg.opacity=t}get engine(){return this._engine}}function Ut(){return[255*Math.random(),255*Math.random(),255*Math.random(),255]}const Ft=n("8554"),Yt=n("405a"),Wt=n("11d9"),Gt=n("bafb");var kt={name:"xxx",components:{},data(){return{arrowType:1,vpOffsetX:0,vpOffsetY:0,vpOx:0,vpOy:0,vpScaleRatio:1}},mounted(){this.initCtx()},methods:{initCtx(){const t=document.getElementById("canvas");let e=new ft(t);e.isDebug=!1,e.sizeRatio=1;e.searcher;let n=e.textureFactroy,r=e.viewport;r.setBackgroundColor([186,186,186,255]),window.vp=r,window.engine=e;let i=[];console.log("engine",e),it([Ft,Yt,Wt,Gt]).then(t=>{i=t.map(t=>{n.createTexture(t,t.width,t.height)}),window.textures=i,this.initRender(e,i)})},initRender(t,e){t.render()},handleClear(){window.g1&&window.g1.clear(),window.g2&&window.g2.clear(),window.g3&&window.g3.clear()},handleSetVp(){const t=+this.vpOffsetX,e=+this.vpOffsetY,n=+this.vpScaleRatio,r=+this.vpOx,i=+this.vpOy;window["vp"].resetTranslationAndScale(t,e,n,r,i),console.log(window["vp"])},handleDrawArrow(){1==this.arrowType?this.drawOneWayArrow():this.drawTwoWayArrow()},handleDrawRect(){this.drawRects(window.engine,window.textures[0],10,0,0,600)},drawRects(t,e,n,r,i,o){const a=new bt,s=new Bt(t,a);window.g1=s;const c=n,h=o/c;for(let u=0;u<c;u++)for(let t=0;t<c;t++){let n=Ut();n[3]=200;let o=s.instance();o.searchable=!1,o.show(),o.translation=[u*h+h/2+r,t*h+h/2+i],o.backgroundColor=n,o.texture=e,o.size=[h,h],o.rotation=Math.PI/6,u%3==0&&(o.borderWidth=1,o.borderDashed=2,o.borderColor=Ut())}},drawOneWayArrow(){const t=new gt(100,100),e=new Bt(window.engine,t);window.g2=e;const n=e.instance().show();n.translation=[300,300],n.vertexOffsetValue=[0,100],n.rotation=Math.PI/4,n.backgroundColor=Ut(),n.searchable=!0,n.expandRadius=20},drawTwoWayArrow(){const t=new jt(window.engine,100,100,10);window.g3=t;const e=t.instance();e.fromTo=[0,0,200,200],e.type=2,e.show(),e.backgroundColor=Ut(),e.borderWidth=3,e.borderDashed=10,e.borderColor=[0,0,0,255],e.searchable=!0,e.expandRadius=20}}},zt=kt,qt=(n("e891"),Object(c["a"])(zt,L,B,!1,null,"59e8921a",null)),Ht=qt.exports,Xt=function(){var t=this,e=t._self._c;return e("div",[e("div",{staticClass:"i-nav"},t._l(t.interviewsList,(function(n){return e("router-link",{key:n.path,attrs:{to:n.path}},[t._v(t._s(n.name))])})),1),e("router-view")],1)},Kt=[],Zt={name:"xxx",components:{},data(){return{interviewsList:[]}},mounted(){const t=this.$router.options.routes.filter(t=>"Study"===t.name)[0].children;this.interviewsList=t},methods:{}},Jt=Zt,Qt=(n("43a8"),Object(c["a"])(Jt,Xt,Kt,!1,null,"3b5ff280",null)),$t=Qt.exports,te=function(){var t=this;t._self._c;return t._m(0)},ee=[function(){var t=this,e=t._self._c;return e("div",[e("section",[t._v(" html超文本标记语言，由一系列的元素（elements）组成；元素可以告诉浏览器如何展示内容； "),e("pre",[t._v("      文档类型声明（DOCTYPE）!DOCTYPE html ；\n      html 元素：文档的根元素，所有的内容都包含在这个元素内。\n      head 元素：包含文档的元数据，如字符集声明、页面标题和链接到 CSS 文件。\n      body 元素：包含可见的页面内容\n      标题和段落：h1 到 h6 定义标题，p 定义段落\n      链接：a 元素用于创建链接\n      图片：img 元素用于嵌入图片\n      列表：ul 表示无序列表，ol 表示有序列表，li 表示列表项。\n      表格：table 用于创建表格，tr 用于行，th 和 td 分别用于表头和单元格\n      "),e("a",{attrs:{href:"https://evelance.notion.site/Table-8dde6cdd0844459b96f2fc9ec7ba8793"}},[t._v("表格：table注意事项")]),t._v("\n      表单：form 用于创建表单，input 用于收集用户输入\n      ")])]),e("section",[t._v(" https://evelance.notion.site/56e3e25360914897ad0717fbd06a17d1 "),e("pre",[t._v("      ## 语义化的理解\n- 用正确的标签做正确的事情，结构清晰，可读性高，方便维护\nheader / main / aside / section / article / footer / canvas / video / audio\n- 利于 SEO（搜索引擎优化）\n\n## SEO\n一种搜索引擎的搜索规则，可利用它来提高网站在搜索结果中的排名\n前端 SEO 实践与注意点：\n- 实践：\n    - head 标签中：\n        - `title`：言简意赅，需要体现出页面的主要内容\n        - `description`：对页面内容的高度概括\n        - `keywords`：列举出网站重要关键词\n- 注意点：\n    - 重要内容不要 JS 输出，爬虫不会执行 JS 获取内容\n    - 非装饰性图片必须加 alt\n    - 提高网站访问速度\n    ")])]),e("section",[e("p",[t._v("Web Worker")]),t._v(" 在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。 web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面你的性能。并且通过 postMessage 将结果回传到主线程。 这样在进行复杂计算操作的时候，就不会阻塞主线程了。 如何创建 web worker: 1. 检测浏览器对于 web worker 的支持性 2. 创建 web worker 文件(js，回传函数等) 3. 创建 web worker 对象 https://github.com/mdn/dom-examples/tree/main/web-workers ")]),e("section",[t._v(" Canvas 和 SVG 有什么区别 绘制方式：js xml 分辨率影响: 逐像素，矢量图(独立于像素) 元素事件：不支持， 支持 场景：频繁重绘，数据量大；svg是dom操作，不适用频繁重绘 ")])])}],ne={name:"HHHH",components:{},data(){return{}},mounted(){},methods:{}},re=ne,ie=Object(c["a"])(re,te,ee,!1,null,null,null),oe=ie.exports,ae=function(){var t=this;t._self._c;return t._m(0)},se=[function(){var t=this,e=t._self._c;return e("div",[e("section",[e("h3",[t._v("1.引入 CSS 的 4 种方式")]),e("div",[t._v('导入 @import "mystyle.css";')]),e("div",[t._v('外链 link rel="stylesheet" type="text/css" href="my.css" ;')]),e("div",[t._v('行内式 div style="border:1px red solid;";')]),e("div",[t._v('style标签 style type="text/css" div { margin: 0; } style')])]),e("section",[e("h3",[t._v("盒模型")]),e("p",[t._v(" Dom中对一个元素在占据布局空间的描述，从内到外：content，padding，border，margin ")]),e("pre",[t._v("box-sizing影响盒模型的计算方式：同样是设置的css宽高像素100px；\n标准的 content-box： 内容宽度（100px） 不包括 内边距 + 边框宽度\nIE的border-box：  内容宽度 100px（包括了内边距+边框）\n")])]),e("section",[e("h3",[t._v("display属性")]),e("pre",[t._v("    block，inline 和 inline-block：\n    - `inline`\n    - 不会独占一行；相邻的排同一行；一行排不下会换行\n    - 不可设置宽高\n    - `padding`、`margin` **水平**方向上设置**有效**，**垂直**方向上**无效**\n\n    - `inline-block`\n    - 和其他元素同一行（行内元素特点）\n    - 可以设置宽高（块级元素特点）\n    - `padding`、`margin` **设置有效**\n\n    - `block`\n    - 独占一行\n    - 可以设置宽高\n    - `padding`、`margin` 设置有效\n\n比较 opacity: 0、visibility: hidden、display: none 的区别\n结构：\ndisplay:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，\nvisibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击\nopacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击\n\n继承：\ndisplay: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。\nvisibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。\n\n性能：\ndisplay：none 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大\nvisibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容\nopacity: 0 ： 修改元素会造成重绘，性能消耗较少\n      ")])]),e("section",[e("h3",[t._v("css选择器")]),e("a",{attrs:{href:"https://evelance.notion.site/CSS-757cd0fa3932490bb5abd723b7726345",target:"_blank"}},[t._v("css选择器")]),e("p",[t._v("选择器匹配规则: 从右往左， why？")]),e("pre",[t._v('        **1. 从右向左匹配的步骤**\n假设有一个选择器 `div ul > li a.active`：\n\n1. **从最右边的选择器开始**，即 `.active`，查找所有带有 `class="active"` 的 `a` 元素。\n2. 然后**往左移动**到 `li a.active`，过滤掉不在 `li` 内部的 `a` 元素。\n3. 接着移动到 `ul > li a.active`，进一步过滤掉不在直接子元素 `li` 内部的 `a` 元素。\n4. 最后到 `div ul > li a.active`，过滤掉不在 `div` 内部的 `ul` 内部的 `li` 内部的 `a` 元素。\n\n**2. 优化原因**\n\n这种从右向左的匹配方式主要是为了优化选择器的性能：\n- **减少不必要的查找**：从右向左匹配能够立即定位具体的元素，从而避免从文档根部开始的全局搜索。\n假设选择器是从左到右匹配，会从文档根部开始搜索所有 `div`，然后查找每个 `div` 下的 `ul`，再查找 `ul` 下的 `li`，最后检查 `li` 下是否有符合条件的 `a`。\n  这可能导致大量无效的查找。\n- **降低复杂度**：CSS 引擎可以快速排除不符合条件的元素。\n例如，选择器 `.active` 可以迅速筛选出特定的 `a` 元素，大大减少需要进一步检查的元素数量。\n      ')])]),e("section",[e("h3",[t._v("CSS 优先级算法")]),e("pre",[t._v("    - 优先级：\n    - 同权重下: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）\n    - !important > id > class > tag\n    - !important 比 内联优先级高\n\n    - **同权重下**：\n    - 优先级就近原则，样式定义最近者为准\n    - 载入样式以最后载入的定位为准\n      ")])]),e("section",[e("h3",[t._v("BFC")]),e("pre",[t._v("        BFC块级格式化上下文 是 CSS 中页面的一块独立渲染区域，内部元素的渲染遵循特定规则，与区域外部的元素相互隔离。\n触发条件:\n- `html` 根元素（整个文档的根元素自动成为 BFC）。\n- 元素的 `float` 属性值不是 `none`（即设置了浮动 `left` 、 `right`）。\n- 元素的 `position` 属性值是 `absolute`（绝对定位）或 `fixed`（固定定位）。\n- 元素的 `display` 属性值是 `inline-block`、`table-cell`、`flex`、`table-caption`、`inline-flex` 等。\n- 元素的 `overflow` 属性值不是 `visible`（如 `auto`、`hidden`、`scroll`）。\n特点：\n1. 同一个 BFC 内部的盒子会按照正常文档流一个接一个地放置。\n2. BFC 内部的元素垂直方向的距离由`margin`决定，属于同一个 BFC 的两个相邻元素的`margin`会发生重叠。\n3. BFC 的区域不会与浮动盒子重叠。\n4. BFC 是一个隔离的独立容器，容器里面的子元素不会影响外面的元素，反之亦然。\n作用：\n清除浮动影响 和 margin重叠\n      ")])]),e("section",[e("h3",[t._v("CSS 单位: px, %, em, rem, vw/vh")]),e("pre",[t._v("- 使用 `px` ，结合 Media Query 进行阶梯式的适配\n- 使用 `%` ，按百分比自适应布局\n- `em`，相对单位，相对于父元素的字体大小\n- `rem`，也是相对单位，相对于根元素 `html`。使用`rem`，结合 `html` 元素的 `font-size` 来根据屏幕宽度适配\n- 使用 `vw`、`vh`，直接根据视口宽高适配。\n1. 在视觉稿要求固定尺寸的元素上使用 `px`。比如 `1px` 线，`4px` 的圆角边框。\n2. 在字号、（大多数）间距上使用 `rem`。\n3. 慎用 `em`。\n      ")])]),e("section",[e("h3",[t._v("css3新特性")]),e("pre",[t._v("        transition: CSS属性，花费时间，运动曲线(默认ease)，延迟时间(默认0)\n        animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），\n是否反向播放动画（默认normal），是否暂停动画（默认running）\n        transform：\ntransform: rotate(30deg);\ntransform: translate(30px, 30px);\ntransform: scale(.8);\ntransform: skew(10deg, 10deg);\ntransform-origin: left top; 左上（默认中心）【改变元素变形的原点】\n\nFlex 布局：\nflex 弹性盒布局模型的目的：提供一种更加高效的方式来对容器中的元素进行布局、对齐和分配空间\n主轴方向：水平排列（默认） | 水平反向排列 | 垂直排列 | 垂直反向排列\nflex-direction: row | row-reverse | column | column-reverse;\n\n换行：不换行（默认） | 换行 | 反向换行(第一行在最后面)\nflex-wrap: nowrap | wrap | wrap-reverse;\n\nflex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\nflex-flow: flex-direction || flex-wrap;\n\n主轴对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐\njustify-content: flex-start | flex-end | center | space-between | space-around;\n\n交叉轴对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 第一行文字的基线对齐\nalign-items: stretch | flex-start | flex-end | center | baseline;\n\n多根轴线对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐\nalign-content: stretch | flex-start | flex-end | center | space-between | space-around;\n\n- `flex` 默认设置是 `flex: 0 1 auto`\n- 意思是项目默认有剩余空间也不放大（0），但空间不足会缩小（1）\n\n      ")])]),e("section",[e("h3",[t._v("响应式设计")]),e("p",[t._v(" 一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 ")]),e("pre",[t._v("@media screen and (max-width: 990px) {\n    .container {\n        background: orange;\n    }\n}\n\n@media (max-width: 575px) {\n   .call-me {\n      .call-item:first-child {\n         border-right: 0 !important;\n         border-bottom: 1px solid #e6e6e6;\n      }\n   }\n}\n      ")])])])}],ce={name:"css",components:{},data(){return{}},mounted(){},methods:{}},he=ce,ue=Object(c["a"])(he,ae,se,!1,null,"24e97c58",null),de=ue.exports,le=function(){var t=this;t._self._c;return t._m(0)},ve=[function(){var t=this,e=t._self._c;return e("div",[e("a",{attrs:{href:"https://github.com/Troland/how-javascript-works/tree/master"}},[t._v("how-javascript-works")])])}],fe={name:"JS",components:{},data(){return{}},mounted(){},methods:{}},_e=fe,pe=Object(c["a"])(_e,le,ve,!1,null,"71c2c726",null),be=pe.exports,ge=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},Ae=[],me={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},xe=me,Me=Object(c["a"])(xe,ge,Ae,!1,null,"2915c99b",null),Oe=Me.exports,we=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},Te=[],Ee={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Re=Ee,Ve=Object(c["a"])(Re,we,Te,!1,null,"6e1ff062",null),ye=Ve.exports,Se=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},De=[],Ne={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Ie=Ne,Pe=Object(c["a"])(Ie,Se,De,!1,null,"027bc347",null),Ce=Pe.exports,Le=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},Be=[],je={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Ue=je,Fe=Object(c["a"])(Ue,Le,Be,!1,null,"ac32dd24",null),Ye=Fe.exports,We=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},Ge=[],ke={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},ze=ke,qe=Object(c["a"])(ze,We,Ge,!1,null,"2bd41924",null),He=qe.exports,Xe=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},Ke=[],Ze={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Je=Ze,Qe=Object(c["a"])(Je,Xe,Ke,!1,null,"6e073e11",null),$e=Qe.exports,tn=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},en=[],nn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},rn=nn,on=Object(c["a"])(rn,tn,en,!1,null,"7789eb79",null),an=on.exports,sn=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},cn=[],hn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},un=hn,dn=Object(c["a"])(un,sn,cn,!1,null,"7f0fcd7e",null),ln=dn.exports,vn=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},fn=[],_n={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},pn=_n,bn=Object(c["a"])(pn,vn,fn,!1,null,"6e481142",null),gn=bn.exports,An=function(){var t=this,e=t._self._c;return e("div",[t._v("t")])},mn=[],xn={name:"xxx",components:{},data(){return{}},mounted(){},methods:{}},Mn=xn,On=Object(c["a"])(Mn,An,mn,!1,null,"6712a19d",null),wn=On.exports;r["a"].use(d["a"]);const Tn=[{path:"/",redirect:"/GLSL"},{path:"/GLSL",name:"GLSL",component:b},{path:"/Coord",name:"Coord",component:O},{path:"/Vector",name:"Vector",component:y},{path:"/Matrix",name:"Matrix",component:C},{path:"/TEST_GL_API",name:"TEST_GL_API",component:Ht},{path:"/study",name:"Study",component:$t,redirect:"/study/html",children:[{path:"/study/html",name:"html",component:oe},{path:"/study/css",name:"css",component:de},{path:"/study/js",name:"js",component:be},{path:"/study/browser",name:"浏览器",component:Oe},{path:"/study/network",name:"network",component:ye},{path:"/study/git",name:"Git管理",component:Ce},{path:"/study/vuereact",name:"框架vue-react",component:Ye},{path:"/study/webpack",name:"webpack",component:He},{path:"/study/ts",name:"ts",component:$e},{path:"/study/optimize",name:"优化手段",component:an},{path:"/study/designmode",name:"设计模式",component:ln},{path:"/study/aigorithm",name:"算法",component:gn},{path:"/study/bussiness1",name:"业务1",component:wn}]}],En=new d["a"]({mode:"history",base:"/hh-render/",routes:Tn});var Rn=En,Vn=n("2f62");r["a"].use(Vn["a"]);var yn=new Vn["a"].Store({state:{},mutations:{},actions:{},modules:{}});n("8e1f");r["a"].config.productionTip=!1,new r["a"]({router:Rn,store:yn,render:t=>t(u)}).$mount("#app")},"5f8a":function(t,e,n){},6935:function(t,e,n){},8554:function(t,e,n){t.exports=n.p+"static/img/1.3058969f.jpg"},"859d":function(t,e,n){},"8a76":function(t,e,n){t.exports=n.p+"static/img/coordlr.33299a8b.png"},"8e1f":function(t,e,n){},"9c9c":function(t,e,n){},a396:function(t,e,n){"use strict";n("0721")},b75e:function(t,e,n){"use strict";n("b78e")},b78e:function(t,e,n){},bafb:function(t,e,n){t.exports=n.p+"static/img/4.e580020d.jpg"},c83a:function(t,e,n){n("2c66"),n("249d"),n("40e9"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("0643"),n("4e3e"),function(e,n){t.exports=n()}(0,(function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},n.n=function(t){var e=t&&t.__esModule?function(){return t["default"]}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=4)}([function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setMatrixArrayType=i,e.toRadian=a,e.equals=s;var r=e.EPSILON=1e-6;e.ARRAY_TYPE="undefined"!==typeof Float32Array?Float32Array:Array,e.RANDOM=Math.random;function i(t){e.ARRAY_TYPE=t}var o=Math.PI/180;function a(t){return t*o}function s(t,e){return Math.abs(t-e)<=r*Math.max(1,Math.abs(t),Math.abs(e))}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sub=e.mul=void 0,e.create=a,e.fromMat4=s,e.clone=c,e.copy=h,e.fromValues=u,e.set=d,e.identity=l,e.transpose=v,e.invert=f,e.adjoint=_,e.determinant=p,e.multiply=b,e.translate=g,e.rotate=A,e.scale=m,e.fromTranslation=x,e.fromRotation=M,e.fromScaling=O,e.fromMat2d=w,e.fromQuat=T,e.normalFromMat4=E,e.projection=R,e.str=V,e.frob=y,e.add=S,e.subtract=D,e.multiplyScalar=N,e.multiplyScalarAndAdd=I,e.exactEquals=P,e.equals=C;var r=n(0),i=o(r);function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(){var t=new i.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function s(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10],t}function c(t){var e=new i.ARRAY_TYPE(9);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function h(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function u(t,e,n,r,o,a,s,c,h){var u=new i.ARRAY_TYPE(9);return u[0]=t,u[1]=e,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=c,u[8]=h,u}function d(t,e,n,r,i,o,a,s,c,h){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t[4]=o,t[5]=a,t[6]=s,t[7]=c,t[8]=h,t}function l(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function v(t,e){if(t===e){var n=e[1],r=e[2],i=e[5];t[1]=e[3],t[2]=e[6],t[3]=n,t[5]=e[7],t[6]=r,t[7]=i}else t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8];return t}function f(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],s=e[5],c=e[6],h=e[7],u=e[8],d=u*a-s*h,l=-u*o+s*c,v=h*o-a*c,f=n*d+r*l+i*v;return f?(f=1/f,t[0]=d*f,t[1]=(-u*r+i*h)*f,t[2]=(s*r-i*a)*f,t[3]=l*f,t[4]=(u*n-i*c)*f,t[5]=(-s*n+i*o)*f,t[6]=v*f,t[7]=(-h*n+r*c)*f,t[8]=(a*n-r*o)*f,t):null}function _(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],s=e[5],c=e[6],h=e[7],u=e[8];return t[0]=a*u-s*h,t[1]=i*h-r*u,t[2]=r*s-i*a,t[3]=s*c-o*u,t[4]=n*u-i*c,t[5]=i*o-n*s,t[6]=o*h-a*c,t[7]=r*c-n*h,t[8]=n*a-r*o,t}function p(t){var e=t[0],n=t[1],r=t[2],i=t[3],o=t[4],a=t[5],s=t[6],c=t[7],h=t[8];return e*(h*o-a*c)+n*(-h*i+a*s)+r*(c*i-o*s)}function b(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=e[6],u=e[7],d=e[8],l=n[0],v=n[1],f=n[2],_=n[3],p=n[4],b=n[5],g=n[6],A=n[7],m=n[8];return t[0]=l*r+v*a+f*h,t[1]=l*i+v*s+f*u,t[2]=l*o+v*c+f*d,t[3]=_*r+p*a+b*h,t[4]=_*i+p*s+b*u,t[5]=_*o+p*c+b*d,t[6]=g*r+A*a+m*h,t[7]=g*i+A*s+m*u,t[8]=g*o+A*c+m*d,t}function g(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=e[6],u=e[7],d=e[8],l=n[0],v=n[1];return t[0]=r,t[1]=i,t[2]=o,t[3]=a,t[4]=s,t[5]=c,t[6]=l*r+v*a+h,t[7]=l*i+v*s+u,t[8]=l*o+v*c+d,t}function A(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=e[6],u=e[7],d=e[8],l=Math.sin(n),v=Math.cos(n);return t[0]=v*r+l*a,t[1]=v*i+l*s,t[2]=v*o+l*c,t[3]=v*a-l*r,t[4]=v*s-l*i,t[5]=v*c-l*o,t[6]=h,t[7]=u,t[8]=d,t}function m(t,e,n){var r=n[0],i=n[1];return t[0]=r*e[0],t[1]=r*e[1],t[2]=r*e[2],t[3]=i*e[3],t[4]=i*e[4],t[5]=i*e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function x(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=e[0],t[7]=e[1],t[8]=1,t}function M(t,e){var n=Math.sin(e),r=Math.cos(e);return t[0]=r,t[1]=n,t[2]=0,t[3]=-n,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function O(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=e[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function w(t,e){return t[0]=e[0],t[1]=e[1],t[2]=0,t[3]=e[2],t[4]=e[3],t[5]=0,t[6]=e[4],t[7]=e[5],t[8]=1,t}function T(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=n+n,s=r+r,c=i+i,h=n*a,u=r*a,d=r*s,l=i*a,v=i*s,f=i*c,_=o*a,p=o*s,b=o*c;return t[0]=1-d-f,t[3]=u-b,t[6]=l+p,t[1]=u+b,t[4]=1-h-f,t[7]=v-_,t[2]=l-p,t[5]=v+_,t[8]=1-h-d,t}function E(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],s=e[5],c=e[6],h=e[7],u=e[8],d=e[9],l=e[10],v=e[11],f=e[12],_=e[13],p=e[14],b=e[15],g=n*s-r*a,A=n*c-i*a,m=n*h-o*a,x=r*c-i*s,M=r*h-o*s,O=i*h-o*c,w=u*_-d*f,T=u*p-l*f,E=u*b-v*f,R=d*p-l*_,V=d*b-v*_,y=l*b-v*p,S=g*y-A*V+m*R+x*E-M*T+O*w;return S?(S=1/S,t[0]=(s*y-c*V+h*R)*S,t[1]=(c*E-a*y-h*T)*S,t[2]=(a*V-s*E+h*w)*S,t[3]=(i*V-r*y-o*R)*S,t[4]=(n*y-i*E+o*T)*S,t[5]=(r*E-n*V-o*w)*S,t[6]=(_*O-p*M+b*x)*S,t[7]=(p*m-f*O-b*A)*S,t[8]=(f*M-_*m+b*g)*S,t):null}function R(t,e,n){return t[0]=2/e,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/n,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t}function V(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"}function y(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))}function S(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t[3]=e[3]+n[3],t[4]=e[4]+n[4],t[5]=e[5]+n[5],t[6]=e[6]+n[6],t[7]=e[7]+n[7],t[8]=e[8]+n[8],t}function D(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t[3]=e[3]-n[3],t[4]=e[4]-n[4],t[5]=e[5]-n[5],t[6]=e[6]-n[6],t[7]=e[7]-n[7],t[8]=e[8]-n[8],t}function N(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*n,t[5]=e[5]*n,t[6]=e[6]*n,t[7]=e[7]*n,t[8]=e[8]*n,t}function I(t,e,n,r){return t[0]=e[0]+n[0]*r,t[1]=e[1]+n[1]*r,t[2]=e[2]+n[2]*r,t[3]=e[3]+n[3]*r,t[4]=e[4]+n[4]*r,t[5]=e[5]+n[5]*r,t[6]=e[6]+n[6]*r,t[7]=e[7]+n[7]*r,t[8]=e[8]+n[8]*r,t}function P(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]}function C(t,e){var n=t[0],r=t[1],o=t[2],a=t[3],s=t[4],c=t[5],h=t[6],u=t[7],d=t[8],l=e[0],v=e[1],f=e[2],_=e[3],p=e[4],b=e[5],g=e[6],A=e[7],m=e[8];return Math.abs(n-l)<=i.EPSILON*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(r-v)<=i.EPSILON*Math.max(1,Math.abs(r),Math.abs(v))&&Math.abs(o-f)<=i.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(a-_)<=i.EPSILON*Math.max(1,Math.abs(a),Math.abs(_))&&Math.abs(s-p)<=i.EPSILON*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(c-b)<=i.EPSILON*Math.max(1,Math.abs(c),Math.abs(b))&&Math.abs(h-g)<=i.EPSILON*Math.max(1,Math.abs(h),Math.abs(g))&&Math.abs(u-A)<=i.EPSILON*Math.max(1,Math.abs(u),Math.abs(A))&&Math.abs(d-m)<=i.EPSILON*Math.max(1,Math.abs(d),Math.abs(m))}e.mul=b,e.sub=D},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.forEach=e.sqrLen=e.len=e.sqrDist=e.dist=e.div=e.mul=e.sub=void 0,e.create=a,e.clone=s,e.length=c,e.fromValues=h,e.copy=u,e.set=d,e.add=l,e.subtract=v,e.multiply=f,e.divide=_,e.ceil=p,e.floor=b,e.min=g,e.max=A,e.round=m,e.scale=x,e.scaleAndAdd=M,e.distance=O,e.squaredDistance=w,e.squaredLength=T,e.negate=E,e.inverse=R,e.normalize=V,e.dot=y,e.cross=S,e.lerp=D,e.hermite=N,e.bezier=I,e.random=P,e.transformMat4=C,e.transformMat3=L,e.transformQuat=B,e.rotateX=j,e.rotateY=U,e.rotateZ=F,e.angle=Y,e.str=W,e.exactEquals=G,e.equals=k;var r=n(0),i=o(r);function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(){var t=new i.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t}function s(t){var e=new i.ARRAY_TYPE(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function c(t){var e=t[0],n=t[1],r=t[2];return Math.sqrt(e*e+n*n+r*r)}function h(t,e,n){var r=new i.ARRAY_TYPE(3);return r[0]=t,r[1]=e,r[2]=n,r}function u(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function d(t,e,n,r){return t[0]=e,t[1]=n,t[2]=r,t}function l(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t}function v(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t}function f(t,e,n){return t[0]=e[0]*n[0],t[1]=e[1]*n[1],t[2]=e[2]*n[2],t}function _(t,e,n){return t[0]=e[0]/n[0],t[1]=e[1]/n[1],t[2]=e[2]/n[2],t}function p(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t}function b(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t}function g(t,e,n){return t[0]=Math.min(e[0],n[0]),t[1]=Math.min(e[1],n[1]),t[2]=Math.min(e[2],n[2]),t}function A(t,e,n){return t[0]=Math.max(e[0],n[0]),t[1]=Math.max(e[1],n[1]),t[2]=Math.max(e[2],n[2]),t}function m(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t}function x(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t}function M(t,e,n,r){return t[0]=e[0]+n[0]*r,t[1]=e[1]+n[1]*r,t[2]=e[2]+n[2]*r,t}function O(t,e){var n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return Math.sqrt(n*n+r*r+i*i)}function w(t,e){var n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return n*n+r*r+i*i}function T(t){var e=t[0],n=t[1],r=t[2];return e*e+n*n+r*r}function E(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t}function R(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}function V(t,e){var n=e[0],r=e[1],i=e[2],o=n*n+r*r+i*i;return o>0&&(o=1/Math.sqrt(o),t[0]=e[0]*o,t[1]=e[1]*o,t[2]=e[2]*o),t}function y(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function S(t,e,n){var r=e[0],i=e[1],o=e[2],a=n[0],s=n[1],c=n[2];return t[0]=i*c-o*s,t[1]=o*a-r*c,t[2]=r*s-i*a,t}function D(t,e,n,r){var i=e[0],o=e[1],a=e[2];return t[0]=i+r*(n[0]-i),t[1]=o+r*(n[1]-o),t[2]=a+r*(n[2]-a),t}function N(t,e,n,r,i,o){var a=o*o,s=a*(2*o-3)+1,c=a*(o-2)+o,h=a*(o-1),u=a*(3-2*o);return t[0]=e[0]*s+n[0]*c+r[0]*h+i[0]*u,t[1]=e[1]*s+n[1]*c+r[1]*h+i[1]*u,t[2]=e[2]*s+n[2]*c+r[2]*h+i[2]*u,t}function I(t,e,n,r,i,o){var a=1-o,s=a*a,c=o*o,h=s*a,u=3*o*s,d=3*c*a,l=c*o;return t[0]=e[0]*h+n[0]*u+r[0]*d+i[0]*l,t[1]=e[1]*h+n[1]*u+r[1]*d+i[1]*l,t[2]=e[2]*h+n[2]*u+r[2]*d+i[2]*l,t}function P(t,e){e=e||1;var n=2*i.RANDOM()*Math.PI,r=2*i.RANDOM()-1,o=Math.sqrt(1-r*r)*e;return t[0]=Math.cos(n)*o,t[1]=Math.sin(n)*o,t[2]=r*e,t}function C(t,e,n){var r=e[0],i=e[1],o=e[2],a=n[3]*r+n[7]*i+n[11]*o+n[15];return a=a||1,t[0]=(n[0]*r+n[4]*i+n[8]*o+n[12])/a,t[1]=(n[1]*r+n[5]*i+n[9]*o+n[13])/a,t[2]=(n[2]*r+n[6]*i+n[10]*o+n[14])/a,t}function L(t,e,n){var r=e[0],i=e[1],o=e[2];return t[0]=r*n[0]+i*n[3]+o*n[6],t[1]=r*n[1]+i*n[4]+o*n[7],t[2]=r*n[2]+i*n[5]+o*n[8],t}function B(t,e,n){var r=e[0],i=e[1],o=e[2],a=n[0],s=n[1],c=n[2],h=n[3],u=h*r+s*o-c*i,d=h*i+c*r-a*o,l=h*o+a*i-s*r,v=-a*r-s*i-c*o;return t[0]=u*h+v*-a+d*-c-l*-s,t[1]=d*h+v*-s+l*-a-u*-c,t[2]=l*h+v*-c+u*-s-d*-a,t}function j(t,e,n,r){var i=[],o=[];return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],o[0]=i[0],o[1]=i[1]*Math.cos(r)-i[2]*Math.sin(r),o[2]=i[1]*Math.sin(r)+i[2]*Math.cos(r),t[0]=o[0]+n[0],t[1]=o[1]+n[1],t[2]=o[2]+n[2],t}function U(t,e,n,r){var i=[],o=[];return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],o[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),o[1]=i[1],o[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),t[0]=o[0]+n[0],t[1]=o[1]+n[1],t[2]=o[2]+n[2],t}function F(t,e,n,r){var i=[],o=[];return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],o[0]=i[0]*Math.cos(r)-i[1]*Math.sin(r),o[1]=i[0]*Math.sin(r)+i[1]*Math.cos(r),o[2]=i[2],t[0]=o[0]+n[0],t[1]=o[1]+n[1],t[2]=o[2]+n[2],t}function Y(t,e){var n=h(t[0],t[1],t[2]),r=h(e[0],e[1],e[2]);V(n,n),V(r,r);var i=y(n,r);return i>1?0:i<-1?Math.PI:Math.acos(i)}function W(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"}function G(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]}function k(t,e){var n=t[0],r=t[1],o=t[2],a=e[0],s=e[1],c=e[2];return Math.abs(n-a)<=i.EPSILON*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(r-s)<=i.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-c)<=i.EPSILON*Math.max(1,Math.abs(o),Math.abs(c))}e.sub=v,e.mul=f,e.div=_,e.dist=O,e.sqrDist=w,e.len=c,e.sqrLen=T,e.forEach=function(){var t=a();return function(e,n,r,i,o,a){var s=void 0,c=void 0;for(n||(n=3),r||(r=0),c=i?Math.min(i*n+r,e.length):e.length,s=r;s<c;s+=n)t[0]=e[s],t[1]=e[s+1],t[2]=e[s+2],o(t,t,a),e[s]=t[0],e[s+1]=t[1],e[s+2]=t[2];return e}}()},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.forEach=e.sqrLen=e.len=e.sqrDist=e.dist=e.div=e.mul=e.sub=void 0,e.create=a,e.clone=s,e.fromValues=c,e.copy=h,e.set=u,e.add=d,e.subtract=l,e.multiply=v,e.divide=f,e.ceil=_,e.floor=p,e.min=b,e.max=g,e.round=A,e.scale=m,e.scaleAndAdd=x,e.distance=M,e.squaredDistance=O,e.length=w,e.squaredLength=T,e.negate=E,e.inverse=R,e.normalize=V,e.dot=y,e.lerp=S,e.random=D,e.transformMat4=N,e.transformQuat=I,e.str=P,e.exactEquals=C,e.equals=L;var r=n(0),i=o(r);function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(){var t=new i.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}function s(t){var e=new i.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function c(t,e,n,r){var o=new i.ARRAY_TYPE(4);return o[0]=t,o[1]=e,o[2]=n,o[3]=r,o}function h(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function u(t,e,n,r,i){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t}function d(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t[3]=e[3]+n[3],t}function l(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t[3]=e[3]-n[3],t}function v(t,e,n){return t[0]=e[0]*n[0],t[1]=e[1]*n[1],t[2]=e[2]*n[2],t[3]=e[3]*n[3],t}function f(t,e,n){return t[0]=e[0]/n[0],t[1]=e[1]/n[1],t[2]=e[2]/n[2],t[3]=e[3]/n[3],t}function _(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t[3]=Math.ceil(e[3]),t}function p(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t[3]=Math.floor(e[3]),t}function b(t,e,n){return t[0]=Math.min(e[0],n[0]),t[1]=Math.min(e[1],n[1]),t[2]=Math.min(e[2],n[2]),t[3]=Math.min(e[3],n[3]),t}function g(t,e,n){return t[0]=Math.max(e[0],n[0]),t[1]=Math.max(e[1],n[1]),t[2]=Math.max(e[2],n[2]),t[3]=Math.max(e[3],n[3]),t}function A(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t[3]=Math.round(e[3]),t}function m(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t}function x(t,e,n,r){return t[0]=e[0]+n[0]*r,t[1]=e[1]+n[1]*r,t[2]=e[2]+n[2]*r,t[3]=e[3]+n[3]*r,t}function M(t,e){var n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return Math.sqrt(n*n+r*r+i*i+o*o)}function O(t,e){var n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return n*n+r*r+i*i+o*o}function w(t){var e=t[0],n=t[1],r=t[2],i=t[3];return Math.sqrt(e*e+n*n+r*r+i*i)}function T(t){var e=t[0],n=t[1],r=t[2],i=t[3];return e*e+n*n+r*r+i*i}function E(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t}function R(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t[3]=1/e[3],t}function V(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=n*n+r*r+i*i+o*o;return a>0&&(a=1/Math.sqrt(a),t[0]=n*a,t[1]=r*a,t[2]=i*a,t[3]=o*a),t}function y(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}function S(t,e,n,r){var i=e[0],o=e[1],a=e[2],s=e[3];return t[0]=i+r*(n[0]-i),t[1]=o+r*(n[1]-o),t[2]=a+r*(n[2]-a),t[3]=s+r*(n[3]-s),t}function D(t,e){return e=e||1,t[0]=i.RANDOM(),t[1]=i.RANDOM(),t[2]=i.RANDOM(),t[3]=i.RANDOM(),V(t,t),m(t,t,e),t}function N(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3];return t[0]=n[0]*r+n[4]*i+n[8]*o+n[12]*a,t[1]=n[1]*r+n[5]*i+n[9]*o+n[13]*a,t[2]=n[2]*r+n[6]*i+n[10]*o+n[14]*a,t[3]=n[3]*r+n[7]*i+n[11]*o+n[15]*a,t}function I(t,e,n){var r=e[0],i=e[1],o=e[2],a=n[0],s=n[1],c=n[2],h=n[3],u=h*r+s*o-c*i,d=h*i+c*r-a*o,l=h*o+a*i-s*r,v=-a*r-s*i-c*o;return t[0]=u*h+v*-a+d*-c-l*-s,t[1]=d*h+v*-s+l*-a-u*-c,t[2]=l*h+v*-c+u*-s-d*-a,t[3]=e[3],t}function P(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function C(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function L(t,e){var n=t[0],r=t[1],o=t[2],a=t[3],s=e[0],c=e[1],h=e[2],u=e[3];return Math.abs(n-s)<=i.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(r-c)<=i.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(o-h)<=i.EPSILON*Math.max(1,Math.abs(o),Math.abs(h))&&Math.abs(a-u)<=i.EPSILON*Math.max(1,Math.abs(a),Math.abs(u))}e.sub=l,e.mul=v,e.div=f,e.dist=M,e.sqrDist=O,e.len=w,e.sqrLen=T,e.forEach=function(){var t=a();return function(e,n,r,i,o,a){var s=void 0,c=void 0;for(n||(n=4),r||(r=0),c=i?Math.min(i*n+r,e.length):e.length,s=r;s<c;s+=n)t[0]=e[s],t[1]=e[s+1],t[2]=e[s+2],t[3]=e[s+3],o(t,t,a),e[s]=t[0],e[s+1]=t[1],e[s+2]=t[2],e[s+3]=t[3];return e}}()},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.vec4=e.vec3=e.vec2=e.quat=e.mat4=e.mat3=e.mat2d=e.mat2=e.glMatrix=void 0;var r=n(0),i=x(r),o=n(5),a=x(o),s=n(6),c=x(s),h=n(1),u=x(h),d=n(7),l=x(d),v=n(8),f=x(v),_=n(9),p=x(_),b=n(2),g=x(b),A=n(3),m=x(A);function x(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}e.glMatrix=i,e.mat2=a,e.mat2d=c,e.mat3=u,e.mat4=l,e.quat=f,e.vec2=p,e.vec3=g,e.vec4=m},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sub=e.mul=void 0,e.create=a,e.clone=s,e.copy=c,e.identity=h,e.fromValues=u,e.set=d,e.transpose=l,e.invert=v,e.adjoint=f,e.determinant=_,e.multiply=p,e.rotate=b,e.scale=g,e.fromRotation=A,e.fromScaling=m,e.str=x,e.frob=M,e.LDU=O,e.add=w,e.subtract=T,e.exactEquals=E,e.equals=R,e.multiplyScalar=V,e.multiplyScalarAndAdd=y;var r=n(0),i=o(r);function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(){var t=new i.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function s(t){var e=new i.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function c(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function h(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function u(t,e,n,r){var o=new i.ARRAY_TYPE(4);return o[0]=t,o[1]=e,o[2]=n,o[3]=r,o}function d(t,e,n,r,i){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t}function l(t,e){if(t===e){var n=e[1];t[1]=e[2],t[2]=n}else t[0]=e[0],t[1]=e[2],t[2]=e[1],t[3]=e[3];return t}function v(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=n*o-i*r;return a?(a=1/a,t[0]=o*a,t[1]=-r*a,t[2]=-i*a,t[3]=n*a,t):null}function f(t,e){var n=e[0];return t[0]=e[3],t[1]=-e[1],t[2]=-e[2],t[3]=n,t}function _(t){return t[0]*t[3]-t[2]*t[1]}function p(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=n[0],c=n[1],h=n[2],u=n[3];return t[0]=r*s+o*c,t[1]=i*s+a*c,t[2]=r*h+o*u,t[3]=i*h+a*u,t}function b(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(n),c=Math.cos(n);return t[0]=r*c+o*s,t[1]=i*c+a*s,t[2]=r*-s+o*c,t[3]=i*-s+a*c,t}function g(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=n[0],c=n[1];return t[0]=r*s,t[1]=i*s,t[2]=o*c,t[3]=a*c,t}function A(t,e){var n=Math.sin(e),r=Math.cos(e);return t[0]=r,t[1]=n,t[2]=-n,t[3]=r,t}function m(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=e[1],t}function x(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function M(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))}function O(t,e,n,r){return t[2]=r[2]/r[0],n[0]=r[0],n[1]=r[1],n[3]=r[3]-t[2]*n[1],[t,e,n]}function w(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t[3]=e[3]+n[3],t}function T(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t[3]=e[3]-n[3],t}function E(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function R(t,e){var n=t[0],r=t[1],o=t[2],a=t[3],s=e[0],c=e[1],h=e[2],u=e[3];return Math.abs(n-s)<=i.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(r-c)<=i.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(o-h)<=i.EPSILON*Math.max(1,Math.abs(o),Math.abs(h))&&Math.abs(a-u)<=i.EPSILON*Math.max(1,Math.abs(a),Math.abs(u))}function V(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t}function y(t,e,n,r){return t[0]=e[0]+n[0]*r,t[1]=e[1]+n[1]*r,t[2]=e[2]+n[2]*r,t[3]=e[3]+n[3]*r,t}e.mul=p,e.sub=T},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sub=e.mul=void 0,e.create=a,e.clone=s,e.copy=c,e.identity=h,e.fromValues=u,e.set=d,e.invert=l,e.determinant=v,e.multiply=f,e.rotate=_,e.scale=p,e.translate=b,e.fromRotation=g,e.fromScaling=A,e.fromTranslation=m,e.str=x,e.frob=M,e.add=O,e.subtract=w,e.multiplyScalar=T,e.multiplyScalarAndAdd=E,e.exactEquals=R,e.equals=V;var r=n(0),i=o(r);function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(){var t=new i.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function s(t){var e=new i.ARRAY_TYPE(6);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function c(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function h(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function u(t,e,n,r,o,a){var s=new i.ARRAY_TYPE(6);return s[0]=t,s[1]=e,s[2]=n,s[3]=r,s[4]=o,s[5]=a,s}function d(t,e,n,r,i,o,a){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t[4]=o,t[5]=a,t}function l(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],s=e[5],c=n*o-r*i;return c?(c=1/c,t[0]=o*c,t[1]=-r*c,t[2]=-i*c,t[3]=n*c,t[4]=(i*s-o*a)*c,t[5]=(r*a-n*s)*c,t):null}function v(t){return t[0]*t[3]-t[1]*t[2]}function f(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=n[0],u=n[1],d=n[2],l=n[3],v=n[4],f=n[5];return t[0]=r*h+o*u,t[1]=i*h+a*u,t[2]=r*d+o*l,t[3]=i*d+a*l,t[4]=r*v+o*f+s,t[5]=i*v+a*f+c,t}function _(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=Math.sin(n),u=Math.cos(n);return t[0]=r*u+o*h,t[1]=i*u+a*h,t[2]=r*-h+o*u,t[3]=i*-h+a*u,t[4]=s,t[5]=c,t}function p(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=n[0],u=n[1];return t[0]=r*h,t[1]=i*h,t[2]=o*u,t[3]=a*u,t[4]=s,t[5]=c,t}function b(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=n[0],u=n[1];return t[0]=r,t[1]=i,t[2]=o,t[3]=a,t[4]=r*h+o*u+s,t[5]=i*h+a*u+c,t}function g(t,e){var n=Math.sin(e),r=Math.cos(e);return t[0]=r,t[1]=n,t[2]=-n,t[3]=r,t[4]=0,t[5]=0,t}function A(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=e[1],t[4]=0,t[5]=0,t}function m(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=e[0],t[5]=e[1],t}function x(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"}function M(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)}function O(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t[3]=e[3]+n[3],t[4]=e[4]+n[4],t[5]=e[5]+n[5],t}function w(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t[3]=e[3]-n[3],t[4]=e[4]-n[4],t[5]=e[5]-n[5],t}function T(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*n,t[5]=e[5]*n,t}function E(t,e,n,r){return t[0]=e[0]+n[0]*r,t[1]=e[1]+n[1]*r,t[2]=e[2]+n[2]*r,t[3]=e[3]+n[3]*r,t[4]=e[4]+n[4]*r,t[5]=e[5]+n[5]*r,t}function R(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]}function V(t,e){var n=t[0],r=t[1],o=t[2],a=t[3],s=t[4],c=t[5],h=e[0],u=e[1],d=e[2],l=e[3],v=e[4],f=e[5];return Math.abs(n-h)<=i.EPSILON*Math.max(1,Math.abs(n),Math.abs(h))&&Math.abs(r-u)<=i.EPSILON*Math.max(1,Math.abs(r),Math.abs(u))&&Math.abs(o-d)<=i.EPSILON*Math.max(1,Math.abs(o),Math.abs(d))&&Math.abs(a-l)<=i.EPSILON*Math.max(1,Math.abs(a),Math.abs(l))&&Math.abs(s-v)<=i.EPSILON*Math.max(1,Math.abs(s),Math.abs(v))&&Math.abs(c-f)<=i.EPSILON*Math.max(1,Math.abs(c),Math.abs(f))}e.mul=f,e.sub=w},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sub=e.mul=void 0,e.create=a,e.clone=s,e.copy=c,e.fromValues=h,e.set=u,e.identity=d,e.transpose=l,e.invert=v,e.adjoint=f,e.determinant=_,e.multiply=p,e.translate=b,e.scale=g,e.rotate=A,e.rotateX=m,e.rotateY=x,e.rotateZ=M,e.fromTranslation=O,e.fromScaling=w,e.fromRotation=T,e.fromXRotation=E,e.fromYRotation=R,e.fromZRotation=V,e.fromRotationTranslation=y,e.getTranslation=S,e.getScaling=D,e.getRotation=N,e.fromRotationTranslationScale=I,e.fromRotationTranslationScaleOrigin=P,e.fromQuat=C,e.frustum=L,e.perspective=B,e.perspectiveFromFieldOfView=j,e.ortho=U,e.lookAt=F,e.targetTo=Y,e.str=W,e.frob=G,e.add=k,e.subtract=z,e.multiplyScalar=q,e.multiplyScalarAndAdd=H,e.exactEquals=X,e.equals=K;var r=n(0),i=o(r);function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(){var t=new i.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function s(t){var e=new i.ARRAY_TYPE(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function c(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function h(t,e,n,r,o,a,s,c,h,u,d,l,v,f,_,p){var b=new i.ARRAY_TYPE(16);return b[0]=t,b[1]=e,b[2]=n,b[3]=r,b[4]=o,b[5]=a,b[6]=s,b[7]=c,b[8]=h,b[9]=u,b[10]=d,b[11]=l,b[12]=v,b[13]=f,b[14]=_,b[15]=p,b}function u(t,e,n,r,i,o,a,s,c,h,u,d,l,v,f,_,p){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t[4]=o,t[5]=a,t[6]=s,t[7]=c,t[8]=h,t[9]=u,t[10]=d,t[11]=l,t[12]=v,t[13]=f,t[14]=_,t[15]=p,t}function d(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function l(t,e){if(t===e){var n=e[1],r=e[2],i=e[3],o=e[6],a=e[7],s=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=n,t[6]=e[9],t[7]=e[13],t[8]=r,t[9]=o,t[11]=e[14],t[12]=i,t[13]=a,t[14]=s}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function v(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],s=e[5],c=e[6],h=e[7],u=e[8],d=e[9],l=e[10],v=e[11],f=e[12],_=e[13],p=e[14],b=e[15],g=n*s-r*a,A=n*c-i*a,m=n*h-o*a,x=r*c-i*s,M=r*h-o*s,O=i*h-o*c,w=u*_-d*f,T=u*p-l*f,E=u*b-v*f,R=d*p-l*_,V=d*b-v*_,y=l*b-v*p,S=g*y-A*V+m*R+x*E-M*T+O*w;return S?(S=1/S,t[0]=(s*y-c*V+h*R)*S,t[1]=(i*V-r*y-o*R)*S,t[2]=(_*O-p*M+b*x)*S,t[3]=(l*M-d*O-v*x)*S,t[4]=(c*E-a*y-h*T)*S,t[5]=(n*y-i*E+o*T)*S,t[6]=(p*m-f*O-b*A)*S,t[7]=(u*O-l*m+v*A)*S,t[8]=(a*V-s*E+h*w)*S,t[9]=(r*E-n*V-o*w)*S,t[10]=(f*M-_*m+b*g)*S,t[11]=(d*m-u*M-v*g)*S,t[12]=(s*T-a*R-c*w)*S,t[13]=(n*R-r*T+i*w)*S,t[14]=(_*A-f*x-p*g)*S,t[15]=(u*x-d*A+l*g)*S,t):null}function f(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],s=e[5],c=e[6],h=e[7],u=e[8],d=e[9],l=e[10],v=e[11],f=e[12],_=e[13],p=e[14],b=e[15];return t[0]=s*(l*b-v*p)-d*(c*b-h*p)+_*(c*v-h*l),t[1]=-(r*(l*b-v*p)-d*(i*b-o*p)+_*(i*v-o*l)),t[2]=r*(c*b-h*p)-s*(i*b-o*p)+_*(i*h-o*c),t[3]=-(r*(c*v-h*l)-s*(i*v-o*l)+d*(i*h-o*c)),t[4]=-(a*(l*b-v*p)-u*(c*b-h*p)+f*(c*v-h*l)),t[5]=n*(l*b-v*p)-u*(i*b-o*p)+f*(i*v-o*l),t[6]=-(n*(c*b-h*p)-a*(i*b-o*p)+f*(i*h-o*c)),t[7]=n*(c*v-h*l)-a*(i*v-o*l)+u*(i*h-o*c),t[8]=a*(d*b-v*_)-u*(s*b-h*_)+f*(s*v-h*d),t[9]=-(n*(d*b-v*_)-u*(r*b-o*_)+f*(r*v-o*d)),t[10]=n*(s*b-h*_)-a*(r*b-o*_)+f*(r*h-o*s),t[11]=-(n*(s*v-h*d)-a*(r*v-o*d)+u*(r*h-o*s)),t[12]=-(a*(d*p-l*_)-u*(s*p-c*_)+f*(s*l-c*d)),t[13]=n*(d*p-l*_)-u*(r*p-i*_)+f*(r*l-i*d),t[14]=-(n*(s*p-c*_)-a*(r*p-i*_)+f*(r*c-i*s)),t[15]=n*(s*l-c*d)-a*(r*l-i*d)+u*(r*c-i*s),t}function _(t){var e=t[0],n=t[1],r=t[2],i=t[3],o=t[4],a=t[5],s=t[6],c=t[7],h=t[8],u=t[9],d=t[10],l=t[11],v=t[12],f=t[13],_=t[14],p=t[15],b=e*a-n*o,g=e*s-r*o,A=e*c-i*o,m=n*s-r*a,x=n*c-i*a,M=r*c-i*s,O=h*f-u*v,w=h*_-d*v,T=h*p-l*v,E=u*_-d*f,R=u*p-l*f,V=d*p-l*_;return b*V-g*R+A*E+m*T-x*w+M*O}function p(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],h=e[6],u=e[7],d=e[8],l=e[9],v=e[10],f=e[11],_=e[12],p=e[13],b=e[14],g=e[15],A=n[0],m=n[1],x=n[2],M=n[3];return t[0]=A*r+m*s+x*d+M*_,t[1]=A*i+m*c+x*l+M*p,t[2]=A*o+m*h+x*v+M*b,t[3]=A*a+m*u+x*f+M*g,A=n[4],m=n[5],x=n[6],M=n[7],t[4]=A*r+m*s+x*d+M*_,t[5]=A*i+m*c+x*l+M*p,t[6]=A*o+m*h+x*v+M*b,t[7]=A*a+m*u+x*f+M*g,A=n[8],m=n[9],x=n[10],M=n[11],t[8]=A*r+m*s+x*d+M*_,t[9]=A*i+m*c+x*l+M*p,t[10]=A*o+m*h+x*v+M*b,t[11]=A*a+m*u+x*f+M*g,A=n[12],m=n[13],x=n[14],M=n[15],t[12]=A*r+m*s+x*d+M*_,t[13]=A*i+m*c+x*l+M*p,t[14]=A*o+m*h+x*v+M*b,t[15]=A*a+m*u+x*f+M*g,t}function b(t,e,n){var r=n[0],i=n[1],o=n[2],a=void 0,s=void 0,c=void 0,h=void 0,u=void 0,d=void 0,l=void 0,v=void 0,f=void 0,_=void 0,p=void 0,b=void 0;return e===t?(t[12]=e[0]*r+e[4]*i+e[8]*o+e[12],t[13]=e[1]*r+e[5]*i+e[9]*o+e[13],t[14]=e[2]*r+e[6]*i+e[10]*o+e[14],t[15]=e[3]*r+e[7]*i+e[11]*o+e[15]):(a=e[0],s=e[1],c=e[2],h=e[3],u=e[4],d=e[5],l=e[6],v=e[7],f=e[8],_=e[9],p=e[10],b=e[11],t[0]=a,t[1]=s,t[2]=c,t[3]=h,t[4]=u,t[5]=d,t[6]=l,t[7]=v,t[8]=f,t[9]=_,t[10]=p,t[11]=b,t[12]=a*r+u*i+f*o+e[12],t[13]=s*r+d*i+_*o+e[13],t[14]=c*r+l*i+p*o+e[14],t[15]=h*r+v*i+b*o+e[15]),t}function g(t,e,n){var r=n[0],i=n[1],o=n[2];return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*o,t[9]=e[9]*o,t[10]=e[10]*o,t[11]=e[11]*o,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function A(t,e,n,r){var o=r[0],a=r[1],s=r[2],c=Math.sqrt(o*o+a*a+s*s),h=void 0,u=void 0,d=void 0,l=void 0,v=void 0,f=void 0,_=void 0,p=void 0,b=void 0,g=void 0,A=void 0,m=void 0,x=void 0,M=void 0,O=void 0,w=void 0,T=void 0,E=void 0,R=void 0,V=void 0,y=void 0,S=void 0,D=void 0,N=void 0;return Math.abs(c)<i.EPSILON?null:(c=1/c,o*=c,a*=c,s*=c,h=Math.sin(n),u=Math.cos(n),d=1-u,l=e[0],v=e[1],f=e[2],_=e[3],p=e[4],b=e[5],g=e[6],A=e[7],m=e[8],x=e[9],M=e[10],O=e[11],w=o*o*d+u,T=a*o*d+s*h,E=s*o*d-a*h,R=o*a*d-s*h,V=a*a*d+u,y=s*a*d+o*h,S=o*s*d+a*h,D=a*s*d-o*h,N=s*s*d+u,t[0]=l*w+p*T+m*E,t[1]=v*w+b*T+x*E,t[2]=f*w+g*T+M*E,t[3]=_*w+A*T+O*E,t[4]=l*R+p*V+m*y,t[5]=v*R+b*V+x*y,t[6]=f*R+g*V+M*y,t[7]=_*R+A*V+O*y,t[8]=l*S+p*D+m*N,t[9]=v*S+b*D+x*N,t[10]=f*S+g*D+M*N,t[11]=_*S+A*D+O*N,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)}function m(t,e,n){var r=Math.sin(n),i=Math.cos(n),o=e[4],a=e[5],s=e[6],c=e[7],h=e[8],u=e[9],d=e[10],l=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=o*i+h*r,t[5]=a*i+u*r,t[6]=s*i+d*r,t[7]=c*i+l*r,t[8]=h*i-o*r,t[9]=u*i-a*r,t[10]=d*i-s*r,t[11]=l*i-c*r,t}function x(t,e,n){var r=Math.sin(n),i=Math.cos(n),o=e[0],a=e[1],s=e[2],c=e[3],h=e[8],u=e[9],d=e[10],l=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=o*i-h*r,t[1]=a*i-u*r,t[2]=s*i-d*r,t[3]=c*i-l*r,t[8]=o*r+h*i,t[9]=a*r+u*i,t[10]=s*r+d*i,t[11]=c*r+l*i,t}function M(t,e,n){var r=Math.sin(n),i=Math.cos(n),o=e[0],a=e[1],s=e[2],c=e[3],h=e[4],u=e[5],d=e[6],l=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=o*i+h*r,t[1]=a*i+u*r,t[2]=s*i+d*r,t[3]=c*i+l*r,t[4]=h*i-o*r,t[5]=u*i-a*r,t[6]=d*i-s*r,t[7]=l*i-c*r,t}function O(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function w(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function T(t,e,n){var r=n[0],o=n[1],a=n[2],s=Math.sqrt(r*r+o*o+a*a),c=void 0,h=void 0,u=void 0;return Math.abs(s)<i.EPSILON?null:(s=1/s,r*=s,o*=s,a*=s,c=Math.sin(e),h=Math.cos(e),u=1-h,t[0]=r*r*u+h,t[1]=o*r*u+a*c,t[2]=a*r*u-o*c,t[3]=0,t[4]=r*o*u-a*c,t[5]=o*o*u+h,t[6]=a*o*u+r*c,t[7]=0,t[8]=r*a*u+o*c,t[9]=o*a*u-r*c,t[10]=a*a*u+h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function E(t,e){var n=Math.sin(e),r=Math.cos(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=n,t[7]=0,t[8]=0,t[9]=-n,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function R(t,e){var n=Math.sin(e),r=Math.cos(e);return t[0]=r,t[1]=0,t[2]=-n,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=n,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function V(t,e){var n=Math.sin(e),r=Math.cos(e);return t[0]=r,t[1]=n,t[2]=0,t[3]=0,t[4]=-n,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function y(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=r+r,c=i+i,h=o+o,u=r*s,d=r*c,l=r*h,v=i*c,f=i*h,_=o*h,p=a*s,b=a*c,g=a*h;return t[0]=1-(v+_),t[1]=d+g,t[2]=l-b,t[3]=0,t[4]=d-g,t[5]=1-(u+_),t[6]=f+p,t[7]=0,t[8]=l+b,t[9]=f-p,t[10]=1-(u+v),t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function S(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}function D(t,e){var n=e[0],r=e[1],i=e[2],o=e[4],a=e[5],s=e[6],c=e[8],h=e[9],u=e[10];return t[0]=Math.sqrt(n*n+r*r+i*i),t[1]=Math.sqrt(o*o+a*a+s*s),t[2]=Math.sqrt(c*c+h*h+u*u),t}function N(t,e){var n=e[0]+e[5]+e[10],r=0;return n>0?(r=2*Math.sqrt(n+1),t[3]=.25*r,t[0]=(e[6]-e[9])/r,t[1]=(e[8]-e[2])/r,t[2]=(e[1]-e[4])/r):e[0]>e[5]&e[0]>e[10]?(r=2*Math.sqrt(1+e[0]-e[5]-e[10]),t[3]=(e[6]-e[9])/r,t[0]=.25*r,t[1]=(e[1]+e[4])/r,t[2]=(e[8]+e[2])/r):e[5]>e[10]?(r=2*Math.sqrt(1+e[5]-e[0]-e[10]),t[3]=(e[8]-e[2])/r,t[0]=(e[1]+e[4])/r,t[1]=.25*r,t[2]=(e[6]+e[9])/r):(r=2*Math.sqrt(1+e[10]-e[0]-e[5]),t[3]=(e[1]-e[4])/r,t[0]=(e[8]+e[2])/r,t[1]=(e[6]+e[9])/r,t[2]=.25*r),t}function I(t,e,n,r){var i=e[0],o=e[1],a=e[2],s=e[3],c=i+i,h=o+o,u=a+a,d=i*c,l=i*h,v=i*u,f=o*h,_=o*u,p=a*u,b=s*c,g=s*h,A=s*u,m=r[0],x=r[1],M=r[2];return t[0]=(1-(f+p))*m,t[1]=(l+A)*m,t[2]=(v-g)*m,t[3]=0,t[4]=(l-A)*x,t[5]=(1-(d+p))*x,t[6]=(_+b)*x,t[7]=0,t[8]=(v+g)*M,t[9]=(_-b)*M,t[10]=(1-(d+f))*M,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function P(t,e,n,r,i){var o=e[0],a=e[1],s=e[2],c=e[3],h=o+o,u=a+a,d=s+s,l=o*h,v=o*u,f=o*d,_=a*u,p=a*d,b=s*d,g=c*h,A=c*u,m=c*d,x=r[0],M=r[1],O=r[2],w=i[0],T=i[1],E=i[2];return t[0]=(1-(_+b))*x,t[1]=(v+m)*x,t[2]=(f-A)*x,t[3]=0,t[4]=(v-m)*M,t[5]=(1-(l+b))*M,t[6]=(p+g)*M,t[7]=0,t[8]=(f+A)*O,t[9]=(p-g)*O,t[10]=(1-(l+_))*O,t[11]=0,t[12]=n[0]+w-(t[0]*w+t[4]*T+t[8]*E),t[13]=n[1]+T-(t[1]*w+t[5]*T+t[9]*E),t[14]=n[2]+E-(t[2]*w+t[6]*T+t[10]*E),t[15]=1,t}function C(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=n+n,s=r+r,c=i+i,h=n*a,u=r*a,d=r*s,l=i*a,v=i*s,f=i*c,_=o*a,p=o*s,b=o*c;return t[0]=1-d-f,t[1]=u+b,t[2]=l-p,t[3]=0,t[4]=u-b,t[5]=1-h-f,t[6]=v+_,t[7]=0,t[8]=l+p,t[9]=v-_,t[10]=1-h-d,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function L(t,e,n,r,i,o,a){var s=1/(n-e),c=1/(i-r),h=1/(o-a);return t[0]=2*o*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*o*c,t[6]=0,t[7]=0,t[8]=(n+e)*s,t[9]=(i+r)*c,t[10]=(a+o)*h,t[11]=-1,t[12]=0,t[13]=0,t[14]=a*o*2*h,t[15]=0,t}function B(t,e,n,r,i){var o=1/Math.tan(e/2),a=1/(r-i);return t[0]=o/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(i+r)*a,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*i*r*a,t[15]=0,t}function j(t,e,n,r){var i=Math.tan(e.upDegrees*Math.PI/180),o=Math.tan(e.downDegrees*Math.PI/180),a=Math.tan(e.leftDegrees*Math.PI/180),s=Math.tan(e.rightDegrees*Math.PI/180),c=2/(a+s),h=2/(i+o);return t[0]=c,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=h,t[6]=0,t[7]=0,t[8]=-(a-s)*c*.5,t[9]=(i-o)*h*.5,t[10]=r/(n-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*n/(n-r),t[15]=0,t}function U(t,e,n,r,i,o,a){var s=1/(e-n),c=1/(r-i),h=1/(o-a);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(e+n)*s,t[13]=(i+r)*c,t[14]=(a+o)*h,t[15]=1,t}function F(t,e,n,r){var o=void 0,a=void 0,s=void 0,c=void 0,h=void 0,u=void 0,d=void 0,l=void 0,v=void 0,f=void 0,_=e[0],p=e[1],b=e[2],g=r[0],A=r[1],m=r[2],x=n[0],M=n[1],O=n[2];return Math.abs(_-x)<i.EPSILON&&Math.abs(p-M)<i.EPSILON&&Math.abs(b-O)<i.EPSILON?mat4.identity(t):(d=_-x,l=p-M,v=b-O,f=1/Math.sqrt(d*d+l*l+v*v),d*=f,l*=f,v*=f,o=A*v-m*l,a=m*d-g*v,s=g*l-A*d,f=Math.sqrt(o*o+a*a+s*s),f?(f=1/f,o*=f,a*=f,s*=f):(o=0,a=0,s=0),c=l*s-v*a,h=v*o-d*s,u=d*a-l*o,f=Math.sqrt(c*c+h*h+u*u),f?(f=1/f,c*=f,h*=f,u*=f):(c=0,h=0,u=0),t[0]=o,t[1]=c,t[2]=d,t[3]=0,t[4]=a,t[5]=h,t[6]=l,t[7]=0,t[8]=s,t[9]=u,t[10]=v,t[11]=0,t[12]=-(o*_+a*p+s*b),t[13]=-(c*_+h*p+u*b),t[14]=-(d*_+l*p+v*b),t[15]=1,t)}function Y(t,e,n,r){var i=e[0],o=e[1],a=e[2],s=r[0],c=r[1],h=r[2],u=i-n[0],d=o-n[1],l=a-n[2],v=u*u+d*d+l*l;v>0&&(v=1/Math.sqrt(v),u*=v,d*=v,l*=v);var f=c*l-h*d,_=h*u-s*l,p=s*d-c*u;return t[0]=f,t[1]=_,t[2]=p,t[3]=0,t[4]=d*p-l*_,t[5]=l*f-u*p,t[6]=u*_-d*f,t[7]=0,t[8]=u,t[9]=d,t[10]=l,t[11]=0,t[12]=i,t[13]=o,t[14]=a,t[15]=1,t}function W(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"}function G(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))}function k(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t[3]=e[3]+n[3],t[4]=e[4]+n[4],t[5]=e[5]+n[5],t[6]=e[6]+n[6],t[7]=e[7]+n[7],t[8]=e[8]+n[8],t[9]=e[9]+n[9],t[10]=e[10]+n[10],t[11]=e[11]+n[11],t[12]=e[12]+n[12],t[13]=e[13]+n[13],t[14]=e[14]+n[14],t[15]=e[15]+n[15],t}function z(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t[3]=e[3]-n[3],t[4]=e[4]-n[4],t[5]=e[5]-n[5],t[6]=e[6]-n[6],t[7]=e[7]-n[7],t[8]=e[8]-n[8],t[9]=e[9]-n[9],t[10]=e[10]-n[10],t[11]=e[11]-n[11],t[12]=e[12]-n[12],t[13]=e[13]-n[13],t[14]=e[14]-n[14],t[15]=e[15]-n[15],t}function q(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*n,t[5]=e[5]*n,t[6]=e[6]*n,t[7]=e[7]*n,t[8]=e[8]*n,t[9]=e[9]*n,t[10]=e[10]*n,t[11]=e[11]*n,t[12]=e[12]*n,t[13]=e[13]*n,t[14]=e[14]*n,t[15]=e[15]*n,t}function H(t,e,n,r){return t[0]=e[0]+n[0]*r,t[1]=e[1]+n[1]*r,t[2]=e[2]+n[2]*r,t[3]=e[3]+n[3]*r,t[4]=e[4]+n[4]*r,t[5]=e[5]+n[5]*r,t[6]=e[6]+n[6]*r,t[7]=e[7]+n[7]*r,t[8]=e[8]+n[8]*r,t[9]=e[9]+n[9]*r,t[10]=e[10]+n[10]*r,t[11]=e[11]+n[11]*r,t[12]=e[12]+n[12]*r,t[13]=e[13]+n[13]*r,t[14]=e[14]+n[14]*r,t[15]=e[15]+n[15]*r,t}function X(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]}function K(t,e){var n=t[0],r=t[1],o=t[2],a=t[3],s=t[4],c=t[5],h=t[6],u=t[7],d=t[8],l=t[9],v=t[10],f=t[11],_=t[12],p=t[13],b=t[14],g=t[15],A=e[0],m=e[1],x=e[2],M=e[3],O=e[4],w=e[5],T=e[6],E=e[7],R=e[8],V=e[9],y=e[10],S=e[11],D=e[12],N=e[13],I=e[14],P=e[15];return Math.abs(n-A)<=i.EPSILON*Math.max(1,Math.abs(n),Math.abs(A))&&Math.abs(r-m)<=i.EPSILON*Math.max(1,Math.abs(r),Math.abs(m))&&Math.abs(o-x)<=i.EPSILON*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(a-M)<=i.EPSILON*Math.max(1,Math.abs(a),Math.abs(M))&&Math.abs(s-O)<=i.EPSILON*Math.max(1,Math.abs(s),Math.abs(O))&&Math.abs(c-w)<=i.EPSILON*Math.max(1,Math.abs(c),Math.abs(w))&&Math.abs(h-T)<=i.EPSILON*Math.max(1,Math.abs(h),Math.abs(T))&&Math.abs(u-E)<=i.EPSILON*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(d-R)<=i.EPSILON*Math.max(1,Math.abs(d),Math.abs(R))&&Math.abs(l-V)<=i.EPSILON*Math.max(1,Math.abs(l),Math.abs(V))&&Math.abs(v-y)<=i.EPSILON*Math.max(1,Math.abs(v),Math.abs(y))&&Math.abs(f-S)<=i.EPSILON*Math.max(1,Math.abs(f),Math.abs(S))&&Math.abs(_-D)<=i.EPSILON*Math.max(1,Math.abs(_),Math.abs(D))&&Math.abs(p-N)<=i.EPSILON*Math.max(1,Math.abs(p),Math.abs(N))&&Math.abs(b-I)<=i.EPSILON*Math.max(1,Math.abs(b),Math.abs(I))&&Math.abs(g-P)<=i.EPSILON*Math.max(1,Math.abs(g),Math.abs(P))}e.mul=p,e.sub=z},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setAxes=e.sqlerp=e.rotationTo=e.equals=e.exactEquals=e.normalize=e.sqrLen=e.squaredLength=e.len=e.length=e.lerp=e.dot=e.scale=e.mul=e.add=e.set=e.copy=e.fromValues=e.clone=void 0,e.create=l,e.identity=v,e.setAxisAngle=f,e.getAxisAngle=_,e.multiply=p,e.rotateX=b,e.rotateY=g,e.rotateZ=A,e.calculateW=m,e.slerp=x,e.invert=M,e.conjugate=O,e.fromMat3=w,e.fromEuler=T,e.str=E;var r=n(0),i=d(r),o=n(1),a=d(o),s=n(2),c=d(s),h=n(3),u=d(h);function d(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function l(){var t=new i.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function v(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function f(t,e,n){n*=.5;var r=Math.sin(n);return t[0]=r*e[0],t[1]=r*e[1],t[2]=r*e[2],t[3]=Math.cos(n),t}function _(t,e){var n=2*Math.acos(e[3]),r=Math.sin(n/2);return 0!=r?(t[0]=e[0]/r,t[1]=e[1]/r,t[2]=e[2]/r):(t[0]=1,t[1]=0,t[2]=0),n}function p(t,e,n){var r=e[0],i=e[1],o=e[2],a=e[3],s=n[0],c=n[1],h=n[2],u=n[3];return t[0]=r*u+a*s+i*h-o*c,t[1]=i*u+a*c+o*s-r*h,t[2]=o*u+a*h+r*c-i*s,t[3]=a*u-r*s-i*c-o*h,t}function b(t,e,n){n*=.5;var r=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(n),c=Math.cos(n);return t[0]=r*c+a*s,t[1]=i*c+o*s,t[2]=o*c-i*s,t[3]=a*c-r*s,t}function g(t,e,n){n*=.5;var r=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(n),c=Math.cos(n);return t[0]=r*c-o*s,t[1]=i*c+a*s,t[2]=o*c+r*s,t[3]=a*c-i*s,t}function A(t,e,n){n*=.5;var r=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(n),c=Math.cos(n);return t[0]=r*c+i*s,t[1]=i*c-r*s,t[2]=o*c+a*s,t[3]=a*c-o*s,t}function m(t,e){var n=e[0],r=e[1],i=e[2];return t[0]=n,t[1]=r,t[2]=i,t[3]=Math.sqrt(Math.abs(1-n*n-r*r-i*i)),t}function x(t,e,n,r){var i=e[0],o=e[1],a=e[2],s=e[3],c=n[0],h=n[1],u=n[2],d=n[3],l=void 0,v=void 0,f=void 0,_=void 0,p=void 0;return v=i*c+o*h+a*u+s*d,v<0&&(v=-v,c=-c,h=-h,u=-u,d=-d),1-v>1e-6?(l=Math.acos(v),f=Math.sin(l),_=Math.sin((1-r)*l)/f,p=Math.sin(r*l)/f):(_=1-r,p=r),t[0]=_*i+p*c,t[1]=_*o+p*h,t[2]=_*a+p*u,t[3]=_*s+p*d,t}function M(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=n*n+r*r+i*i+o*o,s=a?1/a:0;return t[0]=-n*s,t[1]=-r*s,t[2]=-i*s,t[3]=o*s,t}function O(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t}function w(t,e){var n=e[0]+e[4]+e[8],r=void 0;if(n>0)r=Math.sqrt(n+1),t[3]=.5*r,r=.5/r,t[0]=(e[5]-e[7])*r,t[1]=(e[6]-e[2])*r,t[2]=(e[1]-e[3])*r;else{var i=0;e[4]>e[0]&&(i=1),e[8]>e[3*i+i]&&(i=2);var o=(i+1)%3,a=(i+2)%3;r=Math.sqrt(e[3*i+i]-e[3*o+o]-e[3*a+a]+1),t[i]=.5*r,r=.5/r,t[3]=(e[3*o+a]-e[3*a+o])*r,t[o]=(e[3*o+i]+e[3*i+o])*r,t[a]=(e[3*a+i]+e[3*i+a])*r}return t}function T(t,e,n,r){var i=.5*Math.PI/180;e*=i,n*=i,r*=i;var o=Math.sin(e),a=Math.cos(e),s=Math.sin(n),c=Math.cos(n),h=Math.sin(r),u=Math.cos(r);return t[0]=o*c*u-a*s*h,t[1]=a*s*u+o*c*h,t[2]=a*c*h-o*s*u,t[3]=a*c*u+o*s*h,t}function E(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}e.clone=u.clone,e.fromValues=u.fromValues,e.copy=u.copy,e.set=u.set,e.add=u.add,e.mul=p,e.scale=u.scale,e.dot=u.dot,e.lerp=u.lerp;var R=e.length=u.length,V=(e.len=R,e.squaredLength=u.squaredLength),y=(e.sqrLen=V,e.normalize=u.normalize);e.exactEquals=u.exactEquals,e.equals=u.equals,e.rotationTo=function(){var t=c.create(),e=c.fromValues(1,0,0),n=c.fromValues(0,1,0);return function(r,i,o){var a=c.dot(i,o);return a<-.999999?(c.cross(t,e,i),c.len(t)<1e-6&&c.cross(t,n,i),c.normalize(t,t),f(r,t,Math.PI),r):a>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(c.cross(t,i,o),r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=1+a,y(r,r))}}(),e.sqlerp=function(){var t=l(),e=l();return function(n,r,i,o,a,s){return x(t,r,a,s),x(e,i,o,s),x(n,t,e,2*s*(1-s)),n}}(),e.setAxes=function(){var t=a.create();return function(e,n,r,i){return t[0]=r[0],t[3]=r[1],t[6]=r[2],t[1]=i[0],t[4]=i[1],t[7]=i[2],t[2]=-n[0],t[5]=-n[1],t[8]=-n[2],y(e,w(e,t))}}()},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.forEach=e.sqrLen=e.sqrDist=e.dist=e.div=e.mul=e.sub=e.len=void 0,e.create=a,e.clone=s,e.fromValues=c,e.copy=h,e.set=u,e.add=d,e.subtract=l,e.multiply=v,e.divide=f,e.ceil=_,e.floor=p,e.min=b,e.max=g,e.round=A,e.scale=m,e.scaleAndAdd=x,e.distance=M,e.squaredDistance=O,e.length=w,e.squaredLength=T,e.negate=E,e.inverse=R,e.normalize=V,e.dot=y,e.cross=S,e.lerp=D,e.random=N,e.transformMat2=I,e.transformMat2d=P,e.transformMat3=C,e.transformMat4=L,e.str=B,e.exactEquals=j,e.equals=U;var r=n(0),i=o(r);function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(){var t=new i.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t}function s(t){var e=new i.ARRAY_TYPE(2);return e[0]=t[0],e[1]=t[1],e}function c(t,e){var n=new i.ARRAY_TYPE(2);return n[0]=t,n[1]=e,n}function h(t,e){return t[0]=e[0],t[1]=e[1],t}function u(t,e,n){return t[0]=e,t[1]=n,t}function d(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t}function l(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t}function v(t,e,n){return t[0]=e[0]*n[0],t[1]=e[1]*n[1],t}function f(t,e,n){return t[0]=e[0]/n[0],t[1]=e[1]/n[1],t}function _(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t}function p(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t}function b(t,e,n){return t[0]=Math.min(e[0],n[0]),t[1]=Math.min(e[1],n[1]),t}function g(t,e,n){return t[0]=Math.max(e[0],n[0]),t[1]=Math.max(e[1],n[1]),t}function A(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t}function m(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t}function x(t,e,n,r){return t[0]=e[0]+n[0]*r,t[1]=e[1]+n[1]*r,t}function M(t,e){var n=e[0]-t[0],r=e[1]-t[1];return Math.sqrt(n*n+r*r)}function O(t,e){var n=e[0]-t[0],r=e[1]-t[1];return n*n+r*r}function w(t){var e=t[0],n=t[1];return Math.sqrt(e*e+n*n)}function T(t){var e=t[0],n=t[1];return e*e+n*n}function E(t,e){return t[0]=-e[0],t[1]=-e[1],t}function R(t,e){return t[0]=1/e[0],t[1]=1/e[1],t}function V(t,e){var n=e[0],r=e[1],i=n*n+r*r;return i>0&&(i=1/Math.sqrt(i),t[0]=e[0]*i,t[1]=e[1]*i),t}function y(t,e){return t[0]*e[0]+t[1]*e[1]}function S(t,e,n){var r=e[0]*n[1]-e[1]*n[0];return t[0]=t[1]=0,t[2]=r,t}function D(t,e,n,r){var i=e[0],o=e[1];return t[0]=i+r*(n[0]-i),t[1]=o+r*(n[1]-o),t}function N(t,e){e=e||1;var n=2*i.RANDOM()*Math.PI;return t[0]=Math.cos(n)*e,t[1]=Math.sin(n)*e,t}function I(t,e,n){var r=e[0],i=e[1];return t[0]=n[0]*r+n[2]*i,t[1]=n[1]*r+n[3]*i,t}function P(t,e,n){var r=e[0],i=e[1];return t[0]=n[0]*r+n[2]*i+n[4],t[1]=n[1]*r+n[3]*i+n[5],t}function C(t,e,n){var r=e[0],i=e[1];return t[0]=n[0]*r+n[3]*i+n[6],t[1]=n[1]*r+n[4]*i+n[7],t}function L(t,e,n){var r=e[0],i=e[1];return t[0]=n[0]*r+n[4]*i+n[12],t[1]=n[1]*r+n[5]*i+n[13],t}function B(t){return"vec2("+t[0]+", "+t[1]+")"}function j(t,e){return t[0]===e[0]&&t[1]===e[1]}function U(t,e){var n=t[0],r=t[1],o=e[0],a=e[1];return Math.abs(n-o)<=i.EPSILON*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(r-a)<=i.EPSILON*Math.max(1,Math.abs(r),Math.abs(a))}e.len=w,e.sub=l,e.mul=v,e.div=f,e.dist=M,e.sqrDist=O,e.sqrLen=T,e.forEach=function(){var t=a();return function(e,n,r,i,o,a){var s=void 0,c=void 0;for(n||(n=2),r||(r=0),c=i?Math.min(i*n+r,e.length):e.length,s=r;s<c;s+=n)t[0]=e[s],t[1]=e[s+1],o(t,t,a),e[s]=t[0],e[s+1]=t[1];return e}}()}])}))},cff6:function(t,e,n){t.exports=n.p+"static/img/coord2.d710514a.png"},d12e:function(t,e,n){"use strict";n("6935")},d733:function(t,e,n){"use strict";n("3d36")},de67:function(t,e,n){t.exports=n.p+"static/img/matrix2.c2c586e0.png"},e891:function(t,e,n){"use strict";n("9c9c")}});
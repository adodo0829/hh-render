# 1.地图性能瓶颈问题

内存方向， 渲染方向

## 内存方向

地图支持的渲染元素展示数量优化

由于 gpu 和 cpu 都有着内存大小限制，纯静态地图下，我们测试的极限是 3-4w 个储位节点；
地图渲染数量最大的是，点，储位，我们的实现方式是用 图片纹理

#### gpu 内存

- 纹理切图，宽高最好是 2 的幂，可以减少 GPU 的计算负担
- 纹理压缩，可以减少图形数据
- 纹理合并（未验证）
- 开发自定义的网格 mesh 需要自己开发(顶点, 片段)着色器代码
  相比通过 Graphics 生成的元素实例减少很多不必要属性绑定
  顶点数据优化，双向边 20 个顶点 优化为 10 个顶点
  顶点数据优化，单向边 12 个顶点 优化为 7 个顶点

#### cpu 内存

点的类型：储存点，巷道，胡同，休息点，等待点，充电点，门，队列，反光柱，反光条，二维码，旋转点
合并业务逻辑元素，合并为一个图层来实现，
通过增加 showType 来渲染不同类型的业务元素

设备的状态纹理 bianhua

### 产品侧内存优化

产品侧：大地图分层，按楼层 分为小地图进行渲染

## 渲染方向(动画性能)

### drawCall 调用层绘制优化

1.开启动画循环，去掉 pixi 自带的 ticker， 手动实现了一个 ticker， 每个 16 毫秒去渲染一次；  
2.去掉代码里手动调用渲染器的代码，避免不必要的渲染

`ticker 时间控制器`
在固定的时间间隔内触发事件或执行函数。这个概念在动画和游戏开发中非常常见，因为它可以帮助开发者同步动画帧和处理时间相关的逻辑。

Ticker 的作用：
时间控制：确保动画和事件在固定的时间间隔内发生，这对于创建平滑的动画效果至关重要。
帧同步：在游戏开发中，ticker 可以用来同步游戏的逻辑更新和渲染帧，确保游戏运行的流畅性。
资源管理：通过控制事件触发的频率，ticker 可以帮助节省计算资源，避免不必要的计算。

基于 requestAnimationFrame 或者 setInterval 实现

Ticker 的注意事项：
性能影响：不当的 ticker 实现可能会导致性能问题，比如 CPU 占用过高或者动画卡顿。
清理：在不再需要 ticker 时，应该使用 clearInterval 或 cancelAnimationFrame 来停止 ticker，避免内存泄漏。
时间精度：setInterval 和 setTimeout 的精度可能不够高，对于需要高精度时间控制的动画，requestAnimationFrame 是更好的选择。
跨浏览器兼容性：不同的浏览器可能对 requestAnimationFrame 的支持和实现有所不同，需要进行兼容性处理。

### 数据层

当动画设备数增加到 200, 随着时间的推移， 会出现小车重叠的现象, 以及动画稍有延时的问题, 即数据推送和消费渲染速度不在频率不一致

因为同时推送 200 台设备的实时动态点位，我们每个设备的动画队列里存储了很多帧节点， 由于渲染量和计算量都增大，导致前端渲染跟不上 后台的推送速度，可能小车在 b 点，但是数据已经推送到 d 点了，实时性就出现了问题

方案 1:
动画帧固定的补间节点 换成动态的 补间节点数，当渲染比较卡时，fps 低，次数我们就少补一点动画帧节点，加快动队列数据的消费

方案 2：
还是保持固定的补间节点, 删除动画队列中的中间节点数据

方案 3：组合上面
动画主要分为旋转 和 平移，我们可以把同方向的平移帧节点合并，也可以减少绘制次数，意味着每次平移的步长 dx 和 dy 增加，动画显示会没那么平滑

# 地图中的交互问题

1.slam 地图中贝塞尔曲线选中问题

- 曲线边的顶点长度 length 为 N，那么就会产生 N-2 个三角形，N 越大，遍历判断次数越多
- 曲线边宽度过细，鼠标点击选中困难

图层 layer 对象保存了 vertexData 顶点坐标信息

优化思路：
按顶点顺序把 2 个三角形，或者 3/4/5 个合并成一组，形成一个新的多边形区域，然后再判断鼠标点击的点位是否在该区域内，减少遍历判断次数
这样虽然会减少精度，但是扩大一定的模糊选中范围，可以带来性能提升，提示也方便用户更好的选中曲线边
